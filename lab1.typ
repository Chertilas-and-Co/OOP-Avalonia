#import "conf/conf.typ": conf
#show: conf.with(
  title: [= Лабораторная работа №1
    Визуальное проектирование в С\#],
  type: "pract",
  info: (
    author: (
      name: [],
      faculty: [],
      group: "",
      sex: "",
    ),
    inspector: (
      degree: "",
      name: "",
    ),
  ),
  settings: (
    title_page: (
      enabled: true,
    ),
    contents_page: (
      enabled: true,
    ),
  ),
)

= Начало работы с Avalonia

== Установка

Avalonia --- это кроссплатформенный фреймворк, работать с ним можно и на Windows, и на Linux, и на MacOS.
Рассмотрим основные способы установки этого фреймворка на разные системы:

=== Visual Studio (только для Windows)

В скриншотах будет приводиться Visual Studio 2026, но алгоритм установки Avalonia на Visual Studio 2022 аналогичен приведённому ниже.

Откройте Visual Studio Installer и нажмите "изменить" около вашей версии Visual Studio.

#figure(
  image(
    "lab1_imports/images/starting_with_avalonia/visual_studio/vs_installer.png",
    width: 80%,
  ),
  caption: [Visual Studio Installer],
)

Добавьте в Visual Studio компонент "Разработка классических приложений .NET".

#figure(
  image(
    "lab1_imports/images/starting_with_avalonia/visual_studio/editing_vs.png",
    width: 80%,
  ),
  caption: [Добавление компонента],
)

После установки откройте Visual Studio, нажмите на вкладку "Расширения" и выберите "Управление расширениями".

#figure(
  image(
    "lab1_imports/images/starting_with_avalonia/visual_studio/extensions.png",
    width: 80%,
  ),
  caption: [Открытие менеджера расширений],
)

Напишите в поиске "Avalonia" и установите расширение Avalonia от Avalonia Team.

#figure(
  image(
    "lab1_imports/images/starting_with_avalonia/visual_studio/avalonia_extension.png",
    width: 80%,
  ),
  caption: [Установка расширения для работы с Avalonia],
)

Выйдите из Visual Studio, в установщике расширений, который должен был появиться вскоре после этого, нажмите "Modify" и дождитесь конца его работы.

#figure(
  image(
    "lab1_imports/images/starting_with_avalonia/visual_studio/vsix_installer.png",
    width: 80%,
  ),
  caption: [VSIX Installer],
)

После этого откройте Visual Studio, начните создавать новый проект, из шаблонов выберите "Avalonia .NET App (Avalonia UI)" и продолжите создание проекта.

#figure(
  image(
    "lab1_imports/images/starting_with_avalonia/visual_studio/avalonia_template.png",
    width: 80%,
  ),
  caption: [Создание проекта],
)

И, в конце концов, Вас встретит окно с готовым проектом Avalonia, с которым Вы можете продолжать работу.

#figure(
  image(
    "lab1_imports/images/starting_with_avalonia/visual_studio/avalonia_final.png",
    width: 80%,
  ),
  caption: [Готовый проект в Visual Studio],
)

=== Visual Studio Code (любые платформы)

Установите следующие расширения: C\# и C\# Dev Kit от Microsoft, Avalonia for VSCode от Avalonia Team и Avalonia Templates от Adel Bakshi.

#figure(
  image(
    "lab1_imports/images/starting_with_avalonia/vs_code/cs.png",
    width: 80%,
  ),
  caption: [C\#],
)

#figure(
  image(
    "lab1_imports/images/starting_with_avalonia/vs_code/cs_dev_kit.png",
    width: 80%,
  ),
  caption: [C\# Dev Kit],
)

#figure(
  image(
    "lab1_imports/images/starting_with_avalonia/vs_code/avalonia_for_vscode.png",
    width: 80%,
  ),
  caption: [Avalonia for VSCode],
)

#figure(
  image(
    "lab1_imports/images/starting_with_avalonia/vs_code/avalonia_templates.png",
    width: 80%,
  ),
  caption: [Avalonia Templates],
)

После этого создайте Avalonia-проект, нажав на кнопку "Create Avalonia Project".

#figure(
  image(
    "lab1_imports/images/starting_with_avalonia/vs_code/avalonia_create.png",
    width: 80%,
  ),
  caption: [Создание проекта],
)

Теперь Вы можете изменять и развивать уже готовый проект в Visual Studio Code.

#figure(
  image(
    "lab1_imports/images/starting_with_avalonia/vs_code/avalonia_final.png",
    width: 80%,
  ),
  caption: [Готовый проект в Visual Studio Code],
)

=== Bash (любые платформы)

Установите .NET на Вашу платформу.
Действия отличаются от системы к системе, поэтому следуйте официальному гайду от Microsoft.

#link("https://learn.microsoft.com/en-us/dotnet/core/install/")

Установите шаблоны Avalonia с помощью следующей команды:

```sh
dotnet new install Avalonia.Templates
```

Создайте из одного из шаблонов проект под названием, например, `MyApp`.

```sh
dotnet new avalonia.app -o MyApp
```

Эта команда создаст новую папку c названием `MyApp`.
Теперь достаточно зайти в эту папку и запустить проект.

```sh
cd MyApp
dotnet run
```

Код приложения Вы можете редактировать с помощью любого текстового редактора.

== Настройка окна приложения

После создания проекта Avalonia App у Вас автоматически появится главное окно --- MainWindow.axaml, а также связанный с ним файл кода MainWindow.axaml.cs.
Файл .axaml содержит описание пользовательского интерфейса в формате XAML, а файл .axaml.cs --- код на C\#, в котором можно обрабатывать события элементов интерфейса.

Изменять свойства окна можно двумя способами:
- через XAML (описание разметки);
- через код C\# (в классе MainWindow).

Пример изменения заголовка и размеров окна:

```xaml
<Window xmlns="https://github.com/avaloniaui"
        Title="Лаба №1. ФИО, группа"
        Width="400" Height="300">
</Window>
```

Цвет фона объекта можно задать свойством Background:

```xaml
<Window Background="AntiqueWhite">
```

Также можно задать и цвет текста:

```xaml
<Window Background="AntiqueWhite" Foreground="Blue">
```

== Размещение элементов интерфейса

Элементы управления (кнопки, поля ввода, надписи и т.д.) размещаются внутри контейнеров разметки Avalonia.
Наиболее распространённые контейнеры:
- `StackPanel` --- размещает элементы в ряд вертикально или горизонтально;
  Пример:

  ```xaml
  <StackPanel Margin="10">
      <TextBlock Text="Введите значение:"/>

      <TextBox Name="textBox1"/>

      <Button Content="Выполнить" Click="OnButtonClick"/>
  </StackPanel>
  ```

- `Grid` --- разбивает пространство окна на сетку со строками и столбцами. Элементы можно размещать, указывая, в какой строке и столбце они находятся.
  Пример:

  ```xaml
  <Grid RowDefinitions="Auto,Auto,Auto,Auto" ColumnDefinitions="Auto,*" Margin="10">
      <TextBlock Text="Введите значение:" Grid.Row="0" Grid.Column="0" VerticalAlignment="Center"/>
      <TextBox Name="textBox1" Grid.Row="0" Grid.Column="1"/>
      <Button Content="Выполнить" Click="OnButtonClick"/>
  </Grid>
  ```

  - `RowDefinitions` и `ColumnDefinitions` задают сетку: здесь 4 строки (по высоте --- `Auto`) и 2 столбца (первый узкий, второй растягивается --- `*`);
  - `Grid.Row` и `Grid.Column` указывают позицию элемента в сетке;
  - `Grid.ColumnSpan="2"` позволяет занять обе колонки (например, кнопкой).
- `Canvas` --- позволяет позиционировать элементы по абсолютным координатам. Каждый элемент имеет свойства `Canvas.Left`, `Canvas.Top`, `Canvas.Right`, `Canvas.Bottom`.
  Пример:

  ```xaml
  <Canvas>
      <TextBlock Text="Введите значение:" Canvas.Left="10" Canvas.Top="20"/>
      <TextBox Name="textBox1" Width="100" Canvas.Left="150" Canvas.Top="15"/>
      <Button Content="Выполнить" Width="120"
              Canvas.Left="10" Canvas.Top="150"
              Click="OnButtonClick"/>
  </Canvas>
  ```

  - Используется абсолютное позиционирование --- каждая координата задаётся вручную;
  - Такой способ удобен для простых макетов, где нужно точно контролировать расположение элементов. Однако для адаптивных интерфейсов лучше использовать `Grid` или `StackPanel`.

== Размещение строки ввода (`TextBox`)

Для ввода текстовых или числовых данных используется элемент `TextBox`.

Пример размещения трёх полей ввода:

```xaml
<StackPanel Margin="10">
    <TextBox Name="textBox1"/>
    <TextBox Name="textBox2"/>
    <TextBox Name="textBox3"/>
</StackPanel>
```

Получить введённый текст можно в C\# коде:

```cs
string s = textBox1.Text;
```

Задать шрифт можно в XAML:

```xaml
<TextBox FontSize="16" FontFamily="Arial"/>
```

== Размещение надписей (`TextBlock`)

В Avalonia вместо `Label` чаще используется `TextBlock` --- элемент, который отображает текстовые надписи.
Внимание: не путать `TextBlock` и `TextBox`, `TextBlock` используется для вывода текста, а `TextBox` --- для ввода.

Пример:

```xaml
<TextBlock Text="Введите значение X:" FontSize="16"/>
```

== События и обработчики

Каждый элемент интерфейса может вызывать события (например, `Click` у кнопки).
Чтобы обработать событие, в XAML указывается имя метода, а сам метод реализуется в файле .axaml.cs.

=== Обработка события нажатия кнопки (`Click`)

Пример:

```xaml
<Button Name="button1" Content="Выполнить" Click="OnButtonClick"/>
```

```cs
private void OnButtonClick(object? sender, RoutedEventArgs e)
{
  MessageBox.Avalonia.MessageBoxManager
    .GetMessageBoxStandardWindow("Сообщение", "Привет!")
    .Show();
}
```

=== Обработка события загрузки окна (`Opened`)

Событие, аналогичное `Load` в WinForms, --- это `Opened` в Avalonia.

```xaml
<Window xmlns="https://github.com/avaloniaui"
        Title="..."
        Opened="OnWindowOpened">
```

```cs
private void OnWindowOpened(object? sender, EventArgs e)
{
  this.Background = Brushes.AntiqueWhite;
}
```

== Запуск и работа программы

Программу можно запускать из любой IDE или терминала командой:

```sh
dotnet run
```

После успешной сборки появится окно приложения Avalonia.
Для завершения программы просто закройте окно.

== Динамическое изменение свойств

Свойства элементов можно менять в коде во время выполнения:

```cs
textBlock1.Text = "Привет!";
this.Background = Brushes.LightBlue;
```

== Индивидуальные задания

Ниже приведено 14 вариантов задач.
- Все элементы интерфейса (кнопки, поля ввода, текстовые надписи и т.п.) размещайте в окне MainWindow.axaml.
- Если в тексте задания явно не указано иное, то для разметки интерфейса можно использовать любой контейнер: `StackPanel`, `Grid` или `Canvas`.
- Для визуальных надписей используйте `TextBlock`, для ввода данных --- `TextBox`, для интерактивных действий --- `Button`.
- Изменение свойств (текста, цвета, видимости и т.д.) выполняйте в коде MainWindow.axaml.cs.
- События в Avalonia связываются через атрибуты XAML (например `Click="OnButtonClick"`) или через привязку в коде.

1. Разместите в окне четыре кнопки (`Button`). Сделайте на кнопках следующие надписи: Красный, Зелёный, Синий, Жёлтый. Создайте четыре обработчика события `Click`, которые будут менять цвет окна (`this.Background`) в соответствии с текстом на кнопке.
2. Разместите в окне две кнопки (`Button`) и одну надпись (`TextBlock`). Сделайте на кнопках надписи: "Привет", "До свидания". Создайте обработчики события Click для этих кнопок, которые будут изменять текст надписи (`TextBlock.Text`) с одного на другой. Создайте обработчик события загрузки окна (`Opened`), который установит цвет фона окна и изменит текст надписи на строку "Начало работы".
3. Разместите в окне две кнопки (`Button`) и одну надпись (`TextBlock`). Сделайте на кнопках надписи: "Скрыть", "Показать". Создайте обработчики событий `Click`, которые будут скрывать или показывать надпись (через свойство `IsVisible`). Создайте обработчик события загрузки окна (`Opened`), который установит цвет фона окна и изменит текст надписи на строку "Начало работы".
4. Разместите в окне три кнопки (`Button`) и одно поле ввода (`TextBox`). Сделайте на кнопках надписи: Скрыть, Показать, Очистить. Создайте обработчики событий `Click`, которые будут скрывать (`IsVisible = true`), показывать поле ввода (`IsVisible = false`) и очищать содержимое поля (`Text = ""`).
5. Разместите в окне две кнопки (`Button`) и одно поле ввода (`TextBox`). Сделайте на кнопках надписи: Заполнить, Очистить. Создайте обработчики событий `Click`, которые будут очищать поле (`Text = ""`) и заполнять его символами "`******`". Создайте обработчик события загрузки окна (`Opened`), который установит цвет фона окна и задаст текст поля "`+++++`".
6. Разработайте простую игру. На окне разместите пять кнопок (`Button`). При нажатии на любую кнопку некоторые кнопки должны становиться видимыми (`IsVisible = true`), а некоторые --- невидимыми (`IsVisible = false`). Цель игры --- скрыть все кнопки.
7. Разработайте игру, в которой на окне размещены четыре кнопки (`Button`) и четыре надписи (`TextBlock`). При нажатии на любую кнопку часть надписей становится невидимой, а часть --- видимой. Цель игры --- скрыть все надписи.
8. Разместите на окне несколько кнопок (`Button`). Создайте обработчики событий `Click`, которые будут делать нажатую кнопку неактивной (`IsEnabled = false`). Создайте обработчик события изменения размера окна (`Resized`), который будет устанавливать всем кнопкам состояние активное (`IsEnabled = true`).
9. Разместите на окне ряд кнопок (`Button`). Создайте обработчики событий `Click`, которые будут делать неактивной следующую кнопку. Создайте обработчик события нажатия кнопки мыши на окне (PointerPressed), который будет устанавливать всем кнопкам активное состояние (`IsEnabled = true`).
10. Разместите на окне три кнопки (`Button`) и одно поле ввода (`TextBox`). Сделайте на кнопках надписи: "`*****`", "`+++++`", "`00000`". Создайте обработчики событий `Click`, которые будут выводить текст с кнопки в поле ввода (`TextBox.Text = button.Content.ToString()`). Создайте обработчик события загрузки окна (`Opened`), который установит цвет фона окна и задаст текст "Готов к работе" в поле ввода.
11. Разместите на окне несколько полей ввода (`TextBox`). Создайте обработчики события нажатия кнопки мыши на данные поля ввода (`PointerPressed`), которые будут выводить в текущее поле его номер. Создайте обработчик события изменения размера окна (`Resized`), который будет очищать все поля ввода (`Text = ""`).
12. Разместите на окне одно поле ввода (`TextBox`), одну надпись (`TextBlock`) и одну кнопку (`Button`). Создайте обработчик события `Click` для кнопки, который будет копировать текст из поля ввода в надпись. Создайте обработчик события нажатия кнопки мышки на окне (`PointerPressed`), который будет устанавливать цвет фона, изменять текст надписи на "Начало работы" и очищать поле ввода.
13. Разместите на окне одно поле ввода (`TextBox`) и две кнопки (`Button`) с надписями Блокировать и Разблокировать. Создайте обработчики событий `Click`, которые будут делать поле ввода активным или неактивным (`IsEnabled`). Создайте обработчик события нажатия кнопки мышки на окне (`PointerPressed`), который будет изменять цвет фона и делать все элементы окна невидимыми (`IsVisible = false`).
14. Разместите на окне четыре кнопки (`Button`). Создайте для каждой обработчик события `Click`, который будет изменять размеры (`Width`, `Height`) и положение (`Canvas.Left`, `Canvas.Top`) других кнопок на окне. Для позиционирования используйте контейнер `Canvas`.

= Программирование линейных алгоритмов

*Цель второй части*

Научиться создавать структуру простейшей программы на языке C\#.
Освоить написание линейных алгоритмов.

== Структура приложения

В .NET существует два уровня организации:

- Project (Проект) --- основная единица, с которой работает программист. Содержит все исходные материалы для приложения, такие как файлы исходного кода, разметки интерфейса, ресурсы (иконки, изображения, стили), а также данные конфигурации, такие как параметры компилятора.

- Solution (Решение) --- контейнер, который объединяет один или несколько проектов. Один из проектов помечается как стартовый, и именно он запускается при выполнении команды `dotnet run` или при старте отладки.

Проект Avalonia включает следующие основные файлы:
- .csproj --- файл проекта. Содержит сведения о зависимостях, используемых библиотеках, версии .NET, настройках сборки. Создаётся автоматически и редактируется вручную только при необходимости (например, чтобы добавить пакет через NuGet).
- Program.cs --- точка входа приложения. Здесь выполняется запуск Avalonia-приложения.
- App.axaml / App.axaml.cs --- Файлы, содержащие глобальные настройки интерфейса: стили, темы, ресурсы.
- MainWindow.axaml --- XAML-файл, описывающий внешний вид главного окна. В нём размещаются элементы интерфейса (`TextBox`, `Button`, `TextBlock` и т.д.) и контейнеры (`Grid`, `StackPanel`, `Canvas` и т.д.).
- MainWindow.axaml.cs --- файл кода, содержащий обработчики событий и программную логику.
- Assets --- необязательная директория (по умолчанию отсутствует). В ней хранятся изображения, иконки и шрифты, используемые в графическом интерфейсе.

Пример содержимого файла MainWindow.axaml.cs:

```cs
// Раздел подключенных пространств имён
using System;
using Avalonia.Controls;

// Пространство имён нашего проекта
namespace MyFirstApp
{
  // Класс окна
  public partial class MainWindow : Window
  {
    // Методы окна
    public MainWindow()
    {
      InitializeComponent();
    }
  }
}
```

В разделе подключения пространств имён (каждая строка которого располагается в начале файла и начинается ключевым словом `using`) перечислены те подсистемы .NET, которые используются в программе.
Каждое пространство имён включает в себя классы, выполняющие определённую работу, например, классы для работы с сетью располагаются в пространстве `System.Net`, для работы с файлами --- в `System.IO`, а классы элементов интерфейса Avalonia находятся в пространстве имён `Avalonia.Controls`.

Для того чтобы не происходило конфликтов имён классов и переменных, классы нашего проекта также помещаются в отдельное пространство имён.
Определяется оно ключевым словом namespace, после которого следует имя пространства (обычно оно совпадает с именем проекта).

Внутри пространства имён помещаются наши классы --- в новом проекте это класс окна, который содержит все методы для управления поведением окна.
Обратите внимание, что в определении класса присутствует ключевое слово `partial`, это говорит о том, что в нашем программном файле .axaml.cs представлена только часть класса, где содержатся обработчики событий и логика управления элементами, а другая его часть определена в файле разметки .axaml, где описан внешний вид окна.

Наконец, внутри класса располагаются переменные, методы и другие элементы программы.
Фактически, основная часть программы размещается внутри класса при создании обработчиков событий.

== Описание данных

Типы данных имеют особенное значение в С\#, поскольку это строго типизированный язык.
Это означает, что все операции подвергаются строгому контролю со стороны компилятора на соответствие типов, причем код с недопустимыми операциями не компилируются.
Такая строгая проверка типов позволяет предотвратить ошибки и повысить надёжность программ.
Для обеспечения контроля типов все переменные, выражения и значения должны принадлежать к определенному типу.
Такого понятия, как "бестиповая" переменная, в данном языке программирования вообще не существует.
Более того, тип значения определяет те операции, которые разрешается выполнять над ним.
Операция, разрешенная для одного типа данных, может оказаться недопустимой для другого.

В С\# имеются две общие категории встроенных типов данных: типы значений и ссылочные типы.
Они отличаются по содержимому переменной.
Концептуально разница между ними состоит в том, что тип значения (value type) хранит данные непосредственно, в то время как ссылочный тип (reference type) хранит лишь ссылку на значение, хранящееся в оперативной памяти.

Эти типы сохраняются в разных местах памяти: типы значений сохраняются в области, известной как стек, а ссылочные типы --- в области, называемой управляемой кучей (heap).

#figure(
  image("lab1_imports/images/cs_var_types.png", width: 80%),
  caption: [Схема типов данных в С\#],
)

- Целочисленные типы
В C\# определены девять целочисленных типов: `char`, `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long` и `ulong`. Но тип `char` в основном применяется для представления символов и поэтому рассматривается отдельно. Остальные восемь целочисленных типов предназначены для числовых расчетов.

- Типы с плавающей точкой
Типы с плавающей точкой позволяют представлять числа с дробной частью. В C\# имеются две разновидности типов данных с плавающей точкой: `float` и `double`. Они представляют числовые значения с одинарной и двойной точностью соответственно.

- Десятичный тип данных
Для представления чисел с плавающей точкой высокой точности предусмотрен также десятичный тип `decimal`, который предназначен для применения в финансовых вычислениях.

- Символы
В C\# символы представлены не 8-разрядным кодом, как во многих других языках программирования, например С++, а 16-разрядным Unicode. В Unicode набор символов представлен настолько широко, что он охватывает символы практически из всех существующих естественных языков.

- Логический тип данных
Тип `bool` представляет два логических значения: "истина" и "ложь". Эти логические значения обозначаются в C\# зарезервированными словами `true` и `false` соответственно. Следовательно, переменная или выражение типа bool будет принимать одно из этих логических значений.

- Строки
Основным типом при работе со строками является тип `string`, задающий строки переменной длины. Тип `string` представляет последовательность из нуля или более символов в кодировке Unicode. Класс `String` в языке C\# относится к ссылочным типам. Над строками --- объектами этого класса --- определен широкий набор операций, соответствующий современному представлению о том, как должен быть устроен строковый тип. По сути, текст хранится в виде последовательной доступной только для чтения коллекции объектов `char`.

Рассмотрим самые популярные данные --- переменные и константы. Переменная --- это ячейка памяти, которой присвоено некоторое имя, и это имя используется для доступа к данным, расположенным в данной ячейке. Для каждой переменной задаётся тип данных --- диапазон всех возможных значений для данной переменной. Объявляются переменные непосредственно в коде программы.

Примеры объявления переменных:

```cs
int a;     // Только объявление
int b = 7; // Объявление и инициализация значением
```
Для того чтобы присвоить значение символьной переменной, достаточно заключить это значение (т.е. символ) в одинарные кавычки:

```cs
char ch;           // Только объявление
char symbol = 'A'; // Объявление и инициализация значением
```

Несмотря на то, что тип `char` определен в С\# как целочисленный, его не следует путать со всеми остальными целочисленными типами.
Частным случаем переменных являются константы. Константы - это переменные, значения которых не меняются в процессе выполнения программы. Константы описываются как обычная переменная, только с ключевым словом `const` вначале:

```cs
const int c = 5;
```

== Ввод/вывод данных в программу

Рассмотрим один из способов ввода данных через элементы, размещённые в окне приложения.
В приложениях Avalonia для ввода данных чаще всего используется элемент управления `TextBox`, обращение к которому осуществляется через его свойство `Text`. Свойство `Text` хранит строку символов, введённую пользователем. Поэтому данные можно получить следующим образом:

```cs
private void OnButtonClick(object? sender, RoutedEventArgs e)
{
  string s = textBox1.Text;
}
```

Однако со строкой символов трудно производить арифметические операции, поэтому лучше всего при вводе числовых данных перевести строку в целое или вещественное число. Для этого в C\# существуют методы `Parse`, определённые для различных типов данных. Например, для преобразования строки в целое число используется метод `int.Parse`, а для вещественного числа --- метод `double.Parse`.

Таким образом, предыдущий пример можно переписать следующим образом:

```cs
private void OnButtonClick(object? sender, RoutedEventArgs e)
{
  string s = textBox1.Text;
  int a = int.Parse(s);
  int b = a * a;
}
```

Перед выводом числовые данные следует преобразовать назад в строку. Для этого у каждой переменной существует метод `ToString`, который возвращает в результате строку с символьным представлением значения. Вывод данных можно осуществлять в элементы `TextBox` или `TextBlock`, также используя свойство `Text`. Например:

```cs
private void OnButtonClick(object? sender, RoutedEventArgs e)
{
  string s = textBox1.Text;
  int a = int.Parse(s);
  int b = a * a;
  textBlock1.Text = b.ToString();
}
```

Обработка исключений --- это описание реакции программы на определённые события (исключения) во время её выполнения. Реакцией программы может быть, например, корректное завершение работы программы, вывод информации об ошибке или запрос повторения действия (при вводе данных).
Примерами исключений может быть:
- деление на ноль;
- конвертация некорректных данных из одного типа в другой;
- попытка открыть файл, которого не существует;
- доступ к элементу вне рамок массива;
- исчерпывание памяти программы;
- и другое.

Для обработки исключений в C\# используется оператор `try`-`catch`. Он имеет следующую структуру:

```cs
try
{
  // Блок кода, в котором может возникнуть исключение
}
catch ([тип исключения] [имя])
{
  // Блок обработки исключения
}
```

Работа оператора происходит следующим образом: выполняется код в блоке `try`, и если в нём возникает исключение указанного в `catch` типа, управление передаётся в соответствующий блок `catch`. При этом весь оставшийся код от момента выбрасывания исключения до конца блока `try` не будет выполнен. После выполнения блока `catch`, оператор `try`-`catch` завершает работу.

Указывать имя исключения не обязательно. Исключение представляет собой объект, и к нему мы имеем доступ через это имя. С этого объекта мы можем получить, например, стандартное сообщение об ошибке (`Message`), или трассировку стека (`StackTrace`), которая поможет узнать место возникновения ошибки. В этом объекте хранится детальная информации об исключении.

Если тип выброшенного исключения не будет соответствовать типу, указанному в `catch` --- исключение не обработается, и программа завершит работу аварийно.

Ниже приведён пример программы, в которой используется обработка исключения некорректного формата данных:

```cs
private void button1_Click(object sender, EventArgs e)
{
  try
  {
    string s = textBox1.Text;
    int a = int.Parse(s);
    int b = a * a;
    textBox1.Text = b.ToString();
  }
  catch (Exception)
  {
    MessageBox.Show("Введите число");
  }
  finally
  {
    // Блок кода, который выполнится обязательно
  }
}
```

*Типы исключений*

Некоторые из часто встречаемых типов исключений:
- `Exception` --- базовый тип всех исключений. Блок catch, в котором указан тип `Exception` будет "ловить" все исключения;
- `FormatException` --- некорректный формат операнда или аргумента (при передаче в метод).
- `NullReferenceException` --- В экземпляре объекта не задана ссылка на объект, объект не создан;
- `IndexOutOfRangeException` --- индекс вне рамок коллекции;
- `FileNotFoundException` --- файл не найден;
- `DivideByZeroException` --- деление на ноль.

*Несколько блоков `catch`*

Одному блоку `try` может соответствовать несколько блоков `catch`:

```cs
try
{
  // Блок кода, в котором может возникнуть исключение
}
catch (FormatException)
{
  // Блок-обработка исключения 1
}
catch (FileNotFoundException)
{
  // Блок-обработка исключения 2
}
```

В зависимости от того или другого типа исключения в блоке `try`, выполнение будет передано соответствующему блоку `catch`.

*Блок `finally`*

Оператор `try`-`catch` также может содержать блок `finally`. Особенность блока `finally` в том, что код внутри этого блока выполнится в любом случае, в независимости от того, было ли исключение или нет.

```cs
try
{
  // Блок кода, в котором может возникнуть исключение
}
catch (Exception)
{
  // Обработка исключения
}
finally
{
  // Блок кода, который выполнится обязательно
}
```

Выполнение кода программы в блоке `finally` происходит в последнюю очередь. Сначала `try`, затем `finally` или `catch`-`finally` (если было исключение).
Обычно, он используется для освобождения ресурсов. Классическим примером использования блока `finally` является закрытие файла.

*Зачем нужен блок `finally`?*

Очень часто можно услышать вопрос, для чего нужен этот блок. Ведь, кажется, можно освободить ресурсы просто после оператора `try`-`catch`, без использования `finally`. А ответ очень прост. `finally` гарантирует выполнение кода, несмотря ни на что. Даже если в блоках `try` или `catch` будет происходить выход из метода с помощью оператора `return` --- `finally` выполнится.

== Арифметические действия и стандартные функции

При вычислении выражения, стоящего в правой части оператора присваивания, могут использоваться арифметические операции: "`*`" --- умножение, "`+`" --- сложение, "`-`" --- вычитание,  "`/`" --- деление, "`%`" --- взятие остатка от деления. Для задания приоритетов операций могут использоваться круглые скобки "`(` `)`". Также могут использоваться стандартные математические функции, представленные методами класса `Math`:
- `Math.Sin(a)` --- синус (аргумент задаётся в радианах);
- `Math.Cos(a)` --- косинус (аргумент задаётся в радианах);
- `Math.Atan(a)` --- арктангенс (аргумент задаётся в радианах);
- `Math.Log(a)` --- натуральный логарифм;
- `Math.Exp(a)` --- экспонента;
- `Math.Pow(x,y)` --- возведение переменной `x` в степень `y`;
- `Math.Sqrt(a)` --- квадратный корень;
- `Math.Abs(a)` --- модуль числа;
- `Math.Truncate(a)` --- целая часть числа;
- `Math.Round(a)` --- округление числа;

== Пример написания программы

*Задание:* составить программу вычисления для заданных значений `x`, `y`, `z` арифметического выражения

$
  u = tg^2 (x + y) - e^(y - z) sqrt(cos x^2 + sin z^2).
$

Панель диалога программы организовать в виде, представленном на изображении:

#figure(
  image("lab1_imports/images/img2_1.png", width: 60%),
  caption: [Внешний вид программы.],
)

Для вывода результатов используется элемент управления `TextBox`, который в Avalonia может работать как многострочный редактор.
Чтобы обеспечить возможность ввода и вывода нескольких строк, необходимо установить свойство `AcceptsReturn="True"`. Это позволяет переносить текст на новую строку и растягивать элемент как по горизонтали, так и по вертикали.
Для отображения полосы прокрутки используется attached-свойство:

```xaml
ScrollViewer.VerticalScrollBarVisibility="Visible"
```

После установки этих свойств окно будет позволять просматривать большие объёмы текста.

В многострочном текстовом поле Avalonia также существует свойство `Text`, которое содержит весь текст, отображаемый в элементе.
Добавление новой строки выполняется так же, как и в стандартных приложениях C\# --- с помощью конструкции:

```cs
textBox4.Text += Environment.NewLine + "Привет";
```

В этом примере к текущему содержимому окна добавляется символ переноса строки (который может отличаться в разных операционных системах, поэтому используется свойство класса `Environment.NewLine`) и сама новая строка.
Если добавляется числовое значение, то его предварительно нужно привести к строковому виду методом `ToString()`.

Работа с программой происходит следующим образом. Нажмите (щёлкните мышью) кнопку "Выполнить". В окне `textBox4` появляется результат. Измените исходные значения `x`, `y`, `z` в окнах `textBox1` --- `textBox3` и снова нажмите кнопку "Выполнить" --- появится новые результаты.

*Полный код программы имеет следующий вид:*

MainWindow.axaml:

```xaml
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        x:Class="test.MainWindow"
        Title="Лабораторная работа №1"
        Width="420" Height="420">

    <StackPanel Margin="10" Spacing="6">

        <TextBlock Text="Введите значение X:"/>
        <TextBox Name="textBox1" Width="200"/>

        <TextBlock Text="Введите значение Y:"/>
        <TextBox Name="textBox2" Width="200"/>

        <TextBlock Text="Введите значение Z:"/>
        <TextBox Name="textBox3" Width="200"/>

        <TextBlock Text="Результат выполнения программы:"/>

        <TextBox Name="textBox4"
                 AcceptsReturn="True"
                 ScrollViewer.VerticalScrollBarVisibility="Visible"
                 Height="160"
                 Width="360"
                 IsReadOnly="True"/>

        <Button Name="button1"
                Content="Выполнить"
                HorizontalAlignment="Right"
                Width="100"
                Click="OnButtonClick"/>

    </StackPanel>

</Window>
```

MainWindow.axaml.cs:

```cs
using Avalonia.Controls;
using Avalonia.Interactivity;
using System;

namespace MyFirstApp;

public partial class MainWindow : Window
{
  public MainWindow()
  {
    InitializeComponent();

    textBox1.Text = "3.4";   // Начальное значение X
    textBox2.Text = "0.74";  // Начальное значение Y
    textBox3.Text = "19.43"; // Начальное значение Z

    // Вывод строки в многострочный редактор
    textBox4.Text = "Лаб. раб. №1. Иванов А.А. 251 гр.";
  }

  private void OnButtonClick(object? sender, RoutedEventArgs e)
  {
    try
    {
      // Считывание значения X
      double x = double.Parse(textBox1.Text!);

      // Вывод значения X
      textBox4.Text += Environment.NewLine +
                       "X = " + x.ToString();

      // Считывание значение Y
      double y = double.Parse(textBox2.Text!);

      // Вывод значения Y
      textBox4.Text += Environment.NewLine +
                       "Y = " + y.ToString();

      // Считывание значения Z
      double z = double.Parse(textBox3.Text!);

      // Вывод значения Z
      textBox4.Text += Environment.NewLine +
                       "Z = " + z.ToString();

      // Вычисление арифметическое выражение
      double a = Math.Tan(x + y) * Math.Tan(x + y);
      double b = Math.Exp(y - z);
      double c = Math.Sqrt(Math.Cos(x * x) + Math.Sin(z * z));
      double u = a - b * c;

      // Вывод результата
      textBox4.Text += Environment.NewLine +
                       "Результат U = " + u.ToString();
    }
    catch (FormatException)
    {
      textBox4.Text += Environment.NewLine +
                       "Ошибка: введите корректные числовые значения.";
    }
    catch (Exception ex)
    {
      textBox4.Text += Environment.NewLine +
                       "Неизвестная ошибка: " + ex.Message;
    }
  }
}
```

*Представление чисел в экспоненциальной форме:*

$1 "e" 2 --> 1 times 10^2$

$1 "e" - 2 --> 1 times 10^(-2)$

```cs
string s = textBox1.Text;
double a = double.Parse(s);
double b = a * a + 1e2 + 1e-2;
textBox1.Text = b.ToString();
```

== Индивидуальные задания

Ниже приведено 15 вариантов задач. Номер задания соответствует номеру студента в списке группы, если не хватает --- начинать отсчёт с начала.
Уточните условие задания, количество, наименование, типы исходных данных.
В соответствии с этим необходимо:
- установить нужное количество элементов `TextBox` для ввода переменных;
- задать текстовые заголовки `TextBlock` для каждого поля ввода;
- определить необходимые размеры шрифтов, отступы, расположение элементов;
- выбрать типы переменных в программе и функции преобразования при вводе (`double.Parse`, `int.Parse` и др.);
- установить исходные данные (значения по умолчанию), которые будут автоматически появляться в окнах `TextBox` при запуске приложения;
- обязательно использовать обработку исключений (`try`-`catch`) для проверки корректности вводимых значений.

С помощью редактора XAML измените цвет окна (`Background`), размеры шрифтов и другие визуальные свойства интерфейса.

1.
$ t = (2 cos(x - pi/6))/(0.5 + sin^2 y) times (1 + (z^2)/(3 - z^2/5)). $
При $x = 14.26$, $y = -1.22$, $z = 3.5 times 10^(-2)$ $t = 0.564849$.

2.
$
  u = (root(3, 8 + abs(x - y)^2 + 1))/(x^2 + y^2 + 2) - e^(abs(x - y)) ("tg"^2 z + 1)^x.
$
При $x = -4.5$, $y = 7.5 times 10^(-5)$, $z = 84.5$ $u = -55.6848$.

3.
$
  v = (1 + sin^2 (x + y))/(abs(x - (2 y)/(1 + x^2 y^2))) x^(abs(y)) + cos^2 ("arctg" 1/z).
$
При $x = 3.74 times 10^(-2)$, $y = -0.825$, $z = 16$ $v = 1.0553$.

4.
$
  w = abs(cos x - cos y)^((1 + 2 sin^2 y)) times (1 + z + z^2/2 + z^3/3 + z^4/4).
$
При $x = 4 times 10^3$, $y = -0.875$, $z = -4.75 times 10^(-4)$ $w = 1.9873$.

5.
$ alpha = ln(y^(-sqrt(abs(x)))) times (x - y/2) + sin^2 ("arctg" z). $
При $x = -15.246$, $y = 4.642 times 10^(-2)$, $z = 2.0001 times 10^3$ $alpha = -182.036$.

6.
$ beta = sqrt(10 (root(3, x) + x^(y + 2))) (arcsin^2 z - abs(x - y)). $
При $x = 1.655 times 10^(-2)$, $y = -2.75$, $z = 0.15$ $beta = -38.902$.

7.
$
  gamma = 5 "arctg" x - 1/4 arccos x times (x + 3 abs(x - y) + x^2)/(z abs(x - y) + x^2).
$
При $x = 0.1722$, $y = 6.33$, $z = 3.25 times 10^(-4)$ $gamma = -172.025$.

8.
$
  phi = (e^(abs(x - y)) times abs(x - y)^(x + y))/("arctg" x + "arctg" z) + root(3, x^6 + ln^2 y).
$
При $x = -2.235 times 10^(-2)$, $y = 2.23$, $z = 15.221$ $phi = 39.374$.

9.
$
  psi = abs(x^(y/x) - root(3, y/x)) + (y - x) (cos y - (z)/(y - x))/(1 + (y - x)^2).
$
При $x = 1.825 times 10^2$, $y = 18.225$, $z = -3.298 times 10^(-2)$ $psi = 1.2131$.

10.
$
  a = 2^(-x) times sqrt(x + root(4, abs(y))) times root(3, e^(x - (1)/(sin z))).
$
При $x = 3.981 times 10^(-2)$, $y = -1.625 times 10^3$, $z = 0.512$ $a = 1.26185$.

11.
$
  b = y^(root(3, abs(x))) + cos^3 y (abs(x - y) (1 + (sin^2 z)/(sqrt(x + y))))/(e^(abs(x - y)) + x/2).
$
При $x = 6.251$, $y = 0.827$, $z = 25.001$ $b = 0.7121$.

12.
$ c = 2^(y^x) + 3^(x^y) - (y ("arctg" z - pi/6))/(abs(x) + (1)/(y^2 + 1)). $
При $x = 3.251$, $y = 0.325$, $z = 4.66 times 10^(-5)$ $c = 4.025$.

13.
$ f = (root(4, y + root(3, x - 1)))/(abs(x - y) (sin^2 z + tg z)). $
При $x = 17.421$, $y = 1.0365 times 10^(-2)$, $z = 8.28 times 10^4$ $f = 0.33056$.

14.
$
  g = (y^(x + 1))/(root(3, abs(y - 2)) + 3) + (x + y/2)/(2 abs(x + y)) (x + 1)^((-1)/(sin z)).
$
При $x = 1.23$, $y = 15.4$, $z = 2.52 times 10^2$ $g = 82.8257$.

15.
$
  h = (x^y + y^z + z^x)/(3 + y/z sin^2 x) times ("arctg" z - (1)/root(3, abs(x + y)))^x
$
При $x = 8.21 times 10^(-2)$, $y = -1.71$, $z = 1.5$ $h = 20.6376$.

= Программирование разветвляющихся алгоритмов

*Цель третьей части*

Научиться пользоваться простейшими компонентами организации переключений (`RadioButton`). Написать программу разветвляющегося алгоритма.

== Логические переменные и операции над ними

Переменные логического типа описываются посредством служебного слова `bool`. Они могут принимать только два значения --- `True` (истина) и `False` (ложь). Результат `True` и `False` возникает при использовании операций сравнения `<` меньше, `>` больше, `!=` не равно, `<=` меньше или равно, `>=` больше или равно, `==` равно. Объявляются логические переменные следующим образом:

```cs
bool b;
```

В языке C\# имеются логические операции, применяемые к переменным логического типа. Это операции логического отрицания (`!`), логическое И (`&&`) и логическое ИЛИ (`||`). Операция логического отрицания является унарной операцией. Результат операции `!` есть `False`, если операнд истинен, и `True`, если операнд имеет значение ложь.\
`! True` $->$ `False`\
`! False` $->$ `True`\
Результат операции логическое И (`&&`) есть истина, только если оба её операнда истинны, и ложь во всех других случаях. Результат операции логическое ИЛИ (`||`) есть истина, если какой-либо из её операндов истинен, и ложен только тогда, когда оба операнда ложны.

== Условные операторы

Операторы ветвления позволяют изменить порядок выполнения операторов в программе. К операторам ветвления относятся условный оператор `if` и оператор выбора `switch`.
Условный оператор `if` используется для разветвления процесса обработки данных на два направления. Он может иметь одну из форм: сокращенную или полную.
Форма сокращенного оператора `if`:

```cs
if (B)
{
  S;
}
```

где `В` --- логическое или арифметическое выражение, истинность которого проверяется; `S` --- оператор: простой или составной.

Также такую конструкцию можно записать в одну строку:

```cs
if (B) S;
```

При выполнении сокращенной формы оператора `if` сначала вычисляется выражение `B`, затем проводится анализ его результата: если `B` истинно, то выполняется оператор `S`; если `B` ложно, то оператор `S` пропускается. Таким образом, с помощью сокращенной формы оператора `if` можно либо выполнить оператор `S`, либо пропустить его.

Форма полного оператора `if`:

```cs
if (B)
{
  S1;
}
else
{
  S2;
}
```

или так же в одну строку:

```cs
if (B) S1; else S2;
```

где `B` --- логическое или арифметическое выражение, истинность которого проверяется; `S1`, `S2` --- оператор: простой или составной.
При выполнении полной формы оператора `if` сначала вычисляется выражение `B`, затем анализируется его результат: если `B` истинно, то выполняется оператор `S1`, а оператор `S2` пропускается; если `B` ложно, то выполняется оператор `S2`, а `S1` пропускается. Таким образом, с помощью полной формы оператора `if` можно выбрать одно из двух альтернативных действий процесса обработки данных.

Пример. Вычислим значение функции

$
  y(x) = cases(
    sin(x)\, x <= a\,,
    cos(x)\, a < x < b\,,
    tg(x)\, x >= b.
  )
$

Указанное выражение может быть запрограммировано в следующем виде:

```cs
if (x <= a)
{
  y = Math.Sin(x);
}
if ((x > a) && (x < b))
{
  y = Math.Cos(x);
}
if (x >= b)
{
  y = Math.Sin(x)/Math.Cos(x);
}
```

или

```cs
if (x <= a)
{
  y = Math.Sin(x);
}
else if (x < b)
{
  y = Math.Cos(x);
}
else
{
  y = Math.Sin(x)/Math.Cos(x);
}
```

Оператор выбора `switch` предназначен для разветвления процесса вычислений по нескольким направлениям. Формат оператора:

```cs
switch (<выражение>)
{
  case <константное_выражение_1>:
    [<оператор 1>]; <оператор перехода>;
  case <константное_выражение_2>:
    [<оператор 2>]; <оператор перехода>;
  ...
  case <константное_выражение_n>:
    [<оператор n>]; <оператор перехода>;
  [default: <оператор>;]
}
```

Замечание. Выражение, записанное в квадратных скобках, является необязательным элементом в операторе `switch`. Если оно отсутствует, то может отсутствовать и оператор перехода.

Выражение, стоящее за ключевым словом `switch`, должно иметь арифметический, символьный, строковый тип или тип указатель. Все константные выражения должны иметь разные значения, но их тип должен совпадать с типом выражения, стоящим после `switch` или приводиться к нему. Ключевое слово case и расположенное после него константное выражение называют также меткой `case`.

Выполнение оператора начинается с вычисления выражения, расположенного за ключевым словом `switch`. Полученный результат сравнивается с меткой `case`. Если результат выражения соответствует метке case, то выполняется оператор, стоящий после этой метки, за которым обязательно должен следовать оператор `break`. При использовании оператора `break` происходит выход из `switch` и управление передается оператору, следующему за `switch`.

Если ни одно выражение `case` не совпадает со значением оператора `switch`, управление передается операторам, следующим за необязательной подписью `default`. Если подписи `default` нет, то управление передается за пределы оператора `switch`.
Пример использования оператора `switch`:

```cs
int caseSwitch = 1;
switch (caseSwitch)
{
  case 1:
    Console.WriteLine("Case 1");
    break;
  case 2:
    Console.WriteLine("Case 2");
    break;
  default:
    Console.WriteLine("Default case");
    break;
}
```

== Кнопки-переключатели (`RadioButton`)

При создании программ с графическим интерфейсом в Avalonia для организации разветвлений часто используются компоненты в виде кнопок-переключателей (`RadioButton`).
Состояние такой кнопки (включено/выключено) визуально отображается в интерфейсе: если пользователь выбирает один из вариантов переключателя в группе, все остальные автоматически отключаются.

В Avalonia все `RadioButton`, находящиеся в одном контейнере, образуют группу. Чтобы создать в одном окне несколько независимых групп переключателей, каждую группу размещают в своём отдельном контейнере: `StackPanel`, `Grid`, `Border` и т. д.

В окне (Рис.@img3) элементы `RadioButton` сгруппированы внутри контейнера `Grid`.
Каждый переключатель имеет свойство `IsChecked`, определяющее его текущее состояние.

Номер выбранного варианта (0, 1, 2, ...) передаётся в программу и анализируется при помощи оператора `switch`.

== Пример написания программы

*Задание:* ввести три числа `x`, `y`, `z`. Вычислить величину

$
  U = cases(
    y * f(x)^2 + z\, z - x = 0\,,
    y * e^(f(x)) - z\, z - x < 0\,,
    y * sin(f(x)) + z\, z - x > 0.
  )
$

В качестве функции $f(x)$ используется один из вариантов по выбору пользователя:
$sin(x)$, $cos(x)$, $e^x$.

=== Создание окна

Создайте окно в соответствии с Рис.@img3.

#figure(
  image("lab1_imports/images/img3_1.png", width: 80%),
  caption: [Окно лабораторной работы],
)<img3>

Для первой радиокнопки установите:

```xaml
IsChecked="True"
```

Также разместите на форме элементы `Label`, `TextBox` и `Button`.
Поле для вывода результатов --- это многострочный `TextBox` с установленным свойством:

```xaml
AcceptsReturn="True"
```

и включённой вертикальной прокруткой:

```xaml
ScrollViewer.VerticalScrollBarVisibility="Visible"
```

Итоговый код файла MainWindow.axaml будет выглядеть следующим образом:

```xaml
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        x:Class="Lab1_3.MainWindow"
        Title="Лабораторная работа № 1.3"
        Width="500" Height="420"
        CanResize="False">

    <Grid Margin="12">
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="Auto"/>
            <ColumnDefinition Width="*"/>
            <ColumnDefinition Width="160"/>
        </Grid.ColumnDefinitions>

        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <!-- Ввод X -->
        <TextBlock Grid.Row="0" Grid.Column="0"
                   VerticalAlignment="Center" Margin="0 4"
                   Text="X =" />
        <TextBox Grid.Row="0" Grid.Column="1"
                 Name="textBox1" Width="120" Margin="4 4"/>

        <!-- Ввод Y -->
        <TextBlock Grid.Row="1" Grid.Column="0"
                   VerticalAlignment="Center" Margin="0 4"
                   Text="Y =" />
        <TextBox Grid.Row="1" Grid.Column="1"
                 Name="textBox2" Width="120" Margin="4 4"/>

        <!-- Ввод Z -->
        <TextBlock Grid.Row="2" Grid.Column="0"
                   VerticalAlignment="Center" Margin="0 4"
                   Text="Z =" />
        <TextBox Grid.Row="2" Grid.Column="1"
                 Name="textBox3" Width="120" Margin="4 4"/>


        <!-- Контейнер с переключателями -->
        <Border Grid.Row="0" Grid.Column="2"
                Grid.RowSpan="3"
                BorderBrush="Gray" BorderThickness="1"
                CornerRadius="6"
                Margin="10 0 0 0" Padding="8">

            <StackPanel>
                <TextBlock Text="F(x)"
                           FontWeight="Bold"
                           Margin="2 0 0 6"/>

                <RadioButton Name="rbSin" Content="sin(x)" IsChecked="True"/>
                <RadioButton Name="rbCos" Content="cos(x)"/>
                <RadioButton Name="rbExp" Content="exp(x)"/>
            </StackPanel>

        </Border>


        <!-- Поле вывода -->
        <TextBox Grid.Row="3" Grid.ColumnSpan="3"
                 Name="textBox4"
                 AcceptsReturn="True"
                 IsReadOnly="True"
                 Margin="0 10 0 10"
                 Height="160"
                 ScrollViewer.VerticalScrollBarVisibility="Visible"/>


        <!-- Кнопки -->
        <StackPanel Grid.Row="5" Grid.ColumnSpan="3"
                    Orientation="Horizontal"
                    HorizontalAlignment="Center"
                    Spacing="20" Margin="0 5 0 0">

            <Button Name="btnRun"
                    Content="ПУСК"
                    Width="120" Height="36"
                    Click="OnRunClick"/>

            <Button Name="btnClear"
                    Content="Очистить"
                    Width="120" Height="36"
                    Click="OnClearClick"/>
        </StackPanel>

    </Grid>
</Window>
```

=== Создание обработчиков событий

Обработчики событий создаются аналогично предыдущим примерам.
Ниже приведён код файла MainWindow.axaml.cs:

```cs
using Avalonia.Controls;
using Avalonia.Interactivity;
using System;

namespace test;

public partial class MainWindow : Window
{
  public MainWindow()
  {
    InitializeComponent();
  }

  // Обработка кнопки "ПУСК"
  private void OnRunClick(object? sender, RoutedEventArgs e)
  {
    textBox4.Text = ""; // Очистка перед выводом нового результата

    try
    {
      // Получение исходных данных
      double x = double.Parse(textBox1.Text!);
      double y = double.Parse(textBox2.Text!);
      double z = double.Parse(textBox3.Text!);

      // Вывод исходных данных
      textBox4.Text =
        "Результаты работы программы Петрова И.И." + Environment.NewLine +
        "При X = " + x + Environment.NewLine +
        "При Y = " + y + Environment.NewLine +
        "При Z = " + z + Environment.NewLine;

      // Определение выбранной функции f(x)
      int n = 0;
      if (rbCos.IsChecked == true)
      {
        n = 1;
      }
      else if (rbExp.IsChecked == true)
      {
        n = 2;
      }

      // Выбор функции f(x)
      double fx;

      switch (n)
      {
        case 0:
          fx = Math.Sin(x);
          break;

        case 1:
          fx = Math.Cos(x);
          break;

        case 2:
          fx = Math.Exp(x);
          break;

        default:
          fx = 0;
          break;
      }

      // Вычисление U
      double u;
      double diff = z - x;

      if (diff == 0)
      {
        u = y * fx * fx + z;
      }
      else if (diff < 0)
      {
        u = y * Math.Exp(fx) - z;
      }
      else
      {
        u = y * Math.Sin(fx) + z;
      }

      // Вывод результата
      textBox4.Text += "U = " + u.ToString() + Environment.NewLine;
    }
    catch (FormatException)
    {
      textBox4.Text += Environment.NewLine +
        "Ошибка: введены некорректные данные.";
    }
    catch (Exception ex)
    {
      textBox4.Text += Environment.NewLine +
        "Неизвестная ошибка: " + ex.Message;
    }
  }

  // Обработка кнопки "Очистить"
  private void OnClearClick(object? sender, RoutedEventArgs e)
  {
    textBox1.Text = "";
    textBox2.Text = "";
    textBox3.Text = "";
    textBox4.Text = "";
  }
}
```

Запустите программу и убедитесь в том, что все ветви алгоритма выполняются правильно.

== Индивидуальные задания

По указанию преподавателя выберите индивидуальное задание из нижеприведённого списка. В качестве $f(x)$ использовать по выбору: $"sh"(x)$, $2 x$, $e x$. Отредактируйте вид формы и текст программы в соответствии с полученным заданием.

1.
$
  a = cases(
    (f(x) + y)^2 - sqrt(f(x) times y)\, "   " x y > 0\;,
    (f(x) + y)^2 + sqrt(abs(f(x) times y))\, "   " x y < 0\;,
    (f(x) + y)^2 + 1\, "   " x y = 0\;,
  )
$

2.
$
  b = cases(
    ln(f(x)) + (f(x)^2 + y)^3\, "   " x/y > 0\;,
    ln(abs(f(x) / y)) + (f(x) + y)^3\, "   " x/y < 0\;,
    (f(x)^2 + y)^3\, "   " x = 0\;,
    0\, "   " y = 0\;,
  )
$

3.
$
  c = cases(
    f(x)^2 + y^2 + sin(y)\, "   " x - y = 0\;,
    (f(x) - y)^2 + cos(y)\, "   " x - y > 0\;,
    (y - f(x))^2 + tg(y)\, "   " x - y < 0\;,
  )
$

4.
$
  d = cases(
    (f(x) - y)^3 + "arctg"(f(x))\, "   " x > y\;,
    (y - f(x))^3 + "arctg"(f(x))\, "   " y > x\;,
    (y + f(x))^3 + 0.5\, "   " y = x\;,
  )
$

5.
$
  e = cases(
    i times sqrt(f(x))\, "   " i - "нечётное"\, x > 0\;,
    i / 2 times sqrt(abs(f(x)))\, "   " i - "чётное"\, x < 0\;,
    sqrt(abs(i times f(x)))\, "   " "иначе"\;,
  )
$

6.
$
  g = cases(
    e^(f(x) - abs(b))\, "   " 0.5 < x b < 10\;,
    sqrt(abs(f(x) + b))\, "   " 0.1 < x b < 0.5\;,
    2 f(x)^2\, "   " "иначе"\;,
  )
$

7.
$
  s = cases(
    e^(f(x))\, "   " 1 < x b < 10\;,
    sqrt(abs(f(x) + 4 b))\, "   " 12 < x b < 40\;,
    b times f(x)^2\, "   " "иначе"\;,
  )
$

8.
$
  j = cases(
    sin(5 f(x) + 3 m times abs(f(x)))\, "   " -1 < m x\;,
    cos(3 f(x) + 5 m times abs(f(x)))\, "   " x > m\;,
    (f(x) + m)^2\, "   " x = m\;,
  )
$

9.
$
  l = cases(
    2 f(x)^3 + 3 p^2\, "   " x > abs(p)\;,
    abs(f(x) - p)\, "   " 3 < x < abs(p)\;,
    (f(x) - p)^2\, "   " x = abs(p)\;,
  )
$

10.
$
  k = cases(
    ln(abs(f(x)) + abs(q))\, "   " abs(x q) > 10\;,
    e^(f(x) + q)\, "   " abs(x q) < 10\;,
    f(x) + q\, "   " abs(x q) = 10\;,
  )
$

11.
$
  m = frac(
    max(f(x)\, y\, z),
    min(f(x)\, y)
  ) + 5
$

12.
$
  n = frac(
    min(f(x) + y\, y - z),
    max(f(x)\, y)
  )
$

13.
$
  p = frac(
    abs(min(f(x)\, y) - max(y\, z)),
    2
  )
$

14.
$
  q = frac(
    max(f(x) + y + z\, x y z),
    min(f(x) + y + z\, x y z)
  )
$

15.
$ r = max(min(f(x)\, y)\, z) $

= Программирование циклических алгоритмов

*Цель четвертой части*

Освоить написание циклических алгоритмов.
Изучить простейшие средства отладки программ на языке C\#.
Составить и отладить программу циклического алгоритма.

== Операторы организации циклов

Под циклом понимается многократное выполнение одних и тех же операторов при различных значениях промежуточных данных.
Число повторений может быть задано в явной или неявной форме.

К операторам цикла относятся: цикл с предусловием `while`, цикл с постусловием `do while`, цикл с параметром `for` и цикл перебора `foreach`.
Рассмотрим некторые из них.

== Цикл с предусловием `while`

Оператор цикла `while` организует выполнение одного оператора (простого или составного) неизвестное заранее число раз.
Формат цикла `while`:

```cs
while (B)
{
  S;
}
```

где `B` --- выражение, истинность которого проверяется (условие завершения цикла);
`S` --- тело цикла --- оператор (простой или составной).

Перед каждым выполнением тела цикла анализируется значение выражения `B`: если оно истинно, то выполняется тело цикла, и управление передаётся на повторную проверку условия `B`; если значение `B` ложно --- цикл завершается и управление передаётся на оператор, следующий за оператором `S`.

Если результат выражения `B` окажется ложным при первой проверке, то тело цикла не выполнится ни разу.
Отметим, что если условие `B` во время работы цикла не будет изменяться, это может привести к возникновению бесконечного цикла, то есть невозможности выхода из него.
Поэтому внутри тела должны находиться операторы, приводящие к изменению значения выражения `B` так, чтобы цикл мог корректно завершиться.

В качестве иллюстрации выполнения цикла `while` рассмотрим программу вывода в консоль целых чисел из интервала от 1 до n.

```cs
static void Main()
{
  Console.Write("N = ");
  int n = int.Parse(Console.ReadLine());
  int i = 1;
  while (i <= n) // Пока i меньше или равно n
  {
    // Выводим i на экран, затем увеличиваем его на 1
    Console.Write(i++ + " ");
  }
}
```

Результаты работы программы:

```
N = 10
1 2 3 4 5 6 7 8 9 10
```

== Цикл с постусловием `do while`

Оператор цикла `do while` также организует выполнение одного оператора (простого или составного) неизвестное заранее число раз.
Однако в отличие от цикла `while` условие завершения цикла проверяется после выполнения тела цикла.
Формат цикла `do while`:

```cs
do
{
  S;
} while (B);
```

где `B` --- выражение, истинность которого проверяется (условие завершения цикла); `S` --- тело цикла --- оператор (простой или блок).
Сначала выполняется оператор `S`, а затем анализируется значение выражения `B`: если оно истинно, то управление передается оператору `S`, если ложно --- цикл завершается, и управление передается на оператор, следующий за условием `B`.
Так как условие В проверяется после выполнения тела цикла, то в любом случае тело цикла выполнится хотя бы один раз.
В операторе `do while`, так же как и в операторе `while`, возможно возникновение бесконечного цикла в случае, если условие В всегда будет оставаться истинным.

== Цикл с параметром `for`

Цикл с параметром имеет следующую структуру:

```cs
for (<инициализация>; <выражение>; <модификация>)
{
  <оператор>;
}
```

Инициализация используется для объявления и/или присвоения начальных значений величинам, используемым в цикле в качестве параметров (счётчиков).
В этой части можно записать несколько операторов, разделённых запятой.
Областью видимости переменных, объявленных в части инициализации цикла, является цикл и вложенные в него блоки.
Инициализация выполняется только один раз в начале исполнения цикла.

Выражение определяет условие выполнения цикла: если его результат истинен --- цикл выполняется.
Истинность выражения проверяется перед каждым выполнением тела цикла, таким образом, цикл с параметром реализован как цикл с предусловием.
В блоке выражения через запятую можно записать несколько логических выражений, тогда запятая равносильна операции логическое И (`&&`).

Модификация выполняется после каждой итерации цикла и служит обычно для изменения параметров цикла.
В части модификации можно также записать несколько операторов через запятую.

Оператор (простой или составной) представляет собой тело цикла.

Любая из частей оператора `for` (инициализация, выражение, модификация, оператор) может отсутствовать, но точку с запятой, определяющую позицию пропускаемой части, необходимо оставить.

Пример формирования строки, состоящей из чисел от 0 до 9, разделённых пробелами:

```cs
for (var i = 0; i <= 9; i++)
{
  s += i + " ";
}
```

Данный пример работает следующим образом:
сначала вычисляется начальное значение переменной `i`;
затем, пока значение `i` меньше или равно 9, выполняется тело цикла, и затем повторно вычисляется значение `i`;
когда значение `i` становится больше 9, условие становится ложным и управление передаётся за пределы цикла.

== Отладка программ на C\#

Практически в каждой вновь написанной программе после её запуска обнаруживаются ошибки.
Процесс поиска и исправления ошибок в программе называется отладкой.

=== Ошибки компиляции

Ошибки первого уровня --- ошибки компиляции (compile time errors) --- связаны с неправильной записью операторов программы (орфографические, синтаксические ошибки, неверное использование типов данных и т.п.).

При обнаружении ошибок компилятор формирует список сообщений, который отображается после завершения процесса компиляции.
Каждое сообщение об ошибке, как правило, содержит:
- имя файла, в котором обнаружена ошибка;
- номер строки;
- краткое описание характера ошибки.

#figure(
  image("lab1_imports/images/img4_1.png", width: 60%),
  caption: [Список ошибок компиляции в VS Code],
)

Следует учитывать, что одна ошибка может повлечь за собой появление нескольких сообщений.
После исправления первой (верхней) ошибки остальные могут исчезнуть.
Поэтому рекомендуется исправлять ошибки последовательно, сверху вниз, периодически выполняя повторную компиляцию после внесённых исправлений.

Программа может быть запущена только в том случае, если она была скомпилирована без ошибок.

=== Ошибки выполнения

Ошибки второго уровня --- ошибки выполнения (runtime errors) --- связаны с неверным алгоритмом решения задачи или с неправильной программной реализацией алгоритма.
Например, к таким ошибкам относятся: деление на ноль, переполнение, обращение к неинициализированным данным, получение неверного результата вычислений и т.п.

Далеко не все такие ошибки могут быть выявлены сразу.
Для их обнаружения может потребоваться тестирование программы.
Тестирование заключается в выполнении вычислений для таких наборов исходных данных, для которых заранее известен правильный результат.
Если результат отличается от ожидаемого, необходимо использовать средства отладки.

=== Точки останова и пошаговое выполнение программы

Для локализации места возникновения ошибки в программе используются точки останова (breakpoints).

Точка останова --- это специальная отметка, устанавливаемая на строке исходного кода, при достижении которой выполнение программы временно приостанавливается.
Это позволяет пошагово отслеживать выполнение операторов и изменение значений переменных.

Обычно в редакторах кода и IDE точку останова можно установить, щёлкнув правой кнопкой мыши в области слева от номера нужной строки кода (как, например, в VS Code) либо же используя специальную команду, специфичную для этого редактора.

#figure(
  image("lab1_imports/images/img4_2.png", width: 60%),
  caption: [Код с установленной точкой останова в VS Code],
)

После запуска программы в режиме отладки и достижения точки останова выполнение программы приостанавливается.
В этот момент становятся доступны следующие действия отладчика:
- пошаговое выполнение без захода в подпрограммы;
- пошаговое выполнение с заходом в подпрограммы;
- продолжение выполнения программы до следующей точки останова;
- остановка выполнения программы.

#figure(
  image("lab1_imports/images/img4_3.png", width: 60%),
  caption: [Интерфейс отладки в VS Code],
)

Строка кода, которая будет выполнена следующей, обычно подсвечивается.
Значения переменных во время выполнения программы можно просматривать в специальных окнах отладчика, либо наводя курсор мыши на имя переменной в коде.

Для поиска алгоритмических ошибок рекомендуется контролировать промежуточные значения переменных на каждом шаге выполнения подозрительного участка программы и внимательно смотреть за их корректностью.

=== Отладка программ в Visual Studio Code

Редактор VS Code с установленными расширениями C\# и C\# Dev Kit предоставляет весь необходимый функционал для отладки .NET-приложений: установку точек останова, пошаговое выполнение с заходом и без захода в подпрограммы и просмотр значений переменных.

Для запуска программы в режиме отладки нужно нажать на стрелку рядом с кнопокй запуска программы и в контекстном меню выбрать отладку, также можно использовать клавишу F5.

=== Отладка в других редакторах

В каждом редакторе или среде разработки процесс настройки отладчика может сильно отличаться. Для вашего редактора вы можете найти соответствующие инструкции по настройке в интернете.

Например, в случае с редактором Neovim отладка осуществляется с использованием так называемого Debug Adapter Protocol (DAP) и внешнего отладчика .NET, в качестве которого выступает netcoredbg.
Для этого потребуется вручную установить необходимые плагины и настроить конфигурацию.
Но после настройки Вам будет также доступен весь нужный функционал для отладки.

=== Параметр sender в обработчиках событий

В обработчиках событий пользовательского интерфейса часто используется параметр `sender`.
Этот параметр содержит ссылку на объект, который вызвал событие.

Пример обработчика события нажатия кнопки:

```cs
protected void Button_Click(object sender, EventArgs e)
{
  Button btn = sender as Button;
  btn.Content = "Кнопка нажата";
}
```

В данном примере производится приведение параметра `sender` к типу `Button`, после чего появляется возможность обращаться к свойствам и методам этого элемента управления.

Использование параметра `sender` позволяет создавать универсальные обработчики событий для нескольких элементов интерфейса.

== Пример написания программы

*Задание:* Вычислить и вывести на экран таблицу значений функции $y = a times ln x$  при $x$, изменяющемся от $x_0$ до $x_k$ с шагом $d x$, $a$ --- константа.

Панель диалога представлена на изображении:

#figure(
  image("lab1_imports/images/img4_4.png", width: 60%),
  caption: [Окно программы для табулирования функции.],
)

Текст обработчика нажатия кнопки Вычислить приведен ниже.

```cs
private void button1_Click(object sender, EventArgs e)
{
  // Считывание начальных данных
  double x0 = Convert.ToDouble(textBox1.Text);
  double xk = Convert.ToDouble(textBox2.Text);
  double dx = Convert.ToDouble(textBox3.Text);
  double a = Convert.ToDouble(textBox4.Text);
  textBox5.Text = "Работу выполнил Иванов М.А." + Environment.NewLine;
  // Цикл для табулирования функции
  double x = x0;
  while (x <= (xk + dx/2))
  {
    double y = a * Math.Log(x);
    textBox5.Text += "x =" + Convert.ToString(x) +
      "; y =" + Convert.ToString(y) + Environment.NewLine;
    x = x + dx;
  }
}
```

После отладки программы составьте тест (`X0 = 2`, `Xk = 4`, `Dx = 0.2`), установите точку останова на оператор перед циклом и запустите программу в отладочном режиме (F5). После попадания на точку остановки, нажимая клавишу F10, выполните пошагово программу и проследите, как меняются все переменные в процессе выполнения.

== Индивидуальные задания

По указанию преподавателя выберите нужный вариант задачи из нижеприведенного списка. Откорректируйте панель диалога и текст программы.

Cоставьте программу для табулирования функции $y(x)$, выведите на экран значения $x$ и $y(x)$. Добавьте вторую кнопку, которая будет вызывать ту же процедуру которую выполняет основная кнопка (но шаг при этом уменьшается в два раза). Две кнопки должны вызывать один и тот же метод.

// #set page(columns: 2)
1.
$ y = (10^(-2) b c) / x + cos(sqrt(a^3 x)), $
$ x_0 = -1.5; " " x_k = 3.5; " " d x = 0.5; $
$ a = -1.25; " " b = -1.5; " " c = 0.75. $

2.
$ y = 1.2 (a - b)^3 times e^(x^2) + x, $
$ x_0 = -0.75; " " x_k = -1.5; " " d x = -0.05; $
$ a = 1.5; " " b = 1.2. $

3.
$ y = 10^(-1) a x^3 times tg(a - b x), $
$ x_0 = -0.5; " " x_k = 2.5; " " d x = 0.05; $
$ a = 10.2; " " b = 1.25. $

4.
$ y = a x^3 + cos^2 (x^3 - b), $
$ x_0 = 5.3; " " x_k = 10.3; " " d x = 0.25; $
$ a = 1.35; " " b = -6.25. $

5.
$ y = x^4 + cos(2 + x^3 - d), $
$ x_0 = 4.6; " " x_k = 5.8; " " d x = 0.2; $
$ d = 1.3. $

6.
$ y = x^2 + tg(5 x + b / x), $
$ x_0 = -1.5; " " x_k = -2.5; " " d x = -0.5; $
$ b = -0.8. $

7.
$ y = 9 (x + 15 sqrt(x^3 + b^3)), $
$ x_0 = -2.4; " " x_k = 1; " " d x = 0.2; $
$ b = 2.5. $

8.
$ y = 9 x^4 + sin(57.2 + x), $
$ x_0 = -0.75; " " x_k = -2.05; " " d x = -0.2. $

9.
$ y = 0.0025 b x^3 + sqrt(x + e^(0.82)), $
$ x_0 = -1; " " x_k = 4; " " d x = 0.5; $
$ b = 2.3. $

10.
$ y = x times sin(sqrt(x + b - 0.0084)), $
$ x_0 = -2.05; " " x_k = -3.05; " " d x = -0.2; $
$ b = 3.4. $

11.
$ y = x + sqrt(abs(x^3 + a - b e^x)), $
$ x_0 = -4; " " x_k = -6.2; " " d x = -0.2; $
$ a = 0.1. $

12.
$ y = 9 (x^3 + b^3) times tg(x), $
$ x_0 = 1; " " x_k = 2.2; " " d x = 0.2; $
$ b = 3.2. $

13.
$ y = abs(x - b)^(1/2) / abs(b^3 - x^3)^(3/2) + ln(abs(x - b)), $
$ x_0 = -0.73; " " x_k = -1.73; " " d x = -0.1; $
$ b = -2. $

14.
$ y = (x^(5/2) - b) times ln(x^2 + 12.7), $
$ x_0 = 0.25; " " x_k = 5.2; " " d x = 0.3; $
$ b = 0.8. $
