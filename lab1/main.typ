#import "conf.typ": conf
#show: conf.with(
  title: [= Лабораторная работа №1
    Визуальное проектирование в С\#],
  type: "pract",
  info: (
    author: (
      name: [],
      faculty: [],
      group: "",
      sex: "",
    ),
    inspector: (
      degree: "",
      name: "",
    ),
  ),
  settings: (
    title_page: (
      enabled: true,
    ),
    contents_page: (
      enabled: true,
    ),
  ),
)

= Начало работы с Avalonia

== Установка

Avalonia --- это кроссплатформенный фреймворк, работать с ним можно и на Windows, и на Linux, и на MacOS. Рассмотрим основные способы установки этого фреймворка на разные системы:

=== Visual Studio (только для Windows)

В скриншотах будет приводиться Visual Studio 2026, но алгоритм установки Avalonia на Visual Studio 2022 аналогичен приведённому ниже.

Откройте Visual Studio Installer и нажмите "изменить" около вашей версии Visual Studio.

#figure(
  image("./images/starting_with_avalonia/visual_studio/vs_installer.png", width: 80%),
  caption: [Visual Studio Installer],
)

Добавьте в Visual Studio компонент "Разработка классических приложений .NET".

#figure(
  image("./images/starting_with_avalonia/visual_studio/editing_vs.png", width: 80%),
  caption: [Добавление компонента],
)

После установки откройте Visual Studio, нажмите на вкладку "Расширения" и выберите "Управление расширениями".

#figure(
  image("./images/starting_with_avalonia/visual_studio/extensions.png", width: 80%),
  caption: [Открытие менеджера расширений],
)

Напишите в поиске "Avalonia" и установите расширение Avalonia от Avalonia Team.

#figure(
  image("./images/starting_with_avalonia/visual_studio/avalonia_extension.png", width: 80%),
  caption: [Установка расширения для работы с Avalonia]
)

Выйдите из Visual Studio, в установщике расширений, который должен был появиться вскоре после этого, нажмите "Modify" и дождитесь конца его работы.

#figure(
  image("images/starting_with_avalonia/visual_studio/vsix_installer.png", width: 80%),
  caption: [VSIX Installer]
)

После этого откройте Visual Studio, начните создавать новый проект, из шаблонов выберите "Avalonia .NET App (Avalonia UI)" и продолжите создание проекта.

#figure(
  image("images/starting_with_avalonia/visual_studio/avalonia_template.png", width: 80%),
  caption: [VSIX Installer]
)

И, в конце концов, вас встретит окно с готовым проектом Avalonia, с которым Вы можете продолжать работу.

#figure(
  image("images/starting_with_avalonia/visual_studio/avalonia_final.png", width: 80%),
  caption: [Рабочий проект]
)

== Настройка окна приложения

После создания проекта Avalonia App у вас автоматически появится главное окно --- MainWindow.axaml, а также связанный с ним файл кода MainWindow.axaml.cs.
Файл .axaml содержит описание пользовательского интерфейса в формате XAML, а файл .axaml.cs --- код на C\#, в котором можно обрабатывать события элементов интерфейса.

Изменять свойства окна можно двумя способами:
- через XAML (описание разметки);
- через код C\# (в классе MainWindow).

Пример изменения заголовка и размеров окна:
```xaml
<Window xmlns="https://github.com/avaloniaui"
        Title="Лаба №1. ФИО, группа"
        Width="400" Height="300">
</Window>
```

Цвет фона объекта можно задать свойством Background:
```xaml
<Window Background="AntiqueWhite">
```

Также можно задать и цвет текста:
```xaml
<Window Background="AntiqueWhite" Foreground="Blue">
```

== Размещение элементов интерфейса

Элементы управления (кнопки, поля ввода, надписи и т.д.) размещаются внутри контейнеров разметки Avalonia.
Наиболее распространённые контейнеры:
- StackPanel --- размещает элементы в ряд вертикально или горизонтально;
  Пример:
  ```xaml
  <StackPanel Margin="10">
      <TextBlock Text="Введите значение:"/>

      <TextBox Name="textBox1"/>

      <Button Content="Выполнить" Click="OnButtonClick"/>
  </StackPanel>
  ```
- Grid --- разбивает пространство окна на сетку со строками и столбцами. Элементы можно размещать, указывая, в какой строке и столбце они находятся.
  Пример:
  ```xaml
  <Grid RowDefinitions="Auto,Auto,Auto,Auto" ColumnDefinitions="Auto,*" Margin="10">
      <TextBlock Text="Введите значение:" Grid.Row="0" Grid.Column="0" VerticalAlignment="Center"/>
      <TextBox Name="textBox1" Grid.Row="0" Grid.Column="1"/>
      <Button Content="Выполнить" Click="OnButtonClick"/>
  </Grid>
  ```
  - RowDefinitions и ColumnDefinitions задают сетку: здесь 4 строки (по высоте --- Auto) и 2 столбца (первый узкий, второй растягивается --- \*);
  - Grid.Row и Grid.Column указывают позицию элемента в сетке;
  - Grid.ColumnSpan="2" позволяет занять обе колонки (например, кнопкой).
- Canvas --- позволяет позиционировать элементы по абсолютным координатам. Каждый элемент имеет свойства Canvas.Left, Canvas.Top, Canvas.Right, Canvas.Bottom.
  Пример:
  ```xaml
  <Canvas>
      <TextBlock Text="Введите значение:" Canvas.Left="10" Canvas.Top="20"/>
      <TextBox Name="textBox1" Width="100" Canvas.Left="150" Canvas.Top="15"/>
      <Button Content="Выполнить" Width="120"
              Canvas.Left="10" Canvas.Top="150"
              Click="OnButtonClick"/>
  </Canvas>
  ```
  - Используется абсолютное позиционирование --- каждая координата задаётся вручную;
  - Такой способ удобен для простых макетов, где нужно точно контролировать расположение элементов.	Однако для адаптивных интерфейсов лучше использовать Grid или StackPanel.

== Размещение строки ввода (TextBox)

Для ввода текстовых или числовых данных используется элемент TextBox.

Пример размещения трёх полей ввода:
```xaml
<StackPanel Margin="10">
    <TextBox Name="textBox1"/>
    <TextBox Name="textBox2"/>
    <TextBox Name="textBox3"/>
</StackPanel>
```

Получить введённый текст можно в C\# коде:
```cs
string s = textBox1.Text;
```

Задать шрифт можно в XAML:
```xaml
<TextBox FontSize="16" FontFamily="Arial"/>
```

== Размещение надписей (TextBlock)

В Avalonia вместо Label чаще используется TextBlock --- элемент, который отображает текстовые надписи.
Внимание: не путать TextBlock и TextBox, TextBlock используется для вывода текста, а TextBox --- для ввода.

Пример:
```xaml
<TextBlock Text="Введите значение X:" FontSize="16"/>
```

== События и обработчики

Каждый элемент интерфейса может вызывать события (например, Click у кнопки).
Чтобы обработать событие, в XAML указывается имя метода, а сам метод реализуется в файле .axaml.cs.

=== Обработка события нажатия кнопки (Click)

Пример:
```xaml
<Button Name="button1" Content="Выполнить" Click="OnButtonClick"/>
```

```cs
private void OnButtonClick(object? sender, RoutedEventArgs e)
{
    MessageBox.Avalonia.MessageBoxManager
        .GetMessageBoxStandardWindow("Сообщение", "Привет!")
        .Show();
}
```

=== Обработка события загрузки окна (Opened)

Событие, аналогичное Load в WinForms, --- это Opened в Avalonia.
```xaml
<Window xmlns="https://github.com/avaloniaui"
        Title="..."
        Opened="OnWindowOpened">
```

```cs
private void OnWindowOpened(object? sender, EventArgs e)
{
    this.Background = Brushes.AntiqueWhite;
}
```

== Запуск и работа программы

Программу можно запускать из любой IDE или терминала командой:
```sh
dotnet run
```

После успешной сборки появится окно приложения Avalonia.
Для завершения программы просто закройте окно.

== Динамическое изменение свойств

Свойства элементов можно менять в коде во время выполнения:
```cs
textBlock1.Text = "Привет!";
this.Background = Brushes.LightBlue;
```

== Индивидуальные задания
Ниже приведено 14 вариантов задач.
- Все элементы интерфейса (кнопки, поля ввода, текстовые надписи и т.п.) размещайте в окне MainWindow.axaml.
- Если в тексте задания явно не указано иное, то для разметки интерфейса можно использовать любой контейнер: StackPanel, Grid или Canvas.
- Для визуальных надписей используйте TextBlock, для ввода данных --- TextBox, для интерактивных действий --- Button.
- Изменение свойств (текста, цвета, видимости и т.д.) выполняйте в коде MainWindow.axaml.cs.
- События в Avalonia связываются через атрибуты XAML (например `Click="OnButtonClick"`) или через привязку в коде.

1. Разместите в окне четыре кнопки (`Button`). Сделайте на кнопках следующие надписи: Красный, Зелёный, Синий, Жёлтый. Создайте четыре обработчика события `Click`, которые будут менять цвет окна (`this.Background`) в соответствии с текстом на кнопке.
2. Разместите в окне две кнопки (`Button`) и одну надпись (`TextBlock`). Сделайте на кнопках надписи: "Привет", "До свидания". Создайте обработчики события Click для этих кнопок, которые будут изменять текст надписи (`TextBlock.Text`) с одного на другой. Создайте обработчик события загрузки окна (`Opened`), который установит цвет фона окна и изменит текст надписи на строку "Начало работы".
3. Разместите в окне две кнопки (`Button`) и одну надпись (`TextBlock`). Сделайте на кнопках надписи: "Скрыть", "Показать". Создайте обработчики событий `Click`, которые будут скрывать или показывать надпись (через свойство `IsVisible`). Создайте обработчик события загрузки окна (`Opened`), который установит цвет фона окна и изменит текст надписи на строку "Начало работы".
4. Разместите в окне три кнопки (`Button`) и одно поле ввода (`TextBox`). Сделайте на кнопках надписи: Скрыть, Показать, Очистить. Создайте обработчики событий `Click`, которые будут скрывать (`IsVisible = true`), показывать поле ввода (`IsVisible = false`) и очищать содержимое поля (`Text = ""`).
5. Разместите в окне две кнопки (`Button`) и одно поле ввода (`TextBox`). Сделайте на кнопках надписи: Заполнить, Очистить. Создайте обработчики событий `Click`, которые будут очищать поле (`Text = ""`) и заполнять его символами "`******`". Создайте обработчик события загрузки окна (`Opened`), который установит цвет фона окна и задаст текст поля "`+++++`".
6. Разработайте простую игру. На окне разместите пять кнопок (`Button`). При нажатии на любую кнопку некоторые кнопки должны становиться видимыми (`IsVisible = true`), а некоторые --- невидимыми (`IsVisible = false`). Цель игры --- скрыть все кнопки.
7. Разработайте игру, в которой на окне размещены четыре кнопки (`Button`) и четыре надписи (`TextBlock`). При нажатии на любую кнопку часть надписей становится невидимой, а часть --- видимой. Цель игры --- скрыть все надписи.
8. Разместите на окне несколько кнопок (`Button`). Создайте обработчики событий `Click`, которые будут делать нажатую кнопку неактивной (`IsEnabled = false`). Создайте обработчик события изменения размера окна (`Resized`), который будет устанавливать всем кнопкам состояние активное (`IsEnabled = true`).
9. Разместите на окне ряд кнопок (`Button`). Создайте обработчики событий `Click`, которые будут делать неактивной следующую кнопку. Создайте обработчик события нажатия кнопки мыши на окне (PointerPressed), который будет устанавливать всем кнопкам активное состояние (`IsEnabled = true`).
10. Разместите на окне три кнопки (`Button`) и одно поле ввода (`TextBox`). Сделайте на кнопках надписи: "`*****`", "`+++++`", "`00000`". Создайте обработчики событий `Click`, которые будут выводить текст с кнопки в поле ввода (`TextBox.Text = button.Content.ToString()`). Создайте обработчик события загрузки окна (`Opened`), который установит цвет фона окна и задаст текст "Готов к работе" в поле ввода.
11. Разместите на окне несколько полей ввода (`TextBox`). Создайте обработчики события нажатия кнопки мыши на данные поля ввода (`PointerPressed`), которые будут выводить в текущее поле его номер. Создайте обработчик события изменения размера окна (`Resized`), который будет очищать все поля ввода (`Text = ""`).
12. Разместите на окне одно поле ввода (`TextBox`), одну надпись (`TextBlock`) и одну кнопку (`Button`). Создайте обработчик события `Click` для кнопки, который будет копировать текст из поля ввода в надпись. Создайте обработчик события нажатия кнопки мышки на окне (`PointerPressed`), который будет устанавливать цвет фона, изменять текст надписи на "Начало работы" и очищать поле ввода.
13. Разместите на окне одно поле ввода (`TextBox`) и две кнопки (`Button`) с надписями Блокировать и Разблокировать. Создайте обработчики событий `Click`, которые будут делать поле ввода активным или неактивным (`IsEnabled`). Создайте обработчик события нажатия кнопки мышки на окне (`PointerPressed`), который будет изменять цвет фона и делать все элементы окна невидимыми (`IsVisible = false`).
14. Разместите на окне четыре кнопки (`Button`). Создайте для каждой обработчик события `Click`, который будет изменять размеры (`Width`, `Height`) и положение (`Canvas.Left`, `Canvas.Top`) других кнопок на окне. Для позиционирования используйте контейнер `Canvas`.

#pagebreak()
= Программирование линейных алгоритмов

*Цель второй части*

Научиться создавать структуру простейшей программы на языке C\#.
Освоить написание и отладку линейных алгоритмов.

== Структура приложения

В .NET существует два уровня организации:

- Project (Проект) --- основная единица, с которой работает программист. Содержит все исходные материалы для приложения, такие как файлы исходного кода, разметки интерфейса, ресурсы (иконки, изображения, стили), а также данные конфигурации, такие как параметры компилятора.

- Solution (Решение) --- контейнер, который объединяет один или несколько проектов. Один из проектов помечается как стартовый, и именно он запускается при выполнении команды `dotnet run` или при старте отладки.

Проект Avalonia включает следующие основные файлы:
- .csproj --- файл проекта. Содержит сведения о зависимостях, используемых библиотеках, версии .NET, настройках сборки. Создаётся автоматически и редактируется вручную только при необходимости (например, чтобы добавить пакет через NuGet).
- Program.cs --- точка входа приложения. Здесь выполняется запуск Avalonia-приложения.
- App.axaml / App.axaml.cs --- Файлы, содержащие глобальные настройки интерфейса: стили, темы, ресурсы.
- MainWindow.axaml --- XAML-файл, описывающий внешний вид главного окна. В нём размещаются элементы интерфейса (TextBox, Button, TextBlock и т.д.) и контейнеры (Grid, StackPanel, Canvas и т.д.).
- MainWindow.axaml.cs --- файл кода, содержащий обработчики событий и программную логику.
- Assets --- необязательная директория (по умолчанию отсутствует). В ней хранятся изображения, иконки и шрифты, используемые в графическом интерфейсе.

Пример содержимого файла MainWindow.axaml.cs:
```cs
// Раздел подключенных пространств имён
using System;
using Avalonia.Controls;

// Пространство имён нашего проекта
namespace MyFirstApp
{
    // Класс окна
    public partial class MainWindow : Window
    {
        // Методы окна
        public MainWindow()
        {
            InitializeComponent();
        }
    }
}
```

В разделе подключения пространств имён (каждая строка которого располагается в начале файла и начинается ключевым словом `using`) перечислены те подсистемы .NET, которые используются в программе. Каждое пространство имён включает в себя классы, выполняющие определённую работу, например, классы для работы с сетью располагаются в пространстве System.Net, для работы с файлами --- в System.IO, а классы элементов интерфейса Avalonia находятся в пространстве имён Avalonia.Controls.

Для того чтобы не происходило конфликтов имён классов и переменных, классы нашего проекта также помещаются в отдельное пространство имён. Определяется оно ключевым словом namespace, после которого следует имя пространства (обычно оно совпадает с именем проекта).

Внутри пространства имён помещаются наши классы --- в новом проекте это класс окна, который содержит все методы для управления поведением окна. Обратите внимание, что в определении класса присутствует ключевое слово `partial`, это говорит о том, что в нашем программном файле .axaml.cs представлена только часть класса, где содержатся обработчики событий и логика управления элементами, а другая его часть определена в файле разметки .axaml, где описан внешний вид окна.

Наконец, внутри класса располагаются переменные, методы и другие элементы программы. Фактически, основная часть программы размещается внутри класса при создании обработчиков событий.

== Описание данных

Типы данных имеют особенное значение в С\#, поскольку это строго типизированный язык. Это означает, что все операции подвергаются строгому контролю со стороны компилятора на соответствие типов, причем код с недопустимыми операциями не компилируются. Такая строгая проверка типов позволяет предотвратить ошибки и повысить надёжность программ. Для обеспечения контроля типов все переменные, выражения и значения должны принадлежать к определенному типу. Такого понятия, как "бестиповая" переменная, в данном языке программирования вообще не существует. Более того, тип значения определяет те операции, которые разрешается выполнять над ним. Операция, разрешенная для одного типа данных, может оказаться недопустимой для другого.

В С\# имеются две общие категории встроенных типов данных: типы значений и ссылочные типы. Они отличаются по содержимому переменной. Концептуально разница между ними состоит в том, что тип значения (value type) хранит данные непосредственно, в то время как ссылочный тип (reference type) хранит ссылку на значение.

Эти типы сохраняются в разных местах памяти: типы значений сохраняются в области, известной как стек, а ссылочные типы --- в области, называемой управляемой кучей (heap).

#figure(
  image("./images/cs_var_types.png", width: 80%),
  caption: [Схема типов данных в С\#],
)

- Целочисленные типы
В C\# определены девять целочисленных типов: char, byte, sbyte, short, ushort, int, uint, long и ulong. Но тип char в основном применяется для представления символов и поэтому рассматривается отдельно. Остальные восемь целочисленных типов предназначены для числовых расчетов.

- Типы с плавающей точкой
Типы с плавающей точкой позволяют представлять числа с дробной частью. В C\# имеются две разновидности типов данных с плавающей точкой: float и double. Они представляют числовые значения с одинарной и двойной точностью соответственно.

- Десятичный тип данных
Для представления чисел с плавающей точкой высокой точности предусмотрен также десятичный тип decimal, который предназначен для применения в финансовых вычислениях.

- Символы
В C\# символы представлены не 8-разрядным кодом, как во многих других языках программирования, например С++, а 16-разрядным Unicode. В Unicode набор символов представлен настолько широко, что он охватывает символы практически из всех существующих естественных языков.

- Логический тип данных
Тип bool представляет два логических значения: "истина" и "ложь". Эти логические значения обозначаются в C\# зарезервированными словами true и false соответственно. Следовательно, переменная или выражение типа bool будет принимать одно из этих логических значений.

- Строки
Основным типом при работе со строками является тип string, задающий строки переменной длины. Тип string представляет последовательность из нуля или более символов в кодировке Unicode. Класс String в языке C\# относится к ссылочным типам. Над строками --- объектами этого класса --- определен широкий набор операций, соответствующий современному представлению о том, как должен быть устроен строковый тип. По сути, текст хранится в виде последовательной доступной только для чтения коллекции объектов char.

Рассмотрим самые популярные данные --- переменные и константы. Переменная - это ячейка памяти, которой присвоено некоторое имя, и это имя используется для доступа к данным, расположенным в данной ячейке. Для каждой переменной задаётся тип данных --- диапазон всех возможных значений для данной переменной. Объявляются переменные непосредственно в коде программы.

Примеры объявления переменных:

```cs
int a;     // Только объявление
int b = 7; // Объявление и инициализация значением
```
Для того чтобы присвоить значение символьной переменной, достаточно заключить это значение (т.е. символ) в одинарные кавычки:

```cs
char ch;           // Только объявление
char symbol = 'A'; // Объявление и инициализация значением
```

Несмотря на то, что тип char определен в С\# как целочисленный, его не следует путать со всеми остальными целочисленными типами.
Частным случаем переменных являются константы. Константы - это переменные, значения которых не меняются в процессе выполнения программы. Константы описываются как обычная переменная, только с ключевым словом `const` вначале:

```cs
const int c = 5;
```

== Ввод/вывод данных в программу

Рассмотрим один из способов ввода данных через элементы, размещённые в окне приложения.
В приложениях Avalonia для ввода данных чаще всего используется элемент управления TextBox, обращение к которому осуществляется через его свойство `Text`. Свойство `Text` хранит строку символов, введённую пользователем. Поэтому данные можно получить следующим образом:

```cs
private void OnButtonClick(object? sender, RoutedEventArgs e)
{
    string s = textBox1.Text;
}
```

Однако со строкой символов трудно производить арифметические операции, поэтому лучше всего при вводе числовых данных перевести строку в целое или вещественное число. Для этого в C\# существуют методы `Parse`, определённые для различных типов данных. Например, для преобразования строки в целое число используется метод `int.Parse`, а для вещественного числа --- метод `double.Parse`.

Таким образом, предыдущий пример можно переписать следующим образом:

```cs
private void OnButtonClick(object? sender, RoutedEventArgs e)
{
    string s = textBox1.Text;
    int a = int.Parse(s);
    int b = a * a;
}
```

Перед выводом числовые данные следует преобразовать назад в строку. Для этого у каждой переменной существует метод `ToString`, который возвращает в результате строку с символьным представлением значения. Вывод данных можно осуществлять в элементы TextBox или TextBlock, также используя свойство `Text`. Например:

```cs
private void OnButtonClick(object? sender, RoutedEventArgs e)
{
    string s = textBox1.Text;
    int a = int.Parse(s);
    int b = a * a;
    textBlock1.Text = b.ToString();
}
```

Обработка исключений --- это описание реакции программы на определённые события (исключения) во время её выполнения. Реакцией программы может быть, например, корректное завершение работы программы, вывод информации об ошибке или запрос повторения действия (при вводе данных).
Примерами исключений может быть:
- деление на ноль;
- конвертация некорректных данных из одного типа в другой;
- попытка открыть файл, которого не существует;
- доступ к элементу вне рамок массива;
- исчерпывание памяти программы;
- и другое.

Для обработки исключений в C\# используется оператор try-catch. Он имеет следующую структуру:

```cs
try
{
    // Блок кода, в котором может возникнуть исключение
}
catch ([тип исключения] [имя])
{
    // Блок обработки исключения
}
```

Работа оператора происходит следующим образом: выполняется код в блоке try, и если в нём возникает исключение указанного в catch типа, управление передаётся в соответствующий блок catch. При этом весь оставшийся код от момента выбрасывания исключения до конца блока try не будет выполнен. После выполнения блока catch, оператор try-catch завершает работу.

Указывать имя исключения не обязательно. Исключение представляет собой объект, и к нему мы имеем доступ через это имя. С этого объекта мы можем получить, например, стандартное сообщение об ошибке (Message), или трассировку стека (StackTrace), которая поможет узнать место возникновения ошибки. В этом объекте хранится детальная информации об исключении.

Если тип выброшенного исключения не будет соответствовать типу, указанному в catch --- исключение не обработается, и программа завершит работу аварийно.

Ниже приведён пример программы, в которой используется обработка исключения некорректного формата данных:

```cs
private void button1_Click(object sender, EventArgs e)
{

    try
    {
        string s = textBox1.Text;
        int a = int.Parse(s);
        int b = a * a;
        textBox1.Text = b.ToString();
    }
    catch (Exception)
    {
        MessageBox.Show("Введите число");
    }
    finally
    {
        // Блок кода, который выполнится обязательно
    }

}
```

*Типы исключений*

Некоторые из часто встречаемых типов исключений:
- `Exception` --- базовый тип всех исключений. Блок catch, в котором указан тип Exception будет "ловить" все исключения;
- `FormatException` --- некорректный формат операнда или аргумента (при передаче в метод).
- `NullReferenceException` --- В экземпляре объекта не задана ссылка на объект, объект не создан;
- `IndexOutOfRangeException` --- индекс вне рамок коллекции;
- `FileNotFoundException` --- файл не найден;
- `DivideByZeroException` --- деление на ноль.

*Несколько блоков `catch`*

Одному блоку `try` может соответствовать несколько блоков `catch`:

```cs
try
{
   // Блок кода, в котором может возникнуть исключение
}
catch (FormatException)
{
  // Блок-обработка исключения 1
}
catch (FileNotFoundException)
{
  // Блок-обработка исключения 2
}
```

В зависимости от того или другого типа исключения в блоке `try`, выполнение будет передано соответствующему блоку `catch`.

*Блок `finally`*

Оператор try-catch также может содержать блок `finally`. Особенность блока `finally` в том, что код внутри этого блока выполнится в любом случае, в независимости от того, было ли исключение или нет.

```cs
try
{
   // Блок кода, в котором может возникнуть исключение
}
catch (Exception)
{
   // Обработка исключения
}
finally
{
  // Блок кода, который выполнится обязательно
}
```

Выполнение кода программы в блоке `finally` происходит в последнюю очередь. Сначала `try`, затем `finally` или `catch-finally` (если было исключение).
Обычно, он используется для освобождения ресурсов. Классическим примером использования блока `finally` является закрытие файла.

*Зачем блок `finally`?*

Очень часто можно услышать вопрос, для чего нужен этот блок. Ведь, кажется, можно освободить ресурсы просто после оператора `try-catch`, без использования `finally`. А ответ очень прост. `finally` гарантирует выполнение кода, несмотря ни на что. Даже если в блоках `try` или `catch` будет происходить выход из метода с помощью оператора `return` --- `finally` выполнится.

== Арифметические действия и стандартные функции

При вычислении выражения, стоящего в правой части оператора присваивания, могут использоваться арифметические операции: "`*`" --- умножение, "`+`" --- сложение, "`-`" --- вычитание, 	"`/`" --- деление, "`%`" --- взятие остатка от деления. Для задания приоритетов операций могут использоваться круглые скобки "`(` `)`". Также могут использоваться стандартные математические функции, представленные методами класса `Math`:
- `Math.Sin(a)` --- синус (аргумент задаётся в радианах);
- `Math.Cos(a)` --- косинус (аргумент задаётся в радианах);
- `Math.Atan(a)` --- арктангенс (аргумент задаётся в радианах);
- `Math.Log(a)` --- натуральный логарифм;
- `Math.Exp(a)` --- экспонента;
- `Math.Pow(x,y)` --- возведение переменной `x` в степень `y`;
- `Math.Sqrt(a)` --- квадратный корень;
- `Math.Abs(a)` --- модуль числа;
- `Math.Truncate(a)` --- целая часть числа;
- `Math.Round(a)` --- округление числа;

Более подробную информацию смотрите в приложении.

== Пример написания программы

*Задание:* составить программу вычисления для заданных значений x, y, z арифметического выражения

$
  u = tg^2 (x + y) - e^(y - z) sqrt(cos x^2 + sin z^2).
$

Панель диалога программы организовать в виде, представленном на изображении:

#figure(
  image("images/img2_1.png", width: 60%),
  caption: [Внешний вид программы.],
)

Для вывода результатов используется элемент управления `TextBox`, который в Avalonia может работать как многострочный редактор.
Чтобы обеспечить возможность ввода и вывода нескольких строк, необходимо установить свойство `AcceptsReturn="True"`. Это позволяет переносить текст на новую строку и растягивать элемент как по горизонтали, так и по вертикали.
Для отображения полосы прокрутки используется attached-свойство:

```xaml
ScrollViewer.VerticalScrollBarVisibility="Visible"
```

После установки этих свойств окно будет позволять просматривать большие объёмы текста.

В многострочном текстовом поле Avalonia также существует свойство Text, которое содержит весь текст, отображаемый в элементе.
Добавление новой строки выполняется так же, как и в стандартных приложениях C\# --- с помощью конструкции:

```cs
textBox4.Text += Environment.NewLine + "Привет";
```

В этом примере к текущему содержимому окна добавляется символ переноса строки (который может отличаться в разных операционных системах, поэтому используется свойство класса `Environment.NewLine`) и сама новая строка.
Если добавляется числовое значение, то его предварительно нужно привести к строковому виду методом `ToString()`.

Работа с программой происходит следующим образом. Нажмите (щелкните мышью) кнопку "Выполнить". В окне `textBox4` появляется результат. Измените исходные значения x, y, z в окнах `textBox1` --- `textBox3` и снова нажмите кнопку "Выполнить" --- появится новые результаты.

*Полный код программы имеет следующий вид:*

MainWindow.axaml:

```xaml
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        x:Class="test.MainWindow"
        Title="Лабораторная работа №1"
        Width="420" Height="420">

    <StackPanel Margin="10" Spacing="6">

        <TextBlock Text="Введите значение X:"/>
        <TextBox Name="textBox1" Width="200"/>

        <TextBlock Text="Введите значение Y:"/>
        <TextBox Name="textBox2" Width="200"/>

        <TextBlock Text="Введите значение Z:"/>
        <TextBox Name="textBox3" Width="200"/>

        <TextBlock Text="Результат выполнения программы:"/>

        <TextBox Name="textBox4"
                 AcceptsReturn="True"
                 ScrollViewer.VerticalScrollBarVisibility="Visible"
                 Height="160"
                 Width="360"
                 IsReadOnly="True"/>

        <Button Name="button1"
                Content="Выполнить"
                HorizontalAlignment="Right"
                Width="100"
                Click="OnButtonClick"/>

    </StackPanel>

</Window>
```

MainWindow.axaml.cs:

```cs
using Avalonia.Controls;
using Avalonia.Interactivity;
using System;

namespace MyFirstApp;

public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();

        textBox1.Text = "3.4";   // Начальное значение X
        textBox2.Text = "0.74";  // Начальное значение Y
        textBox3.Text = "19.43"; // Начальное значение Z

        // Вывод строки в многострочный редактор
        textBox4.Text = "Лаб. раб. №1. Иванов А.А. 251 гр.";
    }

    private void OnButtonClick(object? sender, RoutedEventArgs e)
    {
        try
        {
            // Считывание значения X
            double x = double.Parse(textBox1.Text!);

            // Вывод значения X
            textBox4.Text += Environment.NewLine +
                             "X = " + x.ToString();

            // Считывание значение Y
            double y = double.Parse(textBox2.Text!);

            // Вывод значения Y
            textBox4.Text += Environment.NewLine +
                             "Y = " + y.ToString();

            // Считывание значения Z
            double z = double.Parse(textBox3.Text!);

            // Вывод значения Z
            textBox4.Text += Environment.NewLine +
                             "Z = " + z.ToString();

            // Вычисление арифметическое выражение
            double a = Math.Tan(x + y) * Math.Tan(x + y);
            double b = Math.Exp(y - z);
            double c = Math.Sqrt(Math.Cos(x * x) + Math.Sin(z * z));
            double u = a - b * c;

            // Вывод результата
            textBox4.Text += Environment.NewLine +
                             "Результат U = " + u.ToString();
        }
        catch (FormatException)
        {
            textBox4.Text += Environment.NewLine +
                             "Ошибка: введите корректные числовые значения.";
        }
        catch (Exception ex)
        {
            textBox4.Text += Environment.NewLine +
                             "Неизвестная ошибка: " + ex.Message;
        }
    }
}
```

*Представление в экспоненциальной форме чисел:*

$1 "e" 2 --> 1 times 10^2$

$1 "e" - 2 --> 1 times 10^(-2)$

```cs
string s = textBox1.Text;
double a = double.Parse(s);
double b = a * a + 1e2 + 1e-2;
textBox1.Text = b.ToString();
```

== Индивидуальные задания

Ниже приведено 15 вариантов задач. Номер задания соответствует номеру студента в списке группы, если не хватает --- начинать отсчёт с начала.
Уточните условие задания, количество, наименование, типы исходных данных.
В соответствии с этим необходимо:
- установить нужное количество элементов `TextBox` для ввода переменных;
- задать текстовые заголовки `TextBlock` для каждого поля ввода;
- определить необходимые размеры шрифтов, отступы, расположение элементов;
- выбрать типы переменных в программе и функции преобразования при вводе (`double.Parse`, `int.Parse` и др.);
- установить исходные данные (значения по умолчанию), которые будут автоматически появляться в окнах `TextBox` при запуске приложения;
- обязательно использовать обработку исключений (`try-catch`) для проверки корректности вводимых значений.

Прочтите в приложении описание меню "Файл", "Правка", "Отладка", а также описание элемента управления `TextBox`.
С помощью редактора XAML измените цвет окна (`Background`), размеры шрифтов и другие визуальные свойства интерфейса.

1.
$ t = (2 cos(x - pi/6))/(0.5 + sin^2 y) times (1 + (z^2)/(3 - z^2/5)). $
При $x = 14.26$, $y = -1.22$, $z = 3.5 times 10^(-2)$ $t = 0.564849$.

2.
$
  u = (root(3, 8 + abs(x - y)^2 + 1))/(x^2 + y^2 + 2) - e^(abs(x - y)) ("tg"^2 z + 1)^x.
$
При $x = -4.5$, $y = 7.5 times 10^(-5)$, $z = 84.5$ $u = -55.6848$.

3.
$
  v = (1 + sin^2 (x + y))/(abs(x - (2 y)/(1 + x^2 y^2))) x^(abs(y)) + cos^2 ("arctg" 1/z).
$
При $x = 3.74 times 10^(-2)$, $y = -0.825$, $z = 16$ $v = 1.0553$.

4.
$
  w = abs(cos x - cos y)^((1 + 2 sin^2 y)) times (1 + z + z^2/2 + z^3/3 + z^4/4).
$
При $x = 4 times 10^3$, $y = -0.875$, $z = -4.75 times 10^(-4)$ $w = 1.9873$.

5.
$ alpha = ln(y^(-sqrt(abs(x)))) times (x - y/2) + sin^2 ("arctg" z). $
При $x = -15.246$, $y = 4.642 times 10^(-2)$, $z = 2.0001 times 10^3$ $alpha = -182.036$.

6.
$ beta = sqrt(10 (root(3, x) + x^(y + 2))) (arcsin^2 z - abs(x - y)). $
При $x = 1.655 times 10^(-2)$, $y = -2.75$, $z = 0.15$ $beta = -38.902$.

7.
$
  gamma = 5 "arctg" x - 1/4 arccos x times (x + 3 abs(x - y) + x^2)/(z abs(x - y) + x^2).
$
При $x = 0.1722$, $y = 6.33$, $z = 3.25 times 10^(-4)$ $gamma = -172.025$.

8.
$
  phi = (e^(abs(x - y)) times abs(x - y)^(x + y))/("arctg" x + "arctg" z) + root(3, x^6 + ln^2 y).
$
При $x = -2.235 times 10^(-2)$, $y = 2.23$, $z = 15.221$ $phi = 39.374$.

9.
$
  psi = abs(x^(y/x) - root(3, y/x)) + (y - x) (cos y - (z)/(y - x))/(1 + (y - x)^2).
$
При $x = 1.825 times 10^2$, $y = 18.225$, $z = -3.298 times 10^(-2)$ $psi = 1.2131$.

10.
$
  a = 2^(-x) times sqrt(x + root(4, abs(y))) times root(3, e^(x - (1)/(sin z))).
$
При $x = 3.981 times 10^(-2)$, $y = -1.625 times 10^3$, $z = 0.512$ $a = 1.26185$.

11.
$
  b = y^(root(3, abs(x))) + cos^3 y (abs(x - y) (1 + (sin^2 z)/(sqrt(x + y))))/(e^(abs(x - y)) + x/2).
$
При $x = 6.251$, $y = 0.827$, $z = 25.001$ $b = 0.7121$.

12.
$ c = 2^(y^x) + 3^(x^y) - (y ("arctg" z - pi/6))/(abs(x) + (1)/(y^2 + 1)). $
При $x = 3.251$, $y = 0.325$, $z = 4.66 times 10^(-5)$ $c = 4.025$.

13.
$ f = (root(4, y + root(3, x - 1)))/(abs(x - y) (sin^2 z + tg z)). $
При $x = 17.421$, $y = 1.0365 times 10^(-2)$, $z = 8.28 times 10^4$ $f = 0.33056$.

14.
$
  g = (y^(x + 1))/(root(3, abs(y - 2)) + 3) + (x + y/2)/(2 abs(x + y)) (x + 1)^((-1)/(sin z)).
$
При $x = 1.23$, $y = 15.4$, $z = 2.52 times 10^2$ $g = 82.8257$.

15.
$
  h = (x^y + y^z + z^x)/(3 + y/z sin^2 x) times ("arctg" z - (1)/root(3, abs(x + y)))^x
$
При $x = 8.21 times 10^(-2)$, $y = -1.71$, $z = 1.5$ $h = 20.6376$.

#pagebreak()
= Программирование разветвляющихся алгоритмов

*Цель третьей части*

== Логические переменные и операции над ними

Переменные логического типа описываются посредством служебного слова `bool`. Они могут принимать только два значения --- `True` (истина) и `False` (ложь). Результат `True` и `False` возникает при использовании операций сравнения `<` меньше, `>` больше, `!=` не равно, `<=` меньше или равно, `>=` больше или равно, `==` равно. Объявляются логические переменные следующим образом:

```cs
bool b;
```

В языке C\# имеются логические операции, применяемые к переменным логического типа. Это операции логического отрицания (`!`), логическое И (`&&`) и логическое ИЛИ (`||`). Операция логического отрицания является унарной операцией. Результат операции `!` есть `False`, если операнд истинен, и `True`, если операнд имеет значение ложь.\
`! True` $->$ `False`\
`! False` $->$ `True`\
Результат операции логическое И (`&&`) есть истина, только если оба её операнда истинны, и ложь во всех других случаях. Результат операции логическое ИЛИ (`||`) есть истина, если какой-либо из её операндов истинен, и ложен только тогда, когда оба операнда ложны.

== Условные операторы

Операторы ветвления позволяют изменить порядок выполнения операторов в программе. К операторам ветвления относятся условный оператор `if` и оператор выбора `switch`.
Условный оператор `if` используется для разветвления процесса обработки данных на два направления. Он может иметь одну из форм: сокращенную или полную.
Форма сокращенного оператора `if`:

```cs
if (B)
{
    S;
}
```

где `В` --- логическое или арифметическое выражение, истинность которого проверяется; `S` --- оператор: простой или составной.

Также такую конструкцию можно записать в одну строку:

```cs
if (B) S;
```

При выполнении сокращенной формы оператора `if` сначала вычисляется выражение `B`, затем проводится анализ его результата: если `B` истинно, то выполняется оператор `S`; если `B` ложно, то оператор `S` пропускается. Таким образом, с помощью сокращенной формы оператора `if` можно либо выполнить оператор `S`, либо пропустить его.

Форма полного оператора `if`:

```cs
if (B)
{
    S1;
}
else
{
    S2;
}
```

или так же в одну строку:

```cs
if (B) S1; else S2;
```

где `B` --- логическое или арифметическое выражение, истинность которого проверяется; `S1`, `S2` --- оператор: простой или составной.
При выполнении полной формы оператора `if` сначала вычисляется выражение `B`, затем анализируется его результат: если `B` истинно, то выполняется оператор `S1`, а оператор `S2` пропускается; если `B` ложно, то выполняется оператор `S2`, а `S1` пропускается. Таким образом, с помощью полной формы оператора `if` можно выбрать одно из двух альтернативных действий процесса обработки данных.

Пример. Вычислим значение функции

$
  y(x) = cases(
    sin(x)\, x <= a\,,
    cos(x)\, a < x < b\,,
    tg(x)\, x >= b.
  )
$

Указанное выражение может быть запрограммировано в следующем виде:

```cs
if (x<=a) y = Math.Sin(x);
if ((x>a) && (x<b)) y = Math.Cos(x);
if (x>=b) y = Math.Sin(x)/Math.Cos(x);
```

или

```cs
if (x <= a) y = Math.Sin(x);
    else if (x < b) y = Math.Cos(x);
           else y = Math.Sin(x) / Math.Cos(x);
```

Оператор выбора `switch` предназначен для разветвления процесса вычислений по нескольким направлениям. Формат оператора:
```cs
switch (<выражение>)
{
    case <константное_выражение_1>:
        [<оператор 1>]; <оператор перехода>;
    case <константное_выражение_2>:
        [<оператор 2>]; <оператор перехода>;
    ...
    case <константное_выражение_n>:
        [<оператор n>]; <оператор перехода>;
    [default: <оператор>;]
}
```

Замечание. Выражение, записанное в квадратных скобках, является необязательным элементом в операторе `switch`. Если оно отсутствует, то может отсутствовать и оператор перехода.

Выражение, стоящее за ключевым словом `switch`, должно иметь арифметический, символьный, строковый тип или тип указатель. Все константные выражения должны иметь разные значения, но их тип должен совпадать с типом выражения, стоящим после `switch` или приводиться к нему. Ключевое слово case и расположенное после него константное выражение называют также меткой `case`.

Выполнение оператора начинается с вычисления выражения, расположенного за ключевым словом `switch`. Полученный результат сравнивается с меткой `case`. Если результат выражения соответствует метке case, то выполняется оператор, стоящий после этой метки, за которым обязательно должен следовать оператор `break`. При использовании оператора `break` происходит выход из `switch` и управление передается оператору, следующему за `switch`.

Если ни одно выражение `case` не совпадает со значением оператора `switch`, управление передается операторам, следующим за необязательной подписью `default`. Если подписи `default` нет, то управление передается за пределы оператора `switch`.
Пример использования оператора `switch`:
```cs
int caseSwitch = 1;
switch (caseSwitch)
{
    case 1:
        Console.WriteLine("Case 1");
        break;
    case 2:
        Console.WriteLine("Case 2");
        break;
    default:
        Console.WriteLine("Default case");
        break;
}
```

== Кнопки-переключатели RadioButton

При создании программ с графическим интерфейсом в Avalonia для организации разветвлений часто используются компоненты в виде кнопок-переключателей (`RadioButton`).
Состояние такой кнопки (включено/выключено) визуально отображается в интерфейсе: если пользователь выбирает один из вариантов переключателя в группе, все остальные автоматически отключаются.

В Avalonia все `RadioButton`, находящиеся в одном контейнере, образуют группу. Чтобы создать в одном окне несколько независимых групп переключателей, каждую группу размещают в своём отдельном контейнере: `StackPanel`, `Grid`, `Border` и т. д.

В окне (Рис.@img3) элементы `RadioButton` сгруппированы внутри контейнера `Grid`.
Каждый переключатель имеет свойство `IsChecked`, определяющее его текущее состояние.

Номер выбранного варианта (0, 1, 2, ...) передаётся в программу и анализируется при помощи оператора `switch`.

== Пример написания программы

*Задание:* ввести три числа x, y, z. Вычислить величину

$
  U = cases(
    y * f(x)^2 + z\, z - x = 0\,,
    y * e^(f(x)) - z\, z - x < 0\,,
    y * sin(f(x)) + z\, z - x > 0.
  )
$

В качестве функции $f(x)$ используется один из вариантов по выбору пользователя:
$sin(x)$, $cos(x)$, $e^x$.

=== Создание окна

Создайте окно в соответствии с Рис.@img3.

#figure(
  image("./images/img3_1.png", width: 80%),
  caption: [Окно лабораторной работы],
)<img3>

Для первой радиокнопки установите:

```xaml
IsChecked="True"
```

Также разместите на форме элементы `Label`, `TextBox` и `Button`.
Поле для вывода результатов --- это многострочный TextBox с установленным свойством:

```xaml
AcceptsReturn="True"
```

и включённой вертикальной прокруткой:
```xaml
ScrollViewer.VerticalScrollBarVisibility="Visible"
```

Итоговый код файла MainWindow.axaml будет выглядеть следующим образом:
```xaml
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        x:Class="Lab1_3.MainWindow"
        Title="Лабораторная работа № 1.3"
        Width="500" Height="420"
        CanResize="False">

    <Grid Margin="12">
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="Auto"/>
            <ColumnDefinition Width="*"/>
            <ColumnDefinition Width="160"/>
        </Grid.ColumnDefinitions>

        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <!-- Ввод X -->
        <TextBlock Grid.Row="0" Grid.Column="0"
                   VerticalAlignment="Center" Margin="0 4"
                   Text="X =" />
        <TextBox Grid.Row="0" Grid.Column="1"
                 Name="textBox1" Width="120" Margin="4 4"/>

        <!-- Ввод Y -->
        <TextBlock Grid.Row="1" Grid.Column="0"
                   VerticalAlignment="Center" Margin="0 4"
                   Text="Y =" />
        <TextBox Grid.Row="1" Grid.Column="1"
                 Name="textBox2" Width="120" Margin="4 4"/>

        <!-- Ввод Z -->
        <TextBlock Grid.Row="2" Grid.Column="0"
                   VerticalAlignment="Center" Margin="0 4"
                   Text="Z =" />
        <TextBox Grid.Row="2" Grid.Column="1"
                 Name="textBox3" Width="120" Margin="4 4"/>


        <!-- Контейнер с переключателями -->
        <Border Grid.Row="0" Grid.Column="2"
                Grid.RowSpan="3"
                BorderBrush="Gray" BorderThickness="1"
                CornerRadius="6"
                Margin="10 0 0 0" Padding="8">

            <StackPanel>
                <TextBlock Text="F(x)"
                           FontWeight="Bold"
                           Margin="2 0 0 6"/>

                <RadioButton Name="rbSin" Content="sin(x)" IsChecked="True"/>
                <RadioButton Name="rbCos" Content="cos(x)"/>
                <RadioButton Name="rbExp" Content="exp(x)"/>
            </StackPanel>

        </Border>


        <!-- Поле вывода -->
        <TextBox Grid.Row="3" Grid.ColumnSpan="3"
                 Name="textBox4"
                 AcceptsReturn="True"
                 IsReadOnly="True"
                 Margin="0 10 0 10"
                 Height="160"
                 ScrollViewer.VerticalScrollBarVisibility="Visible"/>


        <!-- Кнопки -->
        <StackPanel Grid.Row="5" Grid.ColumnSpan="3"
                    Orientation="Horizontal"
                    HorizontalAlignment="Center"
                    Spacing="20" Margin="0 5 0 0">

            <Button Name="btnRun"
                    Content="ПУСК"
                    Width="120" Height="36"
                    Click="OnRunClick"/>

            <Button Name="btnClear"
                    Content="Очистить"
                    Width="120" Height="36"
                    Click="OnClearClick"/>
        </StackPanel>

    </Grid>
</Window>
```

=== Создание обработчиков событий

Обработчики событий создаются аналогично предыдущим примерам.
Ниже приведён код файла MainWindow.axaml.cs:

```cs
using Avalonia.Controls;
using Avalonia.Interactivity;
using System;

namespace test;

public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
    }

    // Обработка кнопки "ПУСК"
    private void OnRunClick(object? sender, RoutedEventArgs e)
    {
        textBox4.Text = ""; // Очистка перед выводом нового результата

        try
        {
            // Получение исходных данных
            double x = double.Parse(textBox1.Text!);
            double y = double.Parse(textBox2.Text!);
            double z = double.Parse(textBox3.Text!);

            // Вывод исходных данных
            textBox4.Text =
                "Результаты работы программы Петрова И.И." + Environment.NewLine +
                "При X = " + x + Environment.NewLine +
                "При Y = " + y + Environment.NewLine +
                "При Z = " + z + Environment.NewLine;

            // Определение выбранной функции f(x)
            int n = 0;
            if (rbCos.IsChecked == true)
            {
                n = 1;
            }
            else if (rbExp.IsChecked == true)
            {
                n = 2;
            }

            // Выбор функции f(x)
            double fx;

            switch (n)
            {
                case 0:
                    fx = Math.Sin(x);
                    break;

                case 1:
                    fx = Math.Cos(x);
                    break;

                case 2:
                    fx = Math.Exp(x);
                    break;

                default:
                    fx = 0;
                    break;
            }

            // Вычисление U
            double u;
            double diff = z - x;

            if (diff == 0)
            {
                u = y * fx * fx + z;
            }
            else if (diff < 0)
            {
                u = y * Math.Exp(fx) - z;
            }
            else
            {
                u = y * Math.Sin(fx) + z;
            }

            // Вывод результата
            textBox4.Text += "U = " + u.ToString() + Environment.NewLine;
        }
        catch (FormatException)
        {
            textBox4.Text += Environment.NewLine +
                "Ошибка: введены некорректные данные.";
        }
        catch (Exception ex)
        {
            textBox4.Text += Environment.NewLine +
                "Неизвестная ошибка: " + ex.Message;
        }
    }

    // Обработка кнопки "Очистить"
    private void OnClearClick(object? sender, RoutedEventArgs e)
    {
        textBox1.Text = "";
        textBox2.Text = "";
        textBox3.Text = "";
        textBox4.Text = "";
    }
}
```

Запустите программу и убедитесь в том, что все ветви алгоритма выполняются правильно.

== Индивидуальные задания

