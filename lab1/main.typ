#import "conf.typ" : conf
#show: conf.with(
  title: [= Лабораторная работа №1
Визуальное проектирование в С\#],
  type: "pract",
  info: (
      author: (
        name: [],
        faculty: [],
        group: "",
        sex: ""
      ),
      inspector: (
        degree: "",
        name: ""
      )
  ),
  settings: (
    title_page: (
      enabled: true
    ),
    contents_page: (
      enabled: true
    )
  )
)

= Начало работы с Avalonia
== Настройка окна приложения

После создания проекта Avalonia App у вас автоматически появится главное окно --- MainWindow.axaml, а также связанный с ним файл кода MainWindow.axaml.cs.
Файл .axaml содержит описание пользовательского интерфейса в формате XAML, а файл .axaml.cs --- код на C\#, в котором можно обрабатывать события элементов интерфейса.

Изменять свойства окна можно двумя способами:
-	через XAML (описание разметки);
-	через код C\# (в классе MainWindow).

Пример изменения заголовка и размеров окна:
```xaml
<Window xmlns="https://github.com/avaloniaui"
        Title="Лаба №1. ФИО, группа"
        Width="400" Height="300">
</Window>
```

Цвет фона объекта можно задать свойством Background:
```xaml
<Window Background="AntiqueWhite">
```

Также можно задать и цвет текста:
```xaml
<Window Background="AntiqueWhite" Foreground="Blue">
```

== Размещение элементов интерфейса

Элементы управления (кнопки, поля ввода, надписи и т.д.) размещаются внутри контейнеров разметки Avalonia.
Наиболее распространённые контейнеры:
-	StackPanel --- размещает элементы в ряд вертикально или горизонтально;
  Пример:
  ```xaml
  <StackPanel Margin="10">
      <TextBlock Text="Введите значение:"/>

      <TextBox Name="textBox1"/>

      <Button Content="Выполнить" Click="OnButtonClick"/>
  </StackPanel>
  ```
- Grid --- разбивает пространство окна на сетку со строками и столбцами. Элементы можно размещать, указывая, в какой строке и столбце они находятся.
  Пример:
  ```xaml
  <Grid RowDefinitions="Auto,Auto,Auto,Auto" ColumnDefinitions="Auto,*" Margin="10">
      <TextBlock Text="Введите значение:" Grid.Row="0" Grid.Column="0" VerticalAlignment="Center"/>
      <TextBox Name="textBox1" Grid.Row="0" Grid.Column="1"/>
      <Button Content="Выполнить" Click="OnButtonClick"/>
  </Grid>
  ```
  -	RowDefinitions и ColumnDefinitions задают сетку: здесь 4 строки (по высоте --- Auto) и 2 столбца (первый узкий, второй растягивается --- \*);
  -	Grid.Row и Grid.Column указывают позицию элемента в сетке;
  -	Grid.ColumnSpan="2" позволяет занять обе колонки (например, кнопкой).
-	Canvas --- позволяет позиционировать элементы по абсолютным координатам. Каждый элемент имеет свойства Canvas.Left, Canvas.Top, Canvas.Right, Canvas.Bottom.
  Пример:
  ```xaml
  <Canvas>
      <TextBlock Text="Введите значение:" Canvas.Left="10" Canvas.Top="20"/>
      <TextBox Name="textBox1" Width="100" Canvas.Left="150" Canvas.Top="15"/>
      <Button Content="Выполнить" Width="120"
              Canvas.Left="10" Canvas.Top="150"
              Click="OnButtonClick"/>
  </Canvas>
  ```
  -	Используется абсолютное позиционирование --- каждая координата задаётся вручную;
  -	Такой способ удобен для простых макетов, где нужно точно контролировать расположение элементов.	Однако для адаптивных интерфейсов лучше использовать Grid или StackPanel.

== Размещение строки ввода (TextBox)

Для ввода текстовых или числовых данных используется элемент TextBox.

Пример размещения трёх полей ввода:
```xaml
<StackPanel Margin="10">
    <TextBox Name="textBox1"/>
    <TextBox Name="textBox2"/>
    <TextBox Name="textBox3"/>
</StackPanel>
```

Получить введённый текст можно в C\# коде:
```cs
string s = textBox1.Text;
```

Задать шрифт можно в XAML:
```xaml
<TextBox FontSize="16" FontFamily="Arial"/>
```

== Размещение надписей (TextBlock)

В Avalonia вместо Label чаще используется TextBlock --- элемент, который отображает текстовые надписи.
Внимание: не путать TextBlock и TextBox, TextBlock используется для вывода текста, а TextBox --- для ввода.

Пример:
```xaml
<TextBlock Text="Введите значение X:" FontSize="16"/>
```

== События и обработчики

Каждый элемент интерфейса может вызывать события (например, Click у кнопки).
Чтобы обработать событие, в XAML указывается имя метода, а сам метод реализуется в файле .axaml.cs.

=== Обработка события нажатия кнопки (Click)

Пример:
```xaml
<Button Name="button1" Content="Выполнить" Click="OnButtonClick"/>

private void OnButtonClick(object? sender, RoutedEventArgs e)
{
    MessageBox.Avalonia.MessageBoxManager
        .GetMessageBoxStandardWindow("Сообщение", "Привет!")
        .Show();
}
```

=== Обработка события загрузки окна (Opened)

Событие, аналогичное Load в WinForms, --- это Opened в Avalonia.
```xaml
<Window xmlns="https://github.com/avaloniaui"
        Title="..."
        Opened="OnWindowOpened">

private void OnWindowOpened(object? sender, EventArgs e)
{
    this.Background = Brushes.AntiqueWhite;
}
```

== Запуск и работа программы

Программу можно запускать из любой IDE или терминала командой:
  ```sh
dotnet run
```

После успешной сборки появится окно приложения Avalonia.
Для завершения программы просто закройте окно.

== Динамическое изменение свойств

Свойства элементов можно менять в коде во время выполнения:
```cs
textBlock1.Text = "Привет!";
this.Background = Brushes.LightBlue;
```

== Индивидуальные задания
Ниже приведено 14 вариантов задач. 
-	Все элементы интерфейса (кнопки, поля ввода, текстовые надписи и т.п.) размещайте в окне MainWindow.axaml.
-	Если в тексте задания явно не указано иное, то для разметки интерфейса можно использовать любой контейнер: StackPanel, Grid или Canvas.
-	Для визуальных надписей используйте TextBlock, для ввода данных --- TextBox, для интерактивных действий --- Button.
-	Изменение свойств (текста, цвета, видимости и т.д.) выполняйте в коде MainWindow.axaml.cs.
-	События в Avalonia связываются через атрибуты XAML (например Click="OnButtonClick") или через привязку в коде.

1. Разместите в окне четыре кнопки (Button). Сделайте на кнопках следующие надписи: Красный, Зелёный, Синий, Жёлтый. Создайте четыре обработчика события Click, которые будут менять цвет окна (this.Background) в соответствии с текстом на кнопке.
2. Разместите в окне две кнопки (Button) и одну надпись (TextBlock). Сделайте на кнопках надписи: "Привет", "До свидания". Создайте обработчики события Click для этих кнопок, которые будут изменять текст надписи (TextBlock.Text) с одного на другой. Создайте обработчик события загрузки окна (Opened), который установит цвет фона окна и изменит текст надписи на строку "Начало работы".
3. Разместите в окне две кнопки (Button) и одну надпись (TextBlock). Сделайте на кнопках надписи: "Скрыть", "Показать". Создайте обработчики событий Click, которые будут скрывать или показывать надпись (через свойство IsVisible). Создайте обработчик события загрузки окна (Opened), который установит цвет фона окна и изменит текст надписи на строку "Начало работы".
4. Разместите в окне три кнопки (Button) и одно поле ввода (TextBox). Сделайте на кнопках надписи: Скрыть, Показать, Очистить. Создайте обработчики событий Click, которые будут скрывать (IsVisible = true), показывать поле ввода (IsVisible = false) и очищать содержимое поля (Text = "").
5. Разместите в окне две кнопки (Button) и одно поле ввода (TextBox). Сделайте на кнопках надписи: Заполнить, Очистить. Создайте обработчики событий Click, которые будут очищать поле (Text = "") и заполнять его символами "\*\*\*\*\*\*". Создайте обработчик события загрузки окна (Opened), который установит цвет фона окна и задаст текст поля "+++++".
6. Разработайте простую игру. На окне разместите пять кнопок (Button). При нажатии на любую кнопку некоторые кнопки должны становиться видимыми (IsVisible = true), а некоторые --- невидимыми (IsVisible = false). Цель игры --- скрыть все кнопки.
7. Разработайте игру, в которой на окне размещены четыре кнопки (Button) и четыре надписи (TextBlock). При нажатии на любую кнопку часть надписей становится невидимой, а часть --- видимой. Цель игры --- скрыть все надписи.
8. Разместите на окне несколько кнопок (Button). Создайте обработчики событий Click, которые будут делать нажатую кнопку неактивной (IsEnabled = false). Создайте обработчик события изменения размера окна (Resized), который будет устанавливать всем кнопкам состояние активное (IsEnabled = true).
9. Разместите на окне ряд кнопок (Button). Создайте обработчики событий Click, которые будут делать неактивной следующую кнопку. Создайте обработчик события нажатия кнопки мыши на окне (PointerPressed), который будет устанавливать всем кнопкам активное состояние (IsEnabled = true).
10. Разместите на окне три кнопки (Button) и одно поле ввода (TextBox). Сделайте на кнопках надписи: "\*\*\*\*\*", "+++++", "00000". Создайте обработчики событий Click, которые будут выводить текст с кнопки в поле ввода (TextBox.Text = button.Content.ToString()). Создайте обработчик события загрузки окна (Opened), который установит цвет фона окна и задаст текст "Готов к работе" в поле ввода.
11. Разместите на окне несколько полей ввода (TextBox). Создайте обработчики события нажатия кнопки мыши на данные поля ввода (PointerPressed), которые будут выводить в текущее поле его номер. Создайте обработчик события изменения размера окна (Resized), который будет очищать все поля ввода (Text = "").
12. Разместите на окне одно поле ввода (TextBox), одну надпись (TextBlock) и одну кнопку (Button). Создайте обработчик события Click для кнопки, который будет копировать текст из поля ввода в надпись. Создайте обработчик события нажатия кнопки мышки на окне (PointerPressed), который будет устанавливать цвет фона, изменять текст надписи на «Начало работы» и очищать поле ввода.
13. Разместите на окне одно поле ввода (TextBox) и две кнопки (Button) с надписями Блокировать и Разблокировать. Создайте обработчики событий Click, которые будут делать поле ввода активным или неактивным (IsEnabled). Создайте обработчик события нажатия кнопки мышки на окне (PointerPressed), который будет изменять цвет фона и делать все элементы окна невидимыми (IsVisible = false).
14. Разместите на окне четыре кнопки (Button). Создайте для каждой обработчик события Click, который будет изменять размеры (Width, Height) и положение (Canvas.Left, Canvas.Top) других кнопок на окне. Для позиционирования используйте контейнер Canvas.

#pagebreak()
= Программирование линейных алгоритмов

*Цель второй части*

Научиться создавать структуру простейшей программы на языке C\#.
Освоить написание и отладку линейных алгоритмов.

== Структура приложения

В .NET существует два уровня организации:

- Project (Проект) --- основная единица, с которой работает программист. Содержит все исходные материалы для приложения, такие как файлы исходного кода, разметки интерфейса, ресурсы (иконки, изображения, стили), а также данные конфигурации, такие как параметры компилятора.

- Solution (Решение) --- контейнер, который объединяет один или несколько проектов. Один из проектов помечается как стартовый, и именно он запускается при выполнении команды `dotnet run` или при старте отладки.

Проект Avalonia включает следующие основные файлы:
-	.csproj --- файл проекта. Содержит сведения о зависимостях, используемых библиотеках, версии .NET, настройках сборки. Создаётся автоматически и редактируется вручную только при необходимости (например, чтобы добавить пакет через NuGet).
-	Program.cs --- точка входа приложения. Здесь выполняется запуск Avalonia-приложения.
-	App.axaml / App.axaml.cs --- Файлы, содержащие глобальные настройки интерфейса: стили, темы, ресурсы.
-	MainWindow.axaml --- XAML-файл, описывающий внешний вид главного окна. В нём размещаются элементы интерфейса (TextBox, Button, TextBlock и т.д.) и контейнеры (Grid, StackPanel, Canvas и т.д.).
-	MainWindow.axaml.cs --- файл кода, содержащий обработчики событий и программную логику.
-	Assets --- необязательная директория (по умолчанию отсутствует). В ней хранятся изображения, иконки и шрифты, используемые в графическом интерфейсе.

Пример содержимого файла MainWindow.axaml.cs:
```cs
// Раздел подключенных пространств имён
using System;
using Avalonia.Controls;

// Пространство имён нашего проекта
namespace MyFirstApp
{
    // Класс окна
    public partial class MainWindow : Window
    {
        // Методы окна
        public MainWindow()
        {
            InitializeComponent();
        }
    }
}
```

В разделе подключения пространств имён (каждая строка которого располагается в начале файла и начинается ключевым словом `using`) перечислены те подсистемы .NET, которые используются в программе. Каждое пространство имён включает в себя классы, выполняющие определённую работу, например, классы для работы с сетью располагаются в пространстве System.Net, для работы с файлами --- в System.IO, а классы элементов интерфейса Avalonia находятся в пространстве имён Avalonia.Controls.

Для того чтобы не происходило конфликтов имён классов и переменных, классы нашего проекта также помещаются в отдельное пространство имён. Определяется оно ключевым словом namespace, после которого следует имя пространства (обычно оно совпадает с именем проекта).

Внутри пространства имён помещаются наши классы --- в новом проекте это класс окна, который содержит все методы для управления поведением окна. Обратите внимание, что в определении класса присутствует ключевое слово `partial`, это говорит о том, что в нашем программном файле .axaml.cs представлена только часть класса, где содержатся обработчики событий и логика управления элементами, а другая его часть определена в файле разметки .axaml, где описан внешний вид окна.

Наконец, внутри класса располагаются переменные, методы и другие элементы программы. Фактически, основная часть программы размещается внутри класса при создании обработчиков событий.

== Описание данных

Типы данных имеют особенное значение в С\#, поскольку это строго типизированный язык. Это означает, что все операции подвергаются строгому контролю со стороны компилятора на соответствие типов, причем код с недопустимыми операциями не компилируются. Такая строгая проверка типов позволяет предотвратить ошибки и повысить надёжность программ. Для обеспечения контроля типов все переменные, выражения и значения должны принадлежать к определенному типу. Такого понятия, как "бестиповая" переменная, в данном языке программирования вообще не существует. Более того, тип значения определяет те операции, которые разрешается выполнять над ним. Операция, разрешенная для одного типа данных, может оказаться недопустимой для другого.

В С\# имеются две общие категории встроенных типов данных: типы значений и ссылочные типы. Они отличаются по содержимому переменной. Концептуально разница между ними состоит в том, что тип значения (value type) хранит данные непосредственно, в то время как ссылочный тип (reference type) хранит ссылку на значение.

Эти типы сохраняются в разных местах памяти: типы значений сохраняются в области, известной как стек, а ссылочные типы --- в области, называемой управляемой кучей (heap).

#figure(
  image("./images/cs_var_types.png", width: 80%),
  caption: [Схема типов данных в С\#],
)

- Целочисленные типы
В C\# определены девять целочисленных типов: char, byte, sbyte, short, ushort, int, uint, long и ulong. Но тип char в основном применяется для представления символов и поэтому рассматривается отдельно. Остальные восемь целочисленных типов предназначены для числовых расчетов. 

- Типы с плавающей точкой
Типы с плавающей точкой позволяют представлять числа с дробной частью. В C\# имеются две разновидности типов данных с плавающей точкой: float и double. Они представляют числовые значения с одинарной и двойной точностью соответственно.

- Десятичный тип данных
Для представления чисел с плавающей точкой высокой точности предусмотрен также десятичный тип decimal, который предназначен для применения в финансовых вычислениях.

- Символы
В C\# символы представлены не 8-разрядным кодом, как во многих других языках программирования, например С++, а 16-разрядным Unicode. В Unicode набор символов представлен настолько широко, что он охватывает символы практически из всех существующих естественных языков. 

- Логический тип данных
Тип bool представляет два логических значения: "истина" и "ложь". Эти логические значения обозначаются в C\# зарезервированными словами true и false соответственно. Следовательно, переменная или выражение типа bool будет принимать одно из этих логических значений. 

- Строки
Основным типом при работе со строками является тип string, задающий строки переменной длины. Тип string представляет последовательность из нуля или более символов в кодировке Unicode. Класс String в языке C\# относится к ссылочным типам. Над строками --- объектами этого класса --- определен широкий набор операций, соответствующий современному представлению о том, как должен быть устроен строковый тип. По сути, текст хранится в виде последовательной доступной только для чтения коллекции объектов char. 

Рассмотрим самые популярные данные – переменные и константы. Переменная - это ячейка памяти, которой присвоено некоторое имя, и это имя используется для доступа к данным, расположенным в данной ячейке. Для каждой переменной задаётся тип данных --- диапазон всех возможных значений для данной переменной. Объявляются переменные непосредственно в коде программы. 

Примеры объявления переменных:

```cs
int a;     // Только объявление
int b = 7; // Объявление и инициализация значением
```
Для того чтобы присвоить значение символьной переменной, достаточно заключить это значение (т.е. символ) в одинарные кавычки:

```cs
char ch;     // Только объявление
char symbol = 'A'; // Объявление и инициализация значением
```
	
Несмотря на то, что тип char определен в С\# как целочисленный, его не следует путать со всеми остальными целочисленными типами. 
Частным случаем переменных являются константы. Константы - это переменные, значения которых не меняются в процессе выполнения программы. Константы описываются как обычная переменная, только с ключевым словом `const` вначале:

```cs
const int c = 5;
```

== Ввод/вывод данных в программу

Рассмотрим один из способов ввода данных через элементы, размещённые в окне приложения.
В приложениях Avalonia для ввода данных чаще всего используется элемент управления TextBox, обращение к которому осуществляется через его свойство `Text`. Свойство `Text` хранит строку символов, введённую пользователем. Поэтому данные можно получить следующим образом:

```cs
private void OnButtonClick(object? sender, RoutedEventArgs e)
{
    string s = textBox1.Text;
}
```

Однако со строкой символов трудно производить арифметические операции, поэтому лучше всего при вводе числовых данных перевести строку в целое или вещественное число. Для этого в C\# существуют методы `Parse`, определённые для различных типов данных. Например, для преобразования строки в целое число используется метод `int.Parse`, а для вещественного числа --- метод `double.Parse`.

Таким образом, предыдущий пример можно переписать следующим образом:

```cs
private void OnButtonClick(object? sender, RoutedEventArgs e)
{
    string s = textBox1.Text;
    int a = int.Parse(s);
    int b = a * a;
}
```

Перед выводом числовые данные следует преобразовать назад в строку. Для этого у каждой переменной существует метод `ToString`, который возвращает в результате строку с символьным представлением значения. Вывод данных можно осуществлять в элементы TextBox или TextBlock, также используя свойство `Text`. Например: 

```cs
private void OnButtonClick(object? sender, RoutedEventArgs e)
{
    string s = textBox1.Text;
    int a = int.Parse(s);
    int b = a * a;
    textBlock1.Text = b.ToString();
}
```

Обработка исключений --- это описание реакции программы на определённые события (исключения) во время её выполнения. Реакцией программы может быть, например, корректное завершение работы программы, вывод информации об ошибке или запрос повторения действия (при вводе данных). 
Примерами исключений может быть:
- деление на ноль;
- конвертация некорректных данных из одного типа в другой;
- попытка открыть файл, которого не существует;
- доступ к элементу вне рамок массива;
- исчерпывание памяти программы;
- и другое. 

Для обработки исключений в C\# используется оператор try-catch. Он имеет следующую структуру:

```cs
try
{
    // блок кода, в котором может возникнуть исключение
}
catch ([тип исключения] [имя])
{
    // блок обработки исключения
}
```

Работа оператора происходит следующим образом: выполняется код в блоке try, и если в нём возникает исключение указанного в catch типа, управление передаётся в соответствующий блок catch. При этом весь оставшийся код от момента выбрасывания исключения до конца блока try не будет выполнен. После выполнения блока catch, оператор try-catch завершает работу.

Указывать имя исключения не обязательно. Исключение представляет собой объект, и к нему мы имеем доступ через это имя. С этого объекта мы можем получить, например, стандартное сообщение об ошибке (Message), или трассировку стека (StackTrace), которая поможет узнать место возникновения ошибки. В этом объекте хранится детальная информации об исключении.

Если тип выброшенного исключения не будет соответствовать типу, указанному в catch --- исключение не обработается, и программа завершит работу аварийно.
