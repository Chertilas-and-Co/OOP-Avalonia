#import "conf/conf.typ": conf
#import "@preview/fletcher:0.5.8" as fletcher: diagram, edge, node

#show: conf.with(
  title: [= Лабораторная работа №2
    Работа с массивами ],
  type: "pract",
  info: (
    author: (
      name: [],
      faculty: [],
      group: "",
      sex: "",
    ),
    inspector: (
      degree: "",
      name: "",
    ),
  ),
  settings: (
    title_page: (
      enabled: true,
    ),
    contents_page: (
      enabled: true,
    ),
  ),
)

_Массив_ --- набор элементов одного и того же типа, объединенных общим именем.
Массивы в С\# можно использовать по аналогии с тем, как они используются в других языках программирования.
Однако С\#-массивы имеют существенные отличия: они относятся к ссылочным типам данных, более того --- реализованы как объекты. Фактически имя массива является ссылкой на область кучи (динамической памяти), в которой последовательно размещается набор элементов определенного типа.
Выделение памяти под элементы происходит на этапе инициализации массива.
А за освобождением памяти следит система сборки мусора --- неиспользуемые массивы автоматически утилизируются данной системой.

= Массивы и исключения

Выход за границы массива в C\# расценивается как ошибка, в ответ на которую генерируется исключение --- `IndexOutOfRangeException`.

Рассмотрим следующий пример:

Создайте консольное приложение.

```cs
static void Main()
{
  int[] myArray = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
  int i;
  try
  {
    for (i = 0; i <= 10; i++) Console.WriteLine(myArray[i]);
  }
  catch (IndexOutOfRangeException)
  {
    Console.WriteLine("Exception: Выход за границу диапазона");
  }
}
```

= Массив как параметр

Так как имя массива фактически является ссылкой, то он передается в метод по ссылке и, следовательно, все изменения элементов массива, являющегося формальным параметром, отразятся на элементах соответствующего массива, являющимся фактическим параметром.

Рассмотрим пример передачи массива как параметра:

```cs
class Program
{
  static void Print(int n, int[] a) // n – размерность массива, а – ссылка на массив
  {
    for (int i = 0; i < n; i++) {
      Console.Write("{0} ", a[i]);
    } 
    Console.WriteLine();
  }

  static void Change(int n, int[] a)
  {
    for (int i = 0; i < n; i++) 
    {
      if (a[i] > 0) a[i] = 0; // изменяются элементы массива
    }
  }

  static void Main()
  {
    int[] myArray = { 0, -1, -2, 3, 4, 5, -6, -7, 8, -9 };
    Print(10, myArray);
    Change(10, myArray);
    Print(10, myArray);
  }
}
```

#block(
  fill: luma(230),
  inset: 8pt,
  radius: 4pt,
  [*Задание*. Измените программу так, чтобы метод `Change` удваивал
    значения положительных элементов массива.],
)

= Массив как объект

Мы уже говорили о том, что массивы в С\# реализованы как объекты.
Если говорить более точно, то они реализованы на основе базового класса `Array`, определенного в пространстве имен `System`.
Данный класс содержит различные свойства и методы. Например, свойство `Length` позволяет определять количество элементов в массиве.

Преобразуем предыдущий пример:

```cs
class Program
{
  static void Print(int[] a) // передаем только ссылку на массив
  {
    for (int i = 0; i < a.Length; i++)
    {
      Console.Write("{0} ", a[i]);
    }
    Console.WriteLine();
  }

  static void Change(int[] a)
  {
    for (int i = 0; i < a.Length; i++) 
    {
      if (a[i] > 0) 
      {
        a[i] = 0;
      } 
    }
   
  }

  static void Main()
    {
      int[] myArray = { 0, -1, -2, 3, 4, 5, -6, -7, 8, -9 };
      Print(myArray);
      Change(myArray);
      Print(myArray);
    }
}
```

Другие свойства и методы класса `Array` приведены в следующей таблице:


#table(
  columns: (auto, auto, auto),
  align: left,
  table.header([*_Элемент_*], [*_Вид_*], [*_Описание_*]),
  [Length], [свойство], [Количество элементов массива (по всем размерностям)],
  [BinarySearch],
  [статический метод],
  [Двоичный поиск в отсортированном массиве],

  [Clear],
  [статический метод],
  [Присваивание элементам массива значений по умолчанию],

  [Copy],
  [статический метод],
  [Копирование заданного диапазона элементов одного массива в другой],

  [CopyTo],
  [экземплярный метод],
  [Копирование всех элементов текущего одномерного массива в другой массив],

  [GetValue], [экземплярный метод], [Получение значения элемента массива],
  [IndexOf],
  [статический метод],
  [Поиск первого вхождения элемента в одномерный массив],

  [LastIndexOf],
  [статический метод],
  [Поиск последнего вхождения элемента в одномерный массив],

  [Reverse],
  [статический метод],
  [Изменение порядка следования элементов на обратный],

  [SetValue], [экземплярный метод], [Установка значения элемента массива],
  [Sort], [статический метод], [Упорядочивание элементов одномерного массива],
)

Вызов статических методов происходит через обращение к имени класса, например, `Array.Sort(myArray)`.
В данном случае мы обращаемся к статическому методу `Sort` класса `Array` и передаем данному методу в качестве параметра объект `myArray` --- экземпляр класса `Array`.

Обращение к свойству или вызов экземплярного метода производится через обращение к экземпляру класса, например, `myArray.Length` или `myArray.GetValue(i)`.

Пример:

```cs
class Program
{
  static void Main()
  {
    try
    {
      int[] MyArray;
      Console.Write("Введите размерность массива: ");
      int n = int.Parse(Console.ReadLine());
      MyArray = new int[n];
      for (int i = 0; i < MyArray.Length; ++i)
      {
        Console.Write("a[{0}] = ",i);
        MyArray[i] = int.Parse(Console.ReadLine());
      }
      PrintArray("исходный массив:", MyArray);
      Array.Sort(MyArray);
      PrintArray("массив отсортирован по возрастанию", MyArray);
      Array.Reverse(MyArray);
      PrintArray("массив отсортирован по убыванию", MyArray);
    }
    catch (FormatException)
    {
      Console.WriteLine("неверный формат ввода данных");
    }
    catch (OverflowException)
    {
      Console.WriteLine("переполнение");
    }
    catch (OutOfMemoryException)
    {
      Console.WriteLine("недостаточно памяти для создания нового объекта");
    }
  }
  static void PrintArray(string a, int[] mas)
  {
    Console.WriteLine(a);
    for (int i = 0; i < mas.Length; i++)
    {
      Console.Write("{0} ", mas[i]);
    }
    Console.WriteLine();
  }
}
```

#block(
  fill: luma(230),
  inset: 8pt,
  radius: 4pt,
  [*Задание*. Добавьте в программу метод `InputArray`, предназначенный для ввода с клавиатуры элементов массива. Продемонстрируйте работу данного метода.],
)

= Многомерные массивы

Многомерные массивы имеют более одного измерения.
Чаще всего используются двумерные массивы, которые представляют собой таблицы.
Каждый элемент массива имеет два индекса, первый определяет номер строки, второй --- номер столбца, на пересечении которых находится элемент.
Нумерация строк и столбцов начинается с нуля.

Объявить двумерный массив можно одним из предложенных способов:


- `тип [,] имя_массива`;
- `тип [,] имя_массива = new тип [размер1, размер2]`;
- `тип [,] имя_массива = {{элементы 1-ой строки}, ... , {элементы n-ой строки}}`;
- `тип [,] имя_массива = new тип [,]{{элементы 1-ой строки}, ... , {элементы n-ой строки}}`;

Например:

- `int [,] a;`
- `int [,] a = new int [3, 4]`;
- `int [,] a = {{0, 1, 2}, {3, 4, 5}}`;
- `int [,] a = new int [,]{{0, 1, 2}, {3, 4, 5}}`;

== Замечания

+ Как и в случае с одномерными массивами, последние два описания являются избыточными.
+ При работе с многомерными массивами можно использовать приемы, которые мы рассмотрели для одномерных массивов.
+ При обращении к свойству `Length` для двумерного массива мы получим общее количество элементов в массиве. Чтобы получить количество строк нужно обратиться к методу `GetLength` с параметром 0. Чтобы получить количество столбцов --- к методу  `GetLength` с параметром 1.

= Ступенчатые массивы

В ступенчатых массивах количество элементов в разных строках может быть различным.
В памяти ступенчатый массив хранится в виде массива массивов.

Структура ступенчатого массива:

#diagram(
  spacing: (0em, 2em),
  node-fill: rgb(173, 216, 230),
  node-outset: 0.3em,
  node-stroke: 1pt,
  node-shape: rect,
  cell-size: (3em, 1.5em),

  // Массив a
  node((0.125, 0), [$dots$], width: 2em, height: 1.5em),
  node((1, 0), [`a`], width: 5em, height: 1.5em, name: <a>),
  node((1.7, 0), [...], width: 2em, height: 1.5em),

  // Массивы a[0], ..., a[n]
  node((0.125, 1), [$dots$], width: 2em, height: 1.5em),
  node((1, 1), [`a[0]`], width: 5em, height: 1.5em, name: <a_0>),
  node((2, 1), [`a[1]`], width: 5em, height: 1.5em, name: <a_1>),
  node((3, 1), [$dots$], width: 5em, height: 1.5em, name: <a_dots>),
  node((4, 1), [`a[n]`], width: 5em, height: 1.5em, name: <a_n>),
  node((4.7, 1), [$dots$], width: 2em, height: 1.5em),

  // Массив a[n]
  node((1.3, 4), [$dots$], width: 2em, height: 1.5em),
  node((2, 4), [`a[1][0]`], width: 5em, height: 1.5em, name: <a_1_0>),
  node((3, 4), [`a[1][1]`], width: 5em, height: 1.5em),
  node((3.7, 4), [$dots$], width: 2em, height: 1.5em),

  // Какой-то промежуточный массив
  node((0.125, 5), [$dots$], width: 2em, height: 1.5em),
  node((1, 5), [`a[0][0]`], width: 5em, height: 1.5em, name: <a_0_0>),
  node((2, 5), [`a[0][1]`], width: 5em, height: 1.5em),
  node((2.7, 5), [$dots$], width: 2em, height: 1.5em),

  // Массив a[1]
  node((2.3, 3), [$dots$], width: 2em, height: 1.5em),
  node((3, 3), [$dots$], width: 5em, height: 1.5em, name: <a_dots_0>),
  node((4, 3), [$dots$], width: 5em, height: 1.5em),
  node((4.7, 3), [$dots$], width: 2em, height: 1.5em),

  // Массив a[0]
  node((2.3, 3), [$dots$], width: 2em, height: 1.5em),
  node((3.3, 2), [$dots$], width: 2em, height: 1.5em),
  node((4, 2), [`a[n][0]`], width: 5em, height: 1.5em, name: <a_n_0>),
  node((5, 2), [`a[n][1]`], width: 5em, height: 1.5em),
  node((5.875, 2), [$dots$], width: 2em, height: 1.5em),

  edge(<a>, <a_0>, "->"),

  edge(<a_0>, <a_0_0>, "->"),
  edge(<a_1>, <a_1_0>, "->"),
  edge(<a_1>, <a_1_0>, "->"),
  edge(<a_dots>, <a_dots_0>, "->"),
  edge(<a_n>, <a_n_0>, "->"),
)

Объявление ступенчатого массива:

`тип [][] имя_массива;`

Например:

`int [][]a;`

Фактически мы объявили одномерный массив ссылок на целочисленные одномерные массивы.
При таком описании потребуется не только выделять память под одномерный массив ссылок, но и под каждый из целочисленных одномерных массивов.
Такое распределение памяти позволяет определять произвольную длину каждой строки массива (отсюда и произошло название массива --- ступенчатый).
Например:

```cs
int [][] a = new int [3][];	// Создаем три строки
a[0] = new int [2];	// 0-ая строка ссылается на 2-х элементый одномерный массив
a[1] = new int [3];	// 1-ая строка ссылается на 3-х элементый одномерный массив
a[2] = new int [10]; // 2-ая строка ссылается на 10-х элементый одномерный массив
```

Другой способ выделения памяти:

```cs
int [][] a = {new int [2], new int [3], new int [10]};
```

Так как каждая строка ступенчатого массива фактически является одномерным массивом, то с каждой строкой можно работать как с экземпляром класса `Array`.
Это является преимуществом ступенчатых массивов перед двумерными массивами.

Пример:
```cs
class Program
{
  static void Main()
  {
    try
    {
      int[][] MyArray;
      Console.Write("Ввведите количество строк: ");
      int n = int.Parse(Console.ReadLine());
      MyArray = new int[n][];
      for (int i = 0; i < MyArray.Length; i++)
      {
        Console.Write("введите количество элементов в {0} строке: ", i);
        int j = int.Parse(Console.ReadLine());
        MyArray[i] = new int[j];
        for (j = 0; j < MyArray[i].Length; j++)
        {
          Console.Write("a[{0}][{1}] = ", i, j);
          MyArray[i][j] = int.Parse(Console.ReadLine());
        }
      }
      PrintArray("исходный массив:", MyArray);
      for (int i = 0; i < MyArray.Length; i++)
      {
        Array.Sort(MyArray[i]);
      } 
      PrintArray("измененный массив", MyArray);
    }
    catch (FormatException)
    {
      Console.WriteLine("неверный формат ввода данных");
    }
    catch (OverflowException)
    {
      Console.WriteLine("переполнение");
    }
    catch (OutOfMemoryException)
    {
      Console.WriteLine("недостаточно памяти для создания нового объекта");
    }
  }

  static void PrintArray(string a, int[][] mas)
  {
      Console.WriteLine(a);
      for (int i = 0; i < mas.Length; i++)
      {
         for (int j = 0; j < mas[i].Length; j++) 
         {
           Console.Write("{0} ", mas[i][j]);
         }
         Console.WriteLine();
      }
  }
}
```

#block(
  fill: luma(230),
  inset: 8pt,
  radius: 4pt,
  [*Задание.* Добавьте в программу метод `MakeArray`, предназначенный для создания ступенчатого массива, в котором количество элементов в каждой строке больше номера строки в два раза. А сам элемент равен сумме номеров строки и столбца, в котором он находится.  Продемонстрируйте работу данного метода.],
)

= Оператор `foreach` и его использование при работе с массивами

Оператор `foreach` применяется для перебора элементов в специальным образом организованной группе данных, в том числе и в массиве.
Удобство этого вида цикла заключается в том, что нам не требуется определять количество элементов в группе и выполнять перебор по индексу --- мы просто указываем на необходимость перебрать все элементы группы.
Синтаксис оператора:

`foreach (<тип> <имя> in <группа>) <тело цикла>`,

где _имя_ определяет локальную по отношению к циклу переменную, которая будет по очереди принимать все значения из указанной _группы_, а _тип_ соответствует базовому типу элементов _группы_.

Ограничением оператора `foreach` является то, что с его помощью можно только просматривать значения элементов в группе данных, но нельзя их изменять.

Рассмотрим несколько примеров использования оператора `foreach`:

1. для работы с одномерными массивами:

```cs
static void PrintArray(string a, int [] mas)
{
  Console.WriteLine(a);
  foreach (int x in mas)
  {
    Console.Write("{0} ", x);
  } 
  Console.WriteLine();
}
```

2. для работы с двумерными массивами:

```cs
static int Sum(int [,] mas)
{
  int s = 0;
  foreach (int x in mas)
  {
    s += x;
  } 
  return s;
}
```

3. для работы со ступенчатыми массивами:

```cs
static void PrintArray3(string a, int[][] mas)
{
  Console.WriteLine(a);
  for (int i = 0; i < mas.Length; i++)
  {
    foreach (int x in mas[i]) {
      Console.Write("{0} ", x);
    } 
    Console.WriteLine();
  }
}
```

= Выполнение индивидуального задания

_Выполните задание в консольном приложении_

*Дан массив размером $n times n$, элементы котрого целые числа.*

*Замечание.* Для хранения массива $n times n$ использовать ступенчатый массив.

Пример:

Найти максимальный элемент в каждой строке и записать данные в новый массив.

```cs
using System;
namespace ConsoleApplication
{
  class Class
  {
    static int[][] Input ()
    {
       Console.WriteLine("введите размерность массива");
       Console.Write("n = ");
       int n = int.Parse(Console.ReadLine());
       int [][]a = new int[n][];
       for (int i = 0; i < n; ++i)
       {
          a[i] = new int [n];
          for (int j = 0; j < n; ++j)
          {
             Console.Write("a[{0},{1}] = ", i, j);
             a[i][j] = int.Parse(Console.ReadLine());
          }
       }
       return a;
    }

    static void Print1(int[] a)
    {
       for (int i = 0; i < a.Length; ++i)
       {
         Console.Write("{0,5} ", a[i]);
       }
    }

    static void Print2(int[][] a)
    {
       for (int i = 0; i < a.Length; ++i, Console.WriteLine()) 
       {
          for (int j = 0; j < a[i].Length; ++j) 
          {
            Console.Write("{0,5} ", a[i][j]);
          }
       }
    }

    static int Max(int[] a)
    {
       int max = a[0];
       for (int i = 1; i < a.Length; ++i) 
       {
          if (a[i] > max) 
          {
            max = a[i];
          }
       }
       return max;
    }

    static void Main()
    {
       int[][] myArray = Input();
       Console.WriteLine("Исходный массив:");
       Print2(myArray);
       int[]rez = new int [myArray.Length];
       for (int i = 0; i < myArray.Length; ++i) 
       {
          rez[i] = Max(myArray[i]);
       }
       Console.WriteLine("Новый массив:");
       Print1(rez);
    }
  }
}
```


+ Найти минимальный элемент в каждом столбце и записать данные в новый массив.
+ Четные столбцы таблицы заменить на вектор `Х`.
+ Нечетные строки таблицы заменить на вектор `Х`.
+ Вычислить $А*Х$, где А --- двумерная матрица, `X` ---  вектор.
+ Для каждой строки подсчитать количество положительных элементов и записать данные в новый массив.
+ Для каждого столбца подсчитать сумму отрицательных элементов и записать данные в новый массив.
+ Для каждого столбца подсчитать сумму четных положительных элементов и записать данные в новый массив.
+ Для каждой строки подсчитать количество элементов, больших заданного числа, и записать данные в новый массив.
+ Для каждого столбца найти первый положительный элемент и записать данные в новый массив.
+ Для каждой строки найти последний четный элемент и записать данные в новый массив.
+ Для каждого столбца найти номер последнего нечетного элемента и записать данные в новый массив.
+ Для каждой строки найти номер первого отрицательного элемента и записать данные в новый массив.
