#import "conf/conf.typ": conf

#show: conf.with(
  title: [= Лабораторная работа №4
  Классы и объекты],
  type: "pract",
  info: (
    author: (
      name: [],
      faculty: [],
      group: "",
      sex: "",
    ),
    inspector: (
      degree: "",
      name: "",
    ),
  ),
  settings: (
    title_page: (
      enabled: true,
    ),
    contents_page: (
      enabled: true,
    ),
  ),
)

= Часть 1. Индексаторы

*Цель работы:*
познакомиться с основой объектного подхода в языке C\#, с использованием индексаторов.

== Теория

Индексатор представляет собой разновидность свойства. 
Если у класса есть скрытое поле, представляющее собой массив, то с помощью индексатора можно обратиться к элементу этого массива, используя имя объекта и номер элемента массива в квадратных скобках.

Синтаксис индексатора аналогичен синтаксису свойства:

`<уровень доступа> <тип>this [список_параметров] { get { код_доступа} set { код_доступа} }`

Индексаторы чаще всего объявляются спецификатором `public`, поскольку они входят в интерфейс объекта.

Код доступа представляет собой блоки операторов, которые выполняются при получении (`get`) или установке значения (`set`) элемента массива. 
Может отсутствовать либо часть `get`, либо `set`, но не обе одновременно.
Если отсутствует часть `set`, индексатор доступен только для чтения (read-only), если отсутствует часть `get`, индексатор доступен только для записи (write-only).

Синтаксически чтение и запись индексатора выглядят почти как методы. 
Метод `get` должен содержать оператор `return`, возвращающий выражение, для типа которого должно существовать неявное преобразование к типу свойства. 
В методе `set` используется параметр со стандартным именем `value`, который содержит устанавливаемое значение.

Список параметров содержит одно или несколько описаний индексов, по которым выполняется доступ к элементу.
Чаще всего используется один индекс целого типа.
Однако, C\# не ограничивает тип индексатора типом `int`.
Например, может оказаться полезным использование в индексаторе строки.
Такой индексатор можно реализовать, выполнив поиск строки в коллекции и возвратив соответствующее значение. 
Методы доступа можно перегружать, версии типа `string` и `int` могут сосуществовать.

Индексаторы могут иметь более одного формального параметра, например, при доступе к двухмерному массиву.

=== Пример. Работа с индексатором

*Задание.*
Создайте объект класса `Rectangle`: "Большой прямоугольник" со сторонами 5 и 10; объявите поле "Имя" данного класса, а также поле "Размеры сторон", содержащее информацию о размерах всех сторонах прямоугольника. 
Организуйте доступ к полю "Имя" посредством свойства, а к полю "Размеры сторон" посредством индексатора.

*Решение*.

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MyConsoleApplication
{
  // Объявление класса
  public class Rectangle
  {
    // Члены класса:
    // Поля.
    private string Name;

    // Объявляем массив с двумя элементами
    private int[] Side = new int[2];  

    // Индексатор с целочисленным параметром (индексом)
    public int this[int index]
    {
      get {
        return Side[index];
      }
      set {
        Side[index] = value;
      }
    }

     // Конструктор с аргументами
    public Rectangle(string name, int SideA, int SideB) 
    {
      Side[0] = SideA;
      Side[1] = SideB;
      Name = name;
    }
    
    // Свойства
    // Только для чтения
    public int Perimeter 
    {
      get {return (Side[0] + Side[1]) * 2; }
    }

    // Для чтения и для записи
    public string Name
    {
      set
      { 
        Name = value;
      }
      get
      { 
        return Name; 
      }
    }
  
  }

  class Program 
  {
    static void Main(string[] args) 
    {     
      // Создание объекта на основе класса Rectangle (Большой прямоугольник со сторонами 5 и 10)
      Rectangle myRectangle = new Rectangle("Большой прямоугольник", 5, 10);

      // Выведем свойства фигуры и её имя
      Console.WriteLine(myRectangle.Name);

      // Длины сторон (до изменения)
      Console.WriteLine(myRectangle[0]);
      Console.WriteLine(myRectangle[1]);
      Console.ReadKey();
      
      // Изменим длины сторон прямоугольника
      myRectangle[0] = 10;
      myRectangle[1] = 20;

      // Выведем свойства фигуры
      // Длины сторон (после изменения)
      Console.WriteLine(myRectangle[0]);
      Console.WriteLine(myRectangle[1]);
      Console.ReadKey();

      // Значение периметра
      Console.WriteLine(myRectangle.Perimeter);
      Console.ReadKey();
    }
  }
}
```

Индексаторы очень удобно применять для создания специализированных массивов, на работу с которыми накладываются какие-либо ограничения.
Кроме того, при доступе к элементу проверяется, не вышел ли индекс за допустимые границы.

=== Пример

Класс Треугольник. Поля --- длины сторон (целые числа).

```cs
// Индексатор, при значении 0 вернём длину стороны а, при 1 - стороны b, при 3 - стороны с
public string this[string i] 
{
  get 
  {
    // switch - позволяет выбирать продолжение алгоритма из нескольких разделов, в скобках указывается условие выбора 
    switch (i)
    {
      // case - ключевое слово, после которого указывается какое либо значение условия выбора при switch
      case "0": return Convert.ToString(this.a); 
      case "1": return Convert.ToString(this.b);
      case "2": return Convert.ToString(this.c);

      // Дефолтное продолжение алгоритма (если не подошло ни к одному из значений case) 
      // В нашем случае генерируется исключение (throw new Exception)
      default: throw new Exception("i не принадлежит 0, 1 или 2"); 
    }
  }
}
```

=== Пример

Предположим, есть некий магазин, занимающийся реализацией ноутбуков.
Эта ситуация отображается при помощи двух классов: класса `Shop`, изображающего магазин, и класса `Laptop`, изображающего его продукцию. 
Дабы не перегружать пример лишней информацией, снабдим класс `Laptop` только двумя полями: `vendor` --- для отображения имени фирмы-производителя, а также `price` --- для отображения цены ноутбука. 
Класс будет включать соответствующие открытые свойства `Vendor` и `Price`, конструктор с двумя параметрами, а также переопределённый метод `ToString()` для отображения информации по конкретной единице товара.
В качестве единственного поля класса `Shop` выступает ссылка на массив объектов `Laptop`.
В конструкторе с одним параметром задаётся количество элементов массива и выделяется память для их хранения. 
Далее нам нужно сделать возможным обращение к элементам этого массива через экземпляр класса `Shop`, пользуясь синтаксисом массива так, словно класс `Shop` и есть массив элементов типа `Laptop`. 
Для этого добавим в класс `Shop` индексатор:

```cs
public Laptop this[int pos] 
{
  get 
  {
    if (pos >= LaptopArr.Length ||  pos < 0) 
    {
      throw new IndexOutOfRangeException();
    } 
    else 
    {
      return (Laptop)LaptopArr[pos];
    }

  set 
  { 
    LaptopArr[pos] = (Laptop)value; 
  }
}
```

Здесь в аксессоре `get` мы предусматриваем выход за пределы массива, и при этом генерируется исключение `IndexOutOfRangeException`.

Для проверки работы классов создаётся отдельный класс `Tester`, содержащий точку входа.
В нём создаётся экземпляр класса `Shop`, причём в конструкторе задается количество элементов, которые в нём можно разместить.

```cs
Shop sh = new Shop(3);
```
Далее мы заполняем этот массив объектами `Laptop`.

```
sh[0] = new Laptop("Samsung", 5200);
sh[1] = new Laptop("Asus", 4700); 
sh[2] = new Laptop("LG", 4300);
```

И, наконец, вывод на экран данных по каждому объекту `Laptop`, пользуясь синтаксисом массива.

```cs
for (int i = 0; i < 3; i++) 
{
  Console.WriteLine(sh[i].ToString());
}
```

В цикле ограничивающим значением в условии является явно заданное число 3.
Дело в том, что индексатор позволяет нам пользоваться лишь синтаксисом индексирования массива, но других функциональных возможностей массива не предоставляет.
Если это был бы стандартный массив, то это условие описывается иначе:

```cs
for (int i = 0; i < sh.Length; i++)
{
  ...
}
```

Для того, чтобы подобная функциональная возможность появилась и в примере, необходимо добавить в класс `Shop` дополнительное свойство `Length`.

```cs
public int Length
{
  get
  { 
    return LaptopArr.Length; 
  }
}
```

Общий вид программы:

```cs
namespace MyConsoleApplication 
{
  public class Laptop 
  {
    private string vendor;
    private double price;

    public string Vendor 
    {
      get
      { 
        return vendor; 
      }
      set 
      {
        vendor = value;
      }
    }

    public double Price 
    {
      get 
      { 
        return price;
      }
      set
      { 
        price = value; 
      }
    }

    public Laptop(string v, double p) 
    {
      vendor = v; price = p;
    }

    public override string ToString() 
    {
      return vendor + " " + price.ToString();
    }
  }

  public class Shop 
  {
    private Laptop[] LaptopArr;
    public Shop(int size) 
    {
      LaptopArr = new Laptop[size];
    }

    public int Length 
    {
      get
      { 
        return LaptopArr.Length; 
      }
    }

    public Laptop this[int pos] 
    {
      get 
      {
        if (pos >= LaptopArr.Length || pos < 0)
        {
          throw new IndexOutOfRangeException();
        }
        else 
        {
            return (Laptop)LaptopArr[pos];
        }
      }
      set
      {
          LaptopArr[pos] = (Laptop)value;
      }
    }
  }

  public class Program 
  {
    public static void Main()
    {
      Shop sh = new Shop(3);
      sh[0] = new Laptop("Samsung", 5200);
      sh[1] = new Laptop("Asus", 4700);
      sh[2] = new Laptop("LG", 4300);

      try 
      {
        for (int i = 0; i < sh.Length; i++) 
        {
          Console.WriteLine(sh[i].ToString());
        }
        Console.WriteLine();
      }

      catch (System.NullReferenceException) {}
    }
  }
}
```

#figure(
  image(
    "lab4_imports/images/example.png",
    width: 80%,
  ),
  caption: [Результат выполнения программы],
)

== Создание многомерныx индексаторов

В C\# есть возможность создавать не только одномерные, но и многомерные индексаторы.
Это возможно, если класс-контейнер содержит в качестве поля массив с более чем одним измерением.

=== Пример использования многомерного индексатора

```cs
namespace MyConsoleApplication 
{
  public class A
  {
    private int[,] arr;

    private int rows, cols;
    public int Rows 
    {
      get 
      { 
        return rows; 
      }
    }
    public int Cols 
    {
      get
      {
        return cols; 
      }
    }

    public A(int rows, int cols)
    {
      this.rows = rows; this.cols = cols;
      arr = new int[rows, cols];
    }

    public int this[int r, int c]
    {
      get 
      {
        return arr[r, c]; 
      }
      set 
      {
        arr[r, c] = value; 
      }
    }
  }

  public class Program 
  {
    static void Main()
    {
      A obj = new A(2, 3);

      for (int i = 0; i < obj.Rows; i++)
      {
        for (int j = 0; j < obj.Cols; j++)
        {
          obj[i, j] = i + j;
          Console.Write(obj[i, j].ToString());
        }
        Console.WriteLine();
      }
    }
  }
}
```

== Задание для самостоятельной работы

1.	Используя решение задания, приведенного в лабораторной работе №3, дополните класс индексатором (одномерным, двумерным, строковым). 
2.	Создайте несколько экземпляров класса и продемонстрируйте работу индексатора.

== Контрольные вопросы

1. В каких случаях применение индексатора является целесообразным?
2. Каким образом осуществляется чтение и запись индексатора?

= Часть 2. Перегрузка операторов

*Цель работы:* 
ознакомиться с понятием перегрузки операторов в языке C\#.

== Введение в перегрузку операторов

Перегрузка операторов позволяет указать, как стандартные операторы будут использоваться с объектами класса. 

Требования к перегрузке операторов:
- перегрузка операторов должна выполняться открытыми статическими методами класса (спецификаторы `public static`);
- у метода-оператора тип возвращаемого значения или одного из параметров должен совпадать с типом, в котором выполняется перегрузка оператора;
- параметры метода-оператора не должны включать модификатор `out` и `ref`.

Невозможно изменить значение стандартных операций для стандартных типов данных.
#figure(
  caption: [Операторы, допускающие перегрузку.],
  table(
    columns: (auto, auto),
    align: left,
    table.header(
      [*Операторы*], [*Категория операторов*]
    ),

    [`-`], 	                            [Изменение знака переменной],
    [`!`],                             	[Операция логического отрицания],
    [`~`],                              [Операция побитового дополнения, которая приводит к инверсии каждого бита],
    [`++`, `--`],                       [Инкремент и декремент],
    [`true`, `false`],	                [Критерий истинности объекта, определяется разработчиком класса],
    [`+`, `–`, `*`, `/`, `%`],        	[Арифметические операторы],
    [`&`, `|`, `^`, `<<`, `>>`],       	[Битовые операции],
    [`==`, `!=`, `<`, `>`, `<=`, `>=`],	[Операторы сравнения],
    [`&&`, `||`],	                    [Логические операторы],
    [`[]`],                             [Операции доступа к элементам массивов моделируются за счет индексаторов],
    [`()`],                            	[Операции преобразования],
    )
) <table1>

#figure(
  caption: [Операторы, не допускающие перегрузку.],
  table(
    columns: (auto, auto),
    align: left,
    table.header(
      [*Операторы*], [*Категория операторов*]),
      [`+=`, `–=`, `*=`, `/=`, `%=`,
      `&=`, `|=`, `^=`, `<<=`, `>>=`],	[Перегружаются автоматически при перегрузке соответствующих бинарных операций],
      [`=`],	                        [Присвоение],
      [`.`],                        	[Доступ к членам типа],
      [`?:`],                         	[Оператора условия],
      [`new`],	                        [Создание объекта],
      [`as`, `is`, `typeof`],       	[Используются для получения информации о типе],
      [`–>`, `sizeof`, `*`, `&`],   	[Доступны только в небезопасном коде]
    ),
) <table2>


Перегрузка операторов имеет некоторые ограничения:
- перегрузка не может изменить приоритет операторов;
- при перегрузке невозможно изменить число операндов, с которыми работает оператор;
- не все операторы можно перегружать (см. таблицы @table1 и @table2).

Перегрузку операторов можно использовать как в классах, так и в структурах.

Поскольку перегруженные операторы являются статическими методами, они не получают указателя `this`, поэтому унарные операторы должны получать один параметр, бинарные два.

Синтаксис перегрузки:

`public static <тип результата> operator <символ операции> (параметры)`

== Перегрузка унарных операторов

Можно определять в классе следующие унарные операции:
`+`, `-`, `!`, `~`, `++`, `--`, `true`, `false`.

Синтаксис объявления унарной операции:

`тип operator унарная_операция ( параметр )`

Примеры заголовков унарных операций:

```cs
public static int operator +(MyObject m)
public static MyObject operator --(MyObject m) 
public static bool operator true(MyObject m)
```

Параметр, передаваемый в операцию, должен иметь тип класса, для которого она определяется. 
Операция должна возвращать:
- для операций `+`, `-`, `!` величину любого типа;
- для операций `++` и `--` величину типа класса, для которого она определяется;
- для операций `true` и `false` величину типа `bool`.

Операции не должны изменять значение передаваемого им операнда. 
Операция, возвращающая величину типа класса, для которого она определяется, должна создать новый объект этого класса, выполнить с ним необходимые действия и передать его в качестве результата.

=== Пример операторов инкремента, декремента и изменения знака

Класс `Point` описывает точку на плоскости, точка имеет координаты `x` и `y`.
Оператор `++` увеличивает обе координаты на 1, оператор `--` уменьшает, оператор `–` изменяет знак координат на противоположный.

```cs
namespace UnaryOperator 
{
  // Класс точки на плоскости - пример для перегрузки операторов 
  class Point
  {
    int x, y;
    public Point(int x, int y)
    { 
      this.x = x; 
      this.y = y; 
    }

    // Перегрузка инкремента
    public static Point operator ++(Point s)
    { 
      s.x++;
      s.y++; 
      return s; 
    }

    // Перегрузка декремента
    public static Point operator --(Point s) 
    { 
      s.x--;
      s.y--; 
      return s;
    }

    // Перегрузка оператора -
    public static Point operator -(Point s)
    {
      Point p = new Point(s.x, s.y);
      p.x = -p.x; 
      p.y = -p.y; 
      return p;
    }

    public override string ToString() 
    {
      return string.Format("X = {0}, Y = {1}", x, y); 
    }
  }

  class Program
  {
    static void Main()
    {
      Point p = new Point(10, 10);

      // Префиксная и постфиксная формы выполняются одинаково
      Console.WriteLine(++p); // x = 11, y = 11

      Point p1 = new Point(10, 10);
      Console.WriteLine(p1++); // x = 11, y=11

      Console.WriteLine(--p); // x = 10, y = 10 
      Console.WriteLine(-p);  // x = -10, y = -10
                              // После выполнения оператора
                              // состояние исходного объекта не изменилось 
      Console.WriteLine(p);   // x = 10, y = 10
    }
  }
}
```

#figure(
  image(
    "lab4_imports/images/example2.png",
    width: 80%,
  ),
  caption: [Результат выполнения программы],
)

В данном примере `Point` является ссылочным типом, поэтому изменения значений `x` и `y`, которые выполняются в перегруженных операторах инкремента и декремента, затрагивают переданный в них объект. 
Оператор `-` (изменение знака) не должен изменять состояние переданного объекта, а должен возвращать новый объект с измененным знаком. 
Для этого в реализации этого метода создается новый объект `Point`, изменяется знак его координат и этот объект возвращается из метода.

В C\# нет возможности выполнить отдельно перегрузку постфиксной и префиксной форм операторов инкремента и декремента.
Поэтому при вызове постфиксная и префиксная форма работают одинаково.

При перегрузке операторов `true` и `false` разработчик задает критерий истинности для своего типа данных. 
После этого объекты типа напрямую можно использовать в структуре операторов `if`, `do`, `while`, `for` в качестве условных выражений.

== Перегрузка бинарных операторов

Можно определять в классе следующие бинарные операции:
`+`, `-`, `*`, `/`, `%`, `&`, `<<`, `>>`, `==`, `!=`, `>`, `<`, `>=`, `<=`.

Синтаксис объявителя бинарной операции:

`тип operator бинарная_операция (параметр1, параметр2)`

Примеры заголовков бинарных операций:

```cs 
static MyObject operator +(MyObject ml, MyObject m2) 
static bool operator ==(MyObject ml, MyObject m2)
```

Хотя бы один параметр, передаваемый в операцию, должен иметь тип класса, для которого она определяется.
Операция может возвращать величину любого типа.

Операции `==` и `!=`, `>` и `<`, `>=` и `<=` определяются только парами и обычно возвращают логическое значение. 
Чаще всего в классе определяют операции сравнения на равенство и неравенство для того, чтобы обеспечить сравнение объектов, а не их ссылок, как определено по умолчанию для ссылочных типов.

=== Пример перегрузки бинарных операций

```cs
namespace BinaryOperator 
{
  class Vector
  {
    public int x; 
    public int y;

    public Vector(int x, int y)
    {
      this.x = x;
      this.y = y; 
    }

    public override string ToString() 
    {
      return string.Format("Vector: X = {0}, Y = {1}", x, y); 
    }

  class Point
  {
    private int x;
    private int y;

    public Point(int x, int y)
    { 
      this.x = x; 
      this.y = y; 
    }

    // Перегрузка бинарного оператора +
    public static Point operator +(Point p, Vector v) 
    { 
      return new Point(p.x + v.x, p.y + v.y);
    }

    // Перегрузка бинарного оператора *
    public static Point operator *(Point p, int a)
    { 
      return new Point(p.x * a, p.y * a); 
    }

    // Перегрузка бинарного оператора -
    public static Vector operator -(Point p1, Point p2) 
    {
      return new Vector(p1.x - p2.x, p1.y - p2.y); 
    }

    public override string ToString()
    {
      return string.Format("Point: X = {0}, Y = {1}", x, y); 
    }
  }

  class Program
  {
    static void Main() 
    {
      Point p1 = new Point(10, 10);
      Point p2 = new Point(12, 20);

      Vector v = new Vector(10, 20);

      Console.WriteLine("Точка p1: {0}", p1);
      Console.WriteLine("Сдвиг: {0}", p1 + v);
      Console.WriteLine("Масштабирование: {0}", p1 * 10);
      Console.WriteLine("Точка p2: {0}", p2);
      Console.WriteLine("Расстояние: {0}", p2 - p1);

      Console.ReadKey();
    }
  }
}
```

#figure(
  image(
    "lab4_imports/images/example3.png",
    width: 80%,
  ),
  caption: [Результат выполнения программы],
)

Выполненная перегрузка автоматически перегружает операторы `+=`, `*=`, `-=`.
Например, можно записать: 

`p1 += v;`

Для реализации этого действия будет использован перегруженный оператор `+`.

Однако перегруженные в примере операторы будут использоваться компилятором только если переменная типа `Point` находится слева от знака операнда.
Т.е. выражение `p * 10` скомпилируется нормально, а при перестановке сомножителей, т.е. в выражении `10 * p` произойдет ошибка компиляции.
Для исправления этой ошибки следует перегрузить оператор `*` с другим порядком операндов:

```cs
public static Point operator *(int a, Point p)
{
  return p * a; 
}
```

При перегрузке операторов отношения надо учитывать, что есть два способа проверки равенства:
- равенство ссылок (тождество);
- равенство значений.

В классе `Object` определены следующие методы сравнения объектов: 

```cs
public static bool ReferenceEquals(Object obj1, Object obj2)
public bool virtual Equals(Object obj)
```

Есть отличия в работе этих методов со значимыми и ссылочными типами.

Метод `ReferenceEquals()` проверяет, указывают ли две ссылки на один и тот же экземпляр класса; точнее --- содержат ли две ссылки один и тот адрес памяти.
Этот метод невозможно переопределить. Со значимыми типами `ReferenceEquals()` всегда возвращает `false`, т.к. при сравнении выполняется приведение к `Object` и упаковка, упакованные объекты располагаются по разным адресам.

Метод `Equals()` является виртуальным. 
Его реализация в `Object` выполняется проверку равенства ссылок, т.е. работает так же как и `ReferenceEquals`.
Для значимых типов в базовом типе `System.ValueType` выполнена перегрузка метода `Equals()`, которая выполняет сравнение объектов путем сравнения всех полей (побитовое сравнение).

=== Пример использования операторов `ReferenceEquals()` и `Equals()` со ссылочными и значимыми типами:

```cs
namespace Equals_and_ReferenceEquals
{
  class CPoint 
  {
    private int x, y;
    public CPoint(int x, int y) 
    {
      this.x = x; 
      this.y = y; 
    }
  }

  struct SPoint 
  {
    private int x, y;
    public SPoint(int x, int y) 
    {
      this.x = x; 
      this.y = y;
    }
  }

  class Program
  {
    static void Main() 
    {
      // Работа метода ReferenceEquals с ссылочным и значимым типами

      // Ссылочный тип
      CPoint p = new CPoint(0, 0);
      CPoint p1 = new CPoint(0, 0);
      CPoint p2 = p1;
      Console.WriteLine("ReferenceEquals(p, p1) = {0}", ReferenceEquals(p, p1)); // false
      // Хотя p и p1 содержат одинаковые значения,
      // они указывают на разные адреса памяти 

      Console.WriteLine("ReferenceEquals(p1, p2) = {0}", ReferenceEquals(p1, p2)); // true
      // p1 и p2 указывают на один и тот же адрес памяти

      // Значимый тип
      SPoint p3 = new SPoint(0, 0);
      Console.WriteLine("ReferenceEquals(p3, p3) = {0}", ReferenceEquals(p3, p3)); // false
      // при передаче в метод ReferenceEquals выполняется упаковка,
      // упакованные объекты располагаются по разным адресам 

      // Работа метода Equals с ссылочным и значимым типами

      // Ссылочный тип
      CPoint cp = new CPoint(0, 0); CPoint cp1 = new CPoint(0, 0);
      Console.WriteLine("Equals(cp, cp1) = {0}", Equals(cp, cp1)); // false
      // Выполняется сравнение адресов

      // Значимый тип 
      SPoint sp = new SPoint(0, 0);
      SPoint sp1 = new SPoint(0, 0);
      Console.WriteLine("Equals(sp, sp1) = {0}", Equals(sp, sp1)); // true
      // Выполняется сравнение значений полей
    }
  }
}
```

#figure(
  image(
    "lab4_imports/images/example4.png",
    width: 80%,
  ),
  caption: [Результат выполнения программы],
)

При создании собственного типа оператор `Equals()` можно перегрузить.
Для ссылочных типов перегрузку следует выполнять, только если тип представляет собой неизменяемый объект. Например, для типа `String`, который содержит в себе неизменную строку, имеется перегруженный метод `Equals()` и оператор `==`.

Поскольку в `System.ValueType` перегруженный метод `Equals()` выполняет побитовое сравнение, то в собственных значимых типах его можно не перегружать. 
Однако, в `System.ValueType` получение значений полей для сравнения в методе `Equals()` выполняется с помощью рефлексии, что приводит к снижению производительности. 
Поэтому при разработке значимого типа для увеличения быстродействия рекомендуется выполнить перегрузку метода `Equals()`.

При перегрузке метода `Equals()` следует также перегружать метод `GetHashCode()`.
Этот метод предназначен для получения целочисленного значения хеш-кода объекта. 
Причем, различным (т.е. не равным между собой) объектам должны соответствовать различные хеш-коды.
Если перегрузку метода `GetHashCode()` не выполнить возникнет предупреждение компилятора.

Перегрузка оператора `==` обычно выполняется путем вызова метода `Equals()`.

Если предполагается сравнивать экземпляры собственного типа для целей сортировки, рекомендуется унаследовать этот тип от интерфейсов `System.IComparable` и `System.IComparable<T>` и реализовать метод `CompareTo()`.
В дальнейшем этот метод можно вызывать из реализации `Equals()` и возвращать `true`, если `CompareTo()` возвращает 0.

=== Пример перегрузки операторов `==` и `!=` для класса `Point` 

```cs 
namespace ComparisonOperator 
{
  class Point
  {
    int x, y;

    public Point(int x, int y)
    { 
      this.x = x;
      this.y = y;
    }

    // Перегрузка метода Equals
    public override bool Equals(object obj) 
    {
      // Если obj == null,
      // Значит он не равен объекту, от имени которого вызывается этот метод
      if (obj == null)
      {
        return false;
      } 

      Point p = obj as Point;
      // Переданный объект не является ссылкой на Point 
      if (p == null) 
      {
        return false;
      }

      // Проверяется равенство содержимого 
      return ((x == p.x) && (y == p.y));
    }

    //При перегрузке Equals надо также перегрузить GetHashCode()
    public override int GetHashCode() 
    {
      return x ^ y; // использование XOR для получения хеш-кода
    }

    public static bool operator ==(Point p1, Point p2)
    {
      // Проверка, что переменные ссылаются на один и тот же адрес
      // Сравнение p1 == p2 приведет к бесконечной рекурсии 
      if (ReferenceEquals(p1, p2)) 
      {
        return true;
      } 

      // Приведение к object необходимо,
      // т.к. сравнение p1 == null приведет к бесконечной рекурсии 
      if ((object)p1 == null)
      {
        return false;
      }

      return p1.Equals(p2);
    }

    public static bool operator !=(Point p1, Point p2) 
    {
      return (!(p1 == p2)); 
    }
  }

  class Program 
  {
    static void Main()
    {
      Point cp = new Point(0, 0);
      Point cp1 = new Point(0, 0);
      Point cp2 = new Point(1, 1);
      Console.WriteLine("cp == cp1: {0}", cp == cp1); // true
      Console.WriteLine("cp == cp1: {0}", cp == cp2); // false
    }
  }
}
```

#figure(
  image(
    "lab4_imports/images/example5.png",
    width: 80%,
  ),
  caption: [Результат выполнения программы],
)

Условные логические операторы `&&` и `||` нельзя перегрузить, но они вычисляются с помощью `&` и `|`, допускающих перегрузку.

== Перегрузка операторов преобразования типа 

Операции преобразования типа обеспечивают возможность явного и неявного преобразования между пользовательскими типами данных. 
Синтаксис объявителя операции преобразования типа:

```cs 
implicit operator тип ( параметр ) // Неявное преобразование 
explicit operator тип ( параметр ) // Явное преобразование
```

Эти операции выполняют преобразование из типа параметра в тип, указанный в заголовке операции. 
Одним из этих типов должен быть класс, для которого определяется операция. 
Таким образом, операции выполняют преобразования либо типа класса к другому типу, либо наоборот.
Преобразуемые типы не должны быть связаны отношениями наследования.

Явное приведение типов требуется, если возможна потеря данных в результате приведения. Например:
- при преобразовании `int` в `short`, потому что размер `short` недостаточен для сохранения значения `int`;
- при преобразовании типов данных со знаком в беззнаковые может быть получен неверный результат, если переменная со знаком содержит отрицательное значение;
- при конвертировании типов с плавающей точкой в целые дробная часть теряется;
- при конвертировании типа, допускающего значение `null`, в тип, не допускающий `null`, если исходная переменная содержит `null`, генерируется исключение.

Если потери данных в результате приведения не происходит, приведение можно выполнять как неявное.

== Индивидуальные задания 

*Создайте класс с компонентами*:

1.
  1. `Point`. 
  2. Индексатор, позволяющий по индексу 0 обращаться к полю `x`, по индексу 1 --- к полю `y`, при других значениях индекса выдается сообщение об ошибке.
  3. Перегрузку:
    - операции `++` (`--`): одновременно увеличивает (уменьшает) значение полей `х` и `у` на 1;
    - констант `true` и `false`: обращение к экземпляру класса дает значение `true`, если значение полей `x` и `у` совпадает, иначе `false`;
    - операции бинарный `+`: одновременно добавляет к полям `х` и `у` значение скаляра.
  4. Преобразования типа `Point` в `string` (и наоборот).

2. 
  1. `Triangle`.
  2. Индексатор, позволяющий по индексу 0 обращаться к полю `a`, по индексу 1 --- к полю `b`, по индексу 2 --- к полю `c`, при других значениях индекса выдается сообщение об ошибке.
  3. Перегрузку:
    - операции `++` (`--`): одновременно увеличивает (уменьшает) значение полей `a`, `b` и `c` на 1;
    - констант `true` и `false`: обращение к экземпляру класса дает значение `true`, если треугольник с заданными длинами сторон существует, иначе `false`;
    - операции `*`: одновременно домножает поля `a`, `b` и `c` на скаляр.
  4. Преобразования типа `Triangle` в `string` (и наоборот).

3. 
  1. `Rectangle` 
  2. Индексатор, позволяющий по индексу 0 обращаться к полю `a`, по индексу 1 --- к полю `b`, при других значениях индекса выдается сообщение об ошибке.
  3. Перегрузку:
    - операции `++` (`--`): одновременно увеличивает (уменьшает) значение полей `a` и `b`;
    - констант `true` и `false`: обращение к экземпляру класса дает значение `true`, если прямоугольник с заданными длинами сторон является квадратом, иначе `false`;
    - операции `*`: одновременно домножает поля `a` и `b` на скаляр.  
  4. Преобразования типа `Rectangle` в `string` (и наоборот).

4.
  1. Класс для работы с одномерным массивом целых чисел.
  2. Индексатор, позволяющий по индексу обращаться к соответствующему элементу массива.
  3. Перегрузку:
    - операции `++` (`--`): одновременно увеличивает (уменьшает) значение всех элементов массива на 1;
    - операции `!`: возвращает значение `true`, если элементы массива не упорядочены по возрастанию, иначе `false`;
    - операции бинарный `*`: домножить все элементы массива на скаляр;
  4. Преобразования класса массив в одномерный массив (и наоборот).

5. 
  1. Класс для работы с двумерным массивом целых чисел.
  2. Двумерный индексатор, позволяющий обращаться к соответствующему элементу массива.
  3. Перегрузку:
    - операции `++` (`--`): одновременно увеличивает (уменьшает) значение всех элементов массива на 1;
    - констант `true` и `false`: обращение к экземпляру класса дает значение `true`, если двумерный массив является квадратным;
    - операции бинарный `+`: позволяющей сложить два массива соответствующих размерностей;
  4. Преобразования класса массив в двумерный массив (и наоборот).

6.
  1. Класс для работы с двумерным массивом вещественных чисел.
  2. Двумерный индексатор, позволяющий обращаться к соответствующему элементу массива.
  3. Перегрузку:
    - операции `++` (`--`): одновременно увеличивает (уменьшает) значение всех элементов массива на 1;
    - констант `true` и `false`: обращение к экземпляру класса дает значение true, если каждая строка массива упорядочена по возрастанию, иначе `false`;
    - операции `*`: позволяющей умножить два массива соответствующих размерностей.
  4. Преобразования класса массив в ступенчатый массив (и наоборот).

7. 
  1. Класс для работы со строками.
  2. Индексатор, позволяющий по индексу обращаться к соответствующему символу строки.
  3. Перегрузку:
    - операции унарного `+` (`-`): преобразующей строку к строчным (прописным) символам;
    - констант `true` и `false`: обращение к экземпляру класса дает значение `true`, если строка не пустая, иначе `false`.
    - операции `&`: возвращает значение `true`, если строковые поля двух объектов посимвольно равны (без учета регистра), иначе `false`;
  4. Преобразования класса-строки в тип `string` (и наоборот).

8.
  1. Добавить в класс для работы с регулярными выражениями.
  2. Индексатор, позволяющий по индексу 0 обращаться к полю `r` (само регулярное выражение), по индексу 1 --- к полю `text` (обрабатываемый текст), при других значениях индекса выдается сообщение об ошибке.
  3. Перегрузку:
    - операции унарного `-`: удаляет из поля `text` все фрагменты, соответствующие регулярному выражению поля `r`;
    - констант `true` и `false`: обращение к экземпляру класса дает значение `true`, если поле `text` не пустое, иначе `false`;
    - операции бинарного `+`: дописывает в конец поля `text` строку.
Преобразования класса `Regex` в тип `string` (и наоборот).

9.
  1. Класс для работы с датой.
  2. Индексатор, позволяющий определить дату `i`-того по счету дня относительно установленной даты (при отрицательных значениях индекса отсчет ведется в обратном порядке, рекомндуется использовать тип `DateTime`).
  3. Перегрузку:
    - операции `!`: возвращает значение `true`, если установленная дата не является последним днем месяца, иначе `false`;
    - констант `true` и `false`: обращение к экземпляру класса дает значение `true`, если установленная дата является началом года, иначе `false`;
    - операции `&`: возвращает значение `true`, если поля двух объектов равны, иначе `false`.
  4. Преобразования класса `DateTime` в тип `string` (и наоборот).

Вариантам 10 и далее соответствует задание по модулю 10 + 1. 

Так, например варианту 10 соответствует задание 1, варианту 11 сооветствует задание 2 и т.д.

= Часть 3. Наследование, виртуальные методы и свойства, полиморфизм и абстрактные классы

*Цель работы:*
Познакомиться с реализацией принципа наследования на языке С\#, с использованием виртуальных методов и свойств, абстрактных и бесплодных классов, с реализацией принципа полиморфизма на языке С\#.

== Теория

Мы уже отмечали, что "наследование" является одной из основных характеристик (или базовых понятий) объектно-ориентированного программирования, это механизм, который дает возможность создавать новый (производный) класс на основе определения уже существующего (базового) класса.

С помощью механизма наследования производный класс наследует все свойства и поведение представленные в базовом классе, при этом позволяя расширять их и изменять.
Все методы и свойства интерфейса базового класса автоматически появляются в интерфейсе производного класса.

Производный класс может иметь только один непосредственный базовый класс. 
Однако наследование является транзитивным.
Если `ClassC` является производным от `ClassB`, и `ClassB` является производным от `ClassA`, `ClassC` наследует члены, объявленные в `ClassB` и `ClassA`.

Наследование применяется для следующих взаимосвязанных целей:
- исключения из программы повторяющихся фрагментов кода;
- упрощения модификации программы;
- упрощения создания новых программ на основе существующих.

При описании класса имя его базового класса записывается в заголовке класса после двоеточия (если имя предка не указано, предком считается базовый класс всей иерархии `System.Object`):

```cs
[уровень доступа] class <имя производного класса>:<имя базового класса>
{
  // Описание членов класса
}
```

Поля, методы и свойства класса наследуются, поэтому при желании заменить элемент базового класса новым элементом следует явным образом указать компилятору свое намерение с помощью ключевого слова `new`.
Синтаксис для полей, свойств и методов выглядит соответственно следующим образом:

```cs
new <уровень доступа> <тип переменной> <имя переменной>;
new <уровень доступа> <тип><имя свойства > { get { код_доступа} set { код_доступа} }
new <уровень доступа> <возвращаемый тип><имя метода > (<список параметров>){тело_метода}
```

Из производного класса можно получить доступ к открытым (`public`), защищенным (`protected`), внутренним (`internal`) и защищенным внутренним (`protected internal`) членам базового класса.  

Хотя производный класс и наследует закрытые члены базового класса, он не может получить доступ к этим членам.
Однако все эти закрытые члены все же присутствуют в производном классе и могут выполнять ту же работу, что и в самом базовом классе, например, если защищенный метод базового класса имеет доступ к закрытому полю, то это поле должно присутствовать в производном классе для правильной работы унаследованного метода базового класса.

Конструкторы не наследуются, поэтому производный класс должен иметь собственные конструкторы. Порядок вызова конструкторов определяется приведенными далее правилами:

1. Если в конструкторе производного класса явный вызов конструктора базового класса отсутствует, автоматически вызывается конструктор базового класса без параметров. 
2. Для иерархии, состоящей из нескольких уровней, конструкторы базовых классов вызываются, начиная с самого верхнего уровня. После этого выполняются конструкторы тех элементов класса, которые являются объектами, в порядке их объявления в классе, а затем исполняется конструктор класса. Таким образом, каждый конструктор инициализирует свою часть объекта. 
3. Если конструктор базового класса требует указания параметров, он должен быть явным образом вызван в конструкторе производного класса в списке инициализации. Вызов выполняется с помощью ключевого слова `base`. Вызывается та версия конструктора, список параметров которой соответствует списку аргументов, указанных после слова `base`.

=== Пример. Наследование

*Задание*. 

Создайте два класса:
1. `Shape` (базовый класс), предназначенный для создания на своей основе классов любых геометрических фигур и обеспечивающий возможность чтения и записи их наименования; 
2. `Rectangle` (производный класс), предназначенный для описания состояния и поведения прямоугольников как геометрических фигур.

*Решение*.

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MyConsoleApplication
{
  // Объявление класса "Фигура"
  public class Shape 
  {
    // Члены класса:
    // Поля
    protected string Name;
    protected int SideA;
    protected int SideB;
    
    // Конструкторы
    public Shape(string name, int sideA, int sideB)
    {
      SideA = sideA; 
      SideB = sideB;
      Name = name;
    }

    // Свойства
    // Наименование фигуры
    public string Name 
    {
      set
      {
        Name = value + " (неопределенная фигура)"; 
      }
      get 
      {
        return Name; 
      }
    }
  }

  public class Rectangle : Shape
  {
    // Члены класса:

    // Конструкторы
    public Rectangle(string Name, int SideA, int SideB): base(Name,SideA,SideB) {}

    // Свойства
    // Свойство, дополняющее элементы базового класса  
    public int Perimeter
    {
      get
      { 
        return (SideA + SideB) * 2; 
      }
    }
    // Свойства
    // Свойство, заменяющее элемент базового класса  
    new public string Name 
    { 
      set 
      { 
        Name = value + " (прямоугольник)"; 
      }
      get
      { 
        return Name;
      }
    }
  }

  class Program 
  {
    static void Main() 
    {
      // Создание объекта на основе класса Rectangle (Большой прямоугольник со сторонами 5 и 10)
      Rectangle myRectangle = new Rectangle("Большой прямоугольник", 5, 10);

      // Выведем свойства фигуры
      // Имя 
      Console.WriteLine(myRectangle.Name);

      // Значение периметра
      Console.WriteLine(myRectangle.Perimeter);
      Console.ReadKey();
    }
  }
}
```

Во время разработки программы удобно оперировать объектами одной иерархии единообразно, то есть использовать один и тот же программный код для работы с экземплярами разных классов.
Желательно иметь возможность описать:
- объект, в который во время выполнения программы заносятся ссылки на объекты разных классов иерархии;
- контейнер, в котором хранятся объекты разных классов, относящиеся к одной иерархии;
- метод, в который могут передаваться объекты разных классов иерархии;
- метод, из которого в зависимости от типа вызвавшего его объекта вызываются соответствующие методы.

Все это возможно благодаря тому, что объекту базового класса в С\# можно присвоить объект производного класса, однако при этом для него вызываются только методы и свойства, определенные в базовом классе (см. пример ниже). 

=== Пример. Присвоение объекту базового класса объекта производного класса (пример несоответствия вызываемых методов типу объекта)

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MyConsoleApplication
{
  // Объявление класса "Фигура"
  public class Shape 
  {
    // Члены класса:
    // Поля
    protected string Name;

    public Shape()
    {
      Name = "Неопределенная фигура";
    }

    // Наименование фигуры
    public string Name
    {
      get
      { 
        return Name + " (неопределенная фигура)"; 
      }
    }
  }

  public class Rectangle : Shape
  {
    // Члены класса:
    // Конструкторы
    public Rectangle()
    {
      Name = "Прямоугольник";
    }
     
    // Свойство, заменяющее элемент базового класса
    new public string Name 
    {
      get 
      { 
        return Name; 
      }
    }
  }


  public class Circle : Shape
  {
    // Члены класса:
    // Конструкторы
    public Circle() 
    {
      Name = "Окружность";
    }

    // Свойство, заменяющее элемент базового класса  
    new public string Name 
    {
      get
      { 
        return Name; 
      }
    }
  }


  class Program
  {
    static void Main() 
    {
      // Создание объектов базового класса 
      // на основе производных класcов 
      Shape myShape1 = new Rectangle();
      Shape myShape2 = new Circle();

      // на основе базового класса
      Shape myShape3 = new Shape();

      // Выведем свойства фигуры
      // Имя 
      Console.WriteLine(myShape1.Name);
      Console.WriteLine(myShape2.Name);
      Console.WriteLine(myShape3.Name);
      Console.ReadKey();
      Console.WriteLine();

      // То же самое, но с использование массива
      Shape[] MyShape = new Shape[3];
      MyShape[0] = new Rectangle();
      MyShape[1] = new Circle();
      MyShape[2] = new Shape();

      foreach (Shape elem in MyShape)
      {
        Console.WriteLine(elem.Name);
      }
      Console.ReadKey();
    }
  }
}
```

Таким образом, возможность доступа к элементам класса определяется типом ссылки, а не типом объекта, на который она указывает.

Причина этого состоит в том, что компилятор еще до выполнения программы должен решить, какой метод вызывать, и вставить в код фрагмент, передающий управление на этот метод (этот процесс называется ранним связыванием).
При этом компилятор может руководствоваться только типом переменной, для которой вызывается метод или свойство. 
То, что в этой переменной в разные моменты времени могут находиться ссылки на объекты разных типов, компилятор учесть не может.

Следовательно, если мы хотим, чтобы вызываемые методы соответствовали типу объекта, необходимо отложить процесс связывания до этапа выполнения программы, а точнее --- до момента вызова метода, когда уже точно известно, на объект какого типа указывает ссылка.
Такой механизм в С\# есть --- он называется поздним связыванием и реализуется с помощью так называемых виртуальных методов.

Объявление метода виртуальным означает, что все ссылки на этот метод будут разрешаться по факту его вызова, то есть не на стадии компиляции, а во время выполнения программы.

Для обозначения виртуального метода или виртуального свойства используется ключевое слово `virtual`, которое записывается в заголовке метода или свойства базового класса следующим образом:

```cs
virtual <уровень доступа> <тип><имя свойства> { get { код_доступа} set { код_доступа} }
virtual <уровень доступа> <возвращаемый тип><имя метода> (<список параметров>){тело_метода}
```

Если в производном классе требуется переопределить виртуальный метод или виртуальное свойство, используется ключевое слово `override`:

```cs
override <уровень доступа> <тип><имя свойства> { get { код_доступа} set { код_доступа} }
override <уровень доступа> <возвращаемый тип><имя метода> (<список параметров>){тело_метода}
```

=== Пример. Использование виртуальных методов (свойств)

*Задание*. 

Изменить программный код, приведенный в предыдущем примере, таким образом, чтобы вызываемые методы соответствовали типу объекта.

*Решение*.

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MyConsoleApplication 
{
  // Объявление класса "Фигура"
  public class Shape
  {
    // Члены класса
    // Поля.
    protected string Name;

    public Shape() 
    {
      Name = "Неопределенная фигура";
    }

    // Наименование фигуры
    virtual public string Name 
    {
      get
      {
        return Name + " (неопределенная фигура)";
      }
    }
  }

  public class Rectangle : Shape 
  {
    // Члены класса
    // Конструкторы
    public Rectangle() 
    {
      Name = "Прямоугольник";
    }

    // свойство, заменяющее элемент базового класса  
    override public string Name 
    {
      get 
      { 
        return Name; 
      }
    }
  }


  public class Circle : Shape
  {
    // Члены класса
    // Конструкторы
    public Circle() 
    {
      Name = "Окружность";
    }

    // Свойство, заменяющее элемент базового класса  
    override public string Name 
    {
      get 
      { 
        return Name;
      }
    }
  }

  class Program 
  {
    static void Main()
    {
      Shape[] MyShape = new Shape[3];
      MyShape[0] = new Rectangle();
      MyShape[1] = new Circle();
      MyShape[2] = new Shape();
      foreach (Shape elem in MyShape) 
      {
        Console.WriteLine(elem.Name);
      }
      Console.ReadKey();
    }
  }
}
```

Переопределенный виртуальный метод должен обладать таким же набором параметров, как и одноименный метод базового класса.
Это требование вполне естественно, если учесть, что одноименные методы
, относящиеся к разным классам, могут вызываться из одной и той же точки программы.

Виртуальные методы базового класса определяют интерфейс всей иерархии.
Этот интерфейс может расширяться в потомках за счет добавления новых виртуальных методов. 
Переопределять виртуальный метод в каждом из потомков не обязательно: если он выполняет устраивающие потомка действия, метод наследуется.

С помощью виртуальных методов реализуется один из основных принципов объектно-ориентированного программирования --- полиморфизм. 
Это слово в переводе с греческого означает "много форм", что в данном случае означает "один вызов --- много методов".
Применение виртуальных методов обеспечивает гибкость и возможность расширения функциональности класса (см. пример ниже).
При описании классов рекомендуется определять в качестве виртуальных те методы, которые в производных классах должны реализовываться по-другому.

Если во всех классах иерархии метод будет выполняться одинаково, его лучше определить как обычный метод.

Таким образом, при наследовании производный класс получает от базового класса все методы, поля, свойства и события.
При разработке производного класса можно поступить следующим образом:
- либо наследовать члены ближайшего базового класса без переопределения; 
- либо заменить реализацию отдельных членов производного класса, скрывая при этом их реализацию в базовом классе;
- либо переопределить виртуальные члены в базовом классе.

При создании иерархии объектов для исключения повторяющегося кода часто бывает логично выделить их общие свойства в один родительский класс. 
При этом может оказаться, что создавать экземпляры такого класса не имеет смысла, потому что никакие реальные объекты им не соответствуют.
Такие классы называют абстрактными. 

Абстрактный класс служит только для порождения потомков. 
Как правило, в нем задается набор методов, который каждый из потомков будет реализовывать по-своему.
Абстрактные классы предназначены для представления общих понятий, которые предполагается конкретизировать в производных классах. 
При этом полученный базовый класс может представлять очень общую сущность, и создание экземпляров такого класса не будет иметь смысла. 
В этом случае класс объявляют как абстрактный (`abstract`) и в нём присутствуют абстрактные методы.

Класс называется абстрактным, если он имеет хотя бы один абстрактный метод.
Метод называется абстрактным, если при его определении задана его сигнатура, но не задана реализация метода.
Абстрактный метод представляет собой виртуальный метод, переопределяемый производными классами.

Объявление абстрактных классов и абстрактных методов должно сопровождаться модификатором `abstract`.

```cs
public abstract class Shape 
{ 
  // ...
  public abstract void Draw();
  // ...
}
```

Модификатор `abstract` может применяться только в методах экземпляра, но не в статических методах.

Поскольку абстрактные классы не являются полностью определенными классами, то нельзя создавать объекты абстрактных классов. 
Кроме того, абстрактные классы могут содержать и полностью определённые методы, в отличие от сходного с ними по назначению специального вида классов, называемых интерфейсом.

Таким образом, абстрактные классы служат только для создания классов-потомков.
Обычно в абстрактном классе задается набор методов, которые каждый из потомков будет реализовывать по-своему. 
Если класс, являющийся производным от абстрактного класса, не переопределяет все абстрактные методы, то он также является абстрактным и должен иметь модификатор `abstract`.

Абстрактный класс задает интерфейс для всей иерархии, при этом методам класса может не соответствовать никаких конкретных действий. 
В этом случае методы имеют пустое тело и объявляются со спецификатором `abstract`.
В производном классе методы переопределяются с помощью спецификатора `override`.

В некоторых случаях возникает необходимость запретить наследовать от определенного класса.
Ключевое слово `sealed` позволяет описать такой класс, который принято называть бесплодным.

В .NET Framework базовым классом для всех остальных классов и типов является класс `System.Object`.
В языке C\# данный класс носит имя `Object`.
Таким образом, каждый значимый и ссылочный тип в C\# неявно наследует класс `Object`.
В частности это означает, что переменная ссылочного типа `Object` может ссылаться на объект любого другого типа.

Мы рассматривали выше, что класс `Object` имеет следующие открытые виртуальные методы:

- `bool Equals(object obj)` --- возвращает значение `true`, если параметр `obj` является таким же, как и вызывающий объект;
- `int GetHashCode()` --- формирует хеш-код объекта и возвращает целое число, однозначно идентифицирующее объект; может использоваться в алгоритмах, где хеширование используется в качестве средства доступа к хранимым объектам;
- `string ToString()` --- по умолчанию возвращает для ссылочных типов полное имя класса в виде строки, а для значимых типов --- значение величины, преобразованное в строку; данный метод переопределяют для того, чтобы можно было выводить информацию о состоянии объекта.

Переопределить метод `ToString()` можно при помощи следующего объявления метода:

```cs
public override string ToString()
{
  // ...
}
```

В Visual Studio после набора слова `override` внутри класса и нажатии клавиши пробела IntelliSense автоматически отображает список всех переопределяемых элементов базового класса (см. рис. @intellisense).

#figure(
  image(
    "lab4_imports/images/intellisense.png",
    width: 80%,
  ),
  caption: [Просмотр списка переопределяемых элементов в Visual Studio],
) <intellisense>

Такое же поведение и подсказки ожидайте в любом другом текстовом редакторе или IDE с настроенным под язык C\# LSP.

=== Пример 

Требуется разработать класс `BaseCar` ("легковой автомобиль в базовой комплектации"), который содержит виртуальный метод `int GetCost()` ("определить стоимость") и переопределяет методы базового класса `System.Object`.
Кроме того, требуется разработать производный от него класс `ForcedCar` ("легковой автомобиль с гидроусилителем руля"), который будет переопределять метод int `GetCost()`.
Исходный код указанных классов представлен в листингах ниже. В коде использовались комментарии к XML-документации (смотрите Приложение 1 к лабораторной работе).

```cs
namespace MyConsoleApplication 
{
  /// <summary>
  /// Представляет легковые автомобили в базовой комплектации.
  /// </summary>
  public class BaseCar 
  {
    protected string mark; // Марка
    protected int year;    // Год выпуска
    protected int cost;    // Базовая стоимость, руб.

    /// <summary>
    /// Конструктор по умолчанию.
    /// </summary>
    public BaseCar()
    {
      mark = "Daewoo Nexia";
      year = 2014;
      cost = 209000;
    }

    /// <summary>
    /// Конструктор с параметрами.
    /// </summary>
    /// <param name="mark">Марка</param>
    /// <param name="year">Год выпуска</param>
    /// <param name="cost">Стоимость, руб.</param>
    public BaseCar(string mark, int year, int cost)
    {
      this.mark = mark;
      this.year = year;
      this.cost = cost;
    }

    /// <summary>
    /// Возвращает результат сравнения объектов.
    /// </summary>
    /// <param name="obj">Объект</param>
    /// <returns>Результат сравнения</returns>
    public override bool Equals(object obj) 
    {
      return base.Equals(obj);
    }

    /// <summary>
    /// Возвращает хеш-код экземпляра класса BaseCar.
    /// </summary>
    /// <returns>Хеш-код объекта</returns>
    public override int GetHashCode()
    {
      return base.GetHashCode();
    }

    /// <summary>
    /// Возвращает строку с данными об автомобиле.
    /// </summary>
    /// <returns>Строка с данными об автомобиле</returns>
    public override string ToString() 
    {
      return string.Format(
        "Автомобиль: {0}\n" +
        "Год выпуска: {1}\n" +
        "Базовая стоимость: {2} руб.\n",
        mark, year, cost
      );
    }

    /// <summary>
    /// Определяет стоимость в зависимости от года выпуска.
    /// </summary>
    /// <returns>Стоимость, руб.</returns>
    public virtual int GetCost()
    {
      // Степень уценки в зависимости от года выпуска
      double dis = 1 - (DateTime.Today.Year - year) / 85.0;
      return Convert.ToInt32(cost * dis);
    }
  }

  /// <summary>
  /// Представляет легковые автомобили с гидроусилителем руля.
  /// </summary>
  public class ForcedCar : BaseCar
  {
    int cost1; // Стоимость гидроусилителя
    int cost2; // Стоимость монтажа

    /// <summary>
    /// Конструктор по умолчанию.
    /// </summary>
    public ForcedCar() : base()
    {
      cost1 = 7000;
      cost2 = 3000;
    }

    /// <summary>
    /// Конструктор с параметрами.
    /// </summary>
    /// <param name="mark">Марка</param>
    /// <param name="year">Год выпуска</param>
    /// <param name="cost">Базовая стоимость, руб.</param>
    /// <param name="cost1">Стоимость гидроусилителя, руб.</param>
    /// <param name="cost2">Стоимость монтажа, руб.</param>
    public ForcedCar(string mark, int year, int cost, int cost1, int cost2)
      : base(mark, year, cost)
    {
      this.cost1 = cost1;
      this.cost2 = cost2;
    }

    /// <summary>
    /// Возвращает полную стоимость.
    /// </summary>
    /// <returns>Полную стоимость, руб.</returns>
    public override int GetCost()
    {
      return base.GetCost() + cost1 + cost2;
    }
  }


  class Program 
  {
    static void Main() 
    {
      Console.Title = "Работа с виртуальными методами";

      BaseCar car1 = new BaseCar();
      ForcedCar car2 = new ForcedCar();
      BaseCar car3 = new BaseCar("Daewoo Matiz", 2013, 230000);
      ForcedCar car4 = new ForcedCar("Daewoo Matiz", 2014, 230000, 6000, 3000);

      BaseCar[] cars = new BaseCar[] { car1, car2, car3, car4 };

      foreach (BaseCar car in cars) 
      {
        Console.WriteLine("Идентификатор: {0}", car.GetHashCode());
        Console.WriteLine(car.ToString());
        Console.WriteLine("Полная стоимость: {0} руб.\n", car.GetCost());
      }

      Console.WriteLine("Результаты сравнения объектов:");
      Console.WriteLine(car1.Equals(car1));
      car1 = car3;
      Console.WriteLine(car3.Equals(car1));
      car3 = car2;
      Console.WriteLine(car3.Equals(car1));

      Console.Read();
    }
  }
}
```

#figure(
  image(
    "lab4_imports/images/classes1.png",
    width: 80%,
  ),
  caption: [Диаграмма классов в Visual Studio],
) 

#figure(
  image(
    "lab4_imports/images/example6.png",
    width: 80%,
  ),
  caption: [Работа консольного приложения],
) 

Полезным видом классов являются запечатанные (бесплодные) классы, для которых запрещается строить производные классы путём наследования.
Примером запечатанного класса является класс `String` встроенной библиотеки .NET Framework.

Если требуется использовать функциональность запечатанного класса, то используют не наследование, а включение.

Иногда требуется не запечатывать класс целиком, а просто предотвратить переопределение некоторых виртуальных методов в производных классах. 
Для этого в заголовке метода указывается ключевое слово `sealed`, и такой метод называется запечатанным виртуальным методом.

=== Пример. Разработка иерархии классов, начиная с абстрактного класса

*Задача*.

Требуется разработать семейство из трёх классов, связанных иерархией наследования, и их следующий функционал:

1. Твёрдое тело: плотность материала тела; определить объём; определить массу; определить центральный момент инерции.
2. Сегмент параболоида вращения: радиус основания, высота.
3. Усечённый параболоид вращения: радиус малого основания.


#figure(
  image(
    "lab4_imports/images/figures.png",
    width: 80%,
  ),
  caption: [Параболоиды вращения],
) 

Создадим в Visual Studio решение Polymorphism, с проектом консольного приложения ConsoleApplication.
Добавим в решение проект библиотеки классов PolymorphClasses.

Реализуем в библиотеке классов PolymorphClasses следующую иерархию классов:
1. `RigidBody` ("твёрдое тело") --- абстрактный класс;
2. `Paraboloid` ("параболоид вращения") --- наследник класса `RigidBody`:
3. `TruncParab` ("усечённый параболоид вращения") --- наследник класса `Paraboloid`.

Исходный код классов `RigidBody`, `Paraboloid` и `TruncParab` приведён ниже.

```cs
namespace MyConsoleApplication 
{
  /// <summary>
  /// Представляет твёрдые тела (абстрактный класс)
  /// </summary>
  public abstract class RigidBody 
  {
    protected static int count = 0; // Общее число твёрдых тел
    protected double density;       // Плотность материала тела, кг/м^3

    /// <summary>
    /// Конструктор по умолчанию
    /// </summary>
    public RigidBody() 
    {
      density = 1000;
      count++;
    }

    /// <summary>
    /// Параметрический конструктор
    /// </summary>
    /// <param name="_d">Плотность материала тела, кг/м^3</param>
    public RigidBody(double _d) 
    {
      density = _d;
      count++;
    }

    /// <summary>
    /// Возвращает число твёрдых тел
    /// </summary>
    public static int Count
    {
      get
      {
        return count;
      }
    }

    /// <summary>
    /// Возвращает или устанавливает плотность тела, кг/м^3
    /// </summary>
    public double Density
    {
      get 
      {
        return density;
      }
      set 
      {
        if (value <= 0) 
        {
          throw new Exception("Плотность тела должна быть > 0!");
        }
        density = value;
      }
    }

    /// <summary>
    /// Возвращает массу
    /// </summary>
    /// <returns>Масса, кг</returns>
    public abstract double GetMass();

    /// <summary>
    /// Возвращает центральный момент инерции
    /// </summary>
    /// <returns>Центральный момент инерции, кг*м^2</returns>
    public abstract double GetInertiaMoment();
  }

  /// <summary>
  /// Представляет параболоиды вращения, являющиеся твёрдыми телами.
  /// </summary>
  public class Paraboloid : RigidBody 
  {
    protected double radius; // Радиус основания, м
    protected double height; // Высота, м

    /// <summary>
    /// Конструктор по умолчанию
    /// </summary>
    public Paraboloid() : base() 
    {
      radius = 1;
      height = 1;
    }

    /// <summary>
    /// Конструктор с параметрами
    /// </summary>
    /// <param name="_d">Плотность, кг/м^3</param>
    /// <param name="_r">Радиус основания, м</param>
    /// <param name="_h">Высота, м</param>
    public Paraboloid(double _d, double _r, double _h) : base(_d) 
    {

      radius = _r;
      height = _h;
    }

    /// <summary>
    /// Возвращает или устанавливает радиус, м
    /// </summary>
    public virtual double Radius
    {
      get 
      { 
        return radius;
      }
      set
      {
        if (value <= 0)
        {
          throw new Exception("Радиус должен быть > 0!");
        }
        radius = value;
      }
    }

    /// <summary>
    /// Возвращает или устанавливает высоту, м
    /// </summary>
    public double Height
    {
      get
      {
        return height; 
      }
      set 
      {
        if (value <= 0)
        {
          throw new Exception("Высота должна быть > 0!");
        }
        height = value;
      }
    }

    /// <summary>
    /// Возвращает строку с характеристиками объекта
    /// </summary>
    /// <returns>Характеристики параболоидa вращения</returns>
    public override string ToString()
    {
      return (string.Format("Характеристики параболоида вращения:\n" +
                            "- плотность: {0} кг/м^3\n" +
                            "- радиус основания: {1} м\n" +
                            "- высота: {2} м", density, radius, height));
    }

    /// <summary>
    /// Возвращает объём
    /// </summary>
    /// <returns>Объём, м^3</returns>
    public virtual double GetVolume()
    {
      return (Math.PI * radius * radius * height / 2);
    }

    /// <summary>
    /// Возвращает массу
    /// </summary>
    /// <returns>Масса, кг</returns>
    public override double GetMass()
    {
      return (density * GetVolume());
    }

    /// <summary>
    /// Возвращает центральный момент инерции
    /// </summary>
    /// <returns>Центральный момент инерции, кг*м^2</returns>
    public override double GetInertiaMoment() 
    {
      return (GetMass() * radius * radius / 5);
    }
  }

  /// <summary>
  /// Представляет усечённые параболоиды вращения,
  /// являющиеся твёрдыми телами (запечатанный класс)
  /// </summary>
  public sealed class TruncParabol : Paraboloid 
  {
    double radiusSmall; // Радиус малого основания, м

    /// <summary>
    /// Конструктор по умолчанию
    /// </summary>
    public TruncParabol() : base()
    {
      radiusSmall = Radius / 2;
    }

    /// <summary>
    /// Конструктор с параметрами
    /// </summary>
    /// <param name="_d">Плотность, кг/м^3</param>
    /// <param name="_r">Радиус большого основания, м</param>
    /// <param name="_rs">Радиус малого основания, м</param>
    /// <param name="_h">Высота, м</param>
    public TruncParabol(double _d, double _r, double _rs, double _h) : base(_d, _r, _h)
    {
      radiusSmall = _rs;
    }

    /// <summary>
    /// Возвращает или устанавливает радиус большого основания, м
    /// </summary>
    public override double Radius 
    {
      get
      { 
        return base.Radius; 
      }
      set 
      {
        if (value > base.Radius)
        {
          throw new Exception("Радиус малого основания не должен быть" +
                              " больше радиуса большого основания!");
        }
        base.Radius = value;
      }
    }

    /// <summary>
    /// Возвращает или устанавливает радиус малого основания, м
    /// </summary>
    public double RadiusSmall 
    {
      get 
      {
        return radiusSmall;
      }
      set {
        if (value <= 0) 
        {
          throw new Exception("Радиус малого основания должен быть > 0!");
        }
        radiusSmall = value;
      }
    }

    /// <summary>
    /// Возвращает строку с характеристиками объекта
    /// </summary>
    /// <returns>Характеристики объекта</returns>
    public override string ToString() 
    {
      return (base.ToString() +
              string.Format("\n- радиус малого основания: {0} м", radiusSmall));
    }

    /// <summary>
    /// Возвращает объём
    /// </summary>
    /// <returns>Объём, м^3</returns>
    public override double GetVolume()
    {
      return (base.GetVolume() +
              Math.PI * height * radiusSmall * radiusSmall / 2);
    }

    /// <summary>
    /// Возвращает массу
    /// </summary>
    /// <returns>Масса, кг</returns>
    public override double GetMass()
    {
      return (density * GetVolume());
    }

    /// <summary>
    /// Возвращает центральный момент инерции
    /// </summary>
    /// <returns>Центральный момент инерции, кг*м^2</returns>
    public override double GetInertiaMoment() 
    {
      return (base.GetInertiaMoment() +
              GetMass() * radiusSmall * radiusSmall / 2);
    }
  }


  class Program
  {
    static void Main()
    {
      Console.Title = "Работа с семейством полиморфных классов";
      Console.WriteLine("*********** Твёрдые тела ***********\n");

      Paraboloid pb1 = new Paraboloid();
      Console.WriteLine(pb1.ToString());

      string s = "- объём: {0:f2} м3\n" +
                 "- масса: {1:f2} кг\n" +
                 "- момент инерции: {2:f2} кг*м2\n";

      Console.WriteLine(s, pb1.GetVolume(), pb1.GetMass(),
                        pb1.GetInertiaMoment());

      Paraboloid pb2 = new Paraboloid(800, 0.7, 1.2);
      Console.WriteLine(pb2.ToString());
      Console.WriteLine(s, pb2.GetVolume(), pb2.GetMass(),
                        pb2.GetInertiaMoment());

      TruncParabol pb3 = new TruncParabol();
      Console.WriteLine(pb3.ToString());
      Console.WriteLine(s, pb3.GetVolume(), pb3.GetMass(),
                        pb3.GetInertiaMoment());

      // Экземпляру базового класса присваивается ссылка на
      // экземпляр производного класса
      Paraboloid pb4 = new TruncParabol(750, 0.6, 0.25, 0.9);

      // Вызов через динамическое связывание методов
      // экземпляра производного класса
      Console.WriteLine(pb4.ToString());
      Console.WriteLine(s, pb4.GetVolume(), pb4.GetMass(),
                        pb4.GetInertiaMoment());

      Console.WriteLine("Всего твёрдых тел: {0} шт\n", RigidBody.Count);

      // Массив параболоидов вращения
      Paraboloid[] parabs = new Paraboloid[4];
      parabs[0] = pb1;
      parabs[1] = pb2;
      parabs[2] = pb3;  // Ссылка на объект производного класса
      parabs[3] = pb4;

      // Цикл для совместного вызова методов экземпляров
      // базового и производного классов
      foreach (Paraboloid p in parabs)
      {
        Console.WriteLine("Вычисленные характеристики тела:\n" + s,
                          p.GetVolume(), p.GetMass(), p.GetInertiaMoment());
      }

      Console.Read();
    }
  }
}
```

#figure(
  image(
    "lab4_imports/images/classes2.png",
    width: 80%,
  ),
  caption: [Диаграмма классов в Visual Studio],
) 

#figure(
  image(
    "lab4_imports/images/example7.png",
    width: 80%,
  ),
  caption: [Результат работы консольного приложения],
) 

== Задание для самостоятельной работы

Данная лабораторная работа предполагает выполнение следующих этапов:
1. Изучить методические указания к лабораторной работе.
2. Разработать базовый класс, содержащий виртуальные методы (см. табл. @table3), и производный от него класс, в котором эти методы переопределены. Дополнительно требуется переопределить методы класса `System.Object`. 
3. Построить иерархию классов, начиная с абстрактного класса (см. табл. @table4). Предусмотреть виртуальные методы в проектируемых классах, а также переопределение этих методов в классах-потомках. Разместить полученные классы в DLL. Разработать консольное приложение, демонстрирующее полиморфизм построенного семейства классов.

#figure(
  caption: [Варианты заданий для разработки классов, содержащих виртуальные методы и их переопределение],
  table(
    columns: 4,
    align: left,
    table.header(
      table.cell(rowspan: 2, [*_№ вар._*]),
      table.cell(rowspan: 2, [*_Виртуальные методы_*]),
      table.cell(colspan: 2, [*_Класс_*]),
      [*_Базовый_*], [*_Производный_*],
    ),

    [1, 5, 9],
    [Определить стоимость ремонта.],
    [Здание (площадь, высота, число этажей, износ).],
    [Жилое здание (общая жилплощадь).],

    [2, 6, 10],	
    [Определить сумму возврата.],
    [Кредит (дата выдачи, сумма, срок, процент).], 
    [Кредит с залогом имущества (стоимость имущества).],

    [3, 7, 11],	
    [Определить цену.],
    [Квартира (адрес дома, номер, площадь, число комнат, этаж).],
    [Квартира с лоджией (площадь лоджии).],

    [4, 8, 12],	
    [Определить стоимость перевозки.],
    [Перевозка грузов (дата, адрес доставки, тип груза, вес груза).],
    [Перевозка грузов за пределы города (расстояние от города).],
  )
) <table3>

#figure(
  caption: [Варианты заданий для разработки иерархии классов, начиная от абстрактного класса],
  table(
    columns: 4,
    align: left,
    table.header(
      table.cell(rowspan: 2, [*№ вар.*]),
      table.cell(colspan: 3, [*Данные для разработки иерархии классов*]),
      [*_Класс 1_*], [*_Класс 2_*], [*_Класс 3_*]
    ), 

    [1, 9, 17],	
    [*Объёмная фигура*: определить объём, определить площадь поверхности.],
    [*Шар*: радиус.],
    [*Полый шар*: внутренний радиус.],

    [2, 10, 18], 
    [*Плоская фигура*: определить периметр, определить площадь.],
    [*Круг*: радиус.],
    [*Круглое кольцо*: внутренний радиус.],


    [3,	11, 19], 
    [*Объёмная фигура*: определить объём, определить площадь поверхности],
    [*Прямой круговой конус*: радиус основания, высота.],
    [*Усечённый прямой круговой конус*: радиус малого основания.],


    [4, 12, 20], 
    [*Плоская фигура*: определить периметр, определить площадь.],
    [*Трапеция*: верхнее основание, нижнее основание, высота.],
    [*Параллелограмм*: угол параллелограмма.],

    [5, 13, 21], 
    [*Объёмная фигура*: определить объём, определить площадь поверхности.],
    [*Прямой круговой цилиндр*: радиус основания, высота],
    [*Полый цилиндр*: внутренний радиус],


    [6, 14, 22], 
    [*Объёмная фигура*: определить объём, определить площадь поверхности.],
    [*Правильная пирамида*: площадь основания, высота, апофема.],
    [*Правильная усечённая пирамида*: площадь малого основания.],


    [7, 15, 23], 
    [*Объёмная фигура*: определить объём, определить площадь поверхности.],
    [*Шаровой сегмент*: высота, радиус шара, радиус основания.],
    [*Шаровой слой*: радиус малого основания.],


    [8, 16, 24], 
    [*Плоская фигура*: определить периметр, определить площадь.],
    [*Круговой сектор*: радиус, центральный угол.],
    [*Круговой сегмент*: высота.],

  )
) <table4>

= Часть 4. Методы расширения

Методы расширения (extension methods) позволяют добавлять новые методы в уже существующие типы без создания нового производного класса.
Эта функциональность бывает особенно полезна, когда нам хочется добавить в некоторый тип новый метод, но сам тип (класс или структуру) мы изменить не можем, поскольку у нас нет доступа к исходному коду.
Либо если мы не можем использовать стандартный механизм наследования, например, если классы определены с модификатором `sealed` (не могут иметь наследников).

Например, нам надо добавить для типа `string` новый метод:

```cs
class Program
{
  static void Main(string[] args)
  {
    string s = "Привет мир";
    char c = 'и';
    int i = s.WordCount(c);
    Console.WriteLine(i);

    Console.ReadLine();
  }
}

public static class StringExtension
{
  public static int WordCount(this string str, char c)
  {
    int counter = 0;
    for (int i = 0; i < str.Length; i++)
    {
      if (str[i] == c) {
        counter++;
      }
    }
    return counter;
  }
}
```

Для того, чтобы создать метод расширения, вначале надо создать статический класс, который и будет содержать этот метод.
В данном случае это класс `StringExtension`.
Затем объявляем статический метод.
Суть нашего метода расширения --- подсчет количества определенных символов в строке.

Собственно метод расширения --- это обычный статический метод, который в качестве первого параметра всегда принимает такую конструкцию:

`this <имя_типа> <название_параметра>`

то есть в нашем случае `this string str`.
Так как наш метод будет относиться к типу `string`, то мы и используем данный тип.

Затем у всех строк мы можем вызвать данный метод:

`int i = s.WordCount(c);`

Причём нам уже не надо указывать первый параметр. Значения для остальных параметров передаются в обычном порядке.

Применение методов расширения очень удобно, но при этом надо помнить, что метод расширения никогда не будет вызван, если он имеет ту же сигнатуру, что и метод, изначально определённый в типе.
Также следует учитывать, что методы расширения действуют на уровне пространства имён.
То есть, если добавить в проект другое пространство имён, то метод не будет применяться к строкам, и в этом случае надо будет подключить пространство имён метода через директиву `using`.

Еще один пример: вычисление факториалов с использованием метода расширения.

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace ConsoleApplication1
{
  class Program
  {
    static void Main(string[] args)
    {
      int x = 3;
      Console.WriteLine(x.factorial());
      Console.ReadLine();
    }
  }
  public static class MyMathExtension
  {
    public static int factorial(this int x)
    {
      if (x <= 1)
      {
        return 1;
      }
      if (x == 2)
      {
        return 2;
      }
      else
      {
        return x * factorial(x - 1);
      }
    }
  }
}
```

== Создание и использование библиотек

=== Назначение библиотек

При разработке программ со временем возникает необходимость повторного использования кода.
Классы и методы, написанные для одной программы, часто оказываются полезными и в других проектах.
Для удобства повторного использования такой код целесообразно выделять в отдельные библиотеки.

В платформе .NET единицей повторного использования является сборка (assembly).
Сборка может содержать:
- классы;
- структуры;
- интерфейсы;
- методы;
- метаданные.

Чаще всего сборки распространяются в виде файлов с расширением .dll.
Следует подчеркнуть, что это не нативные Windows-DLL, а .NET-сборки, содержащие промежуточный код (IL) и метаданные.
Такие библиотеки являются кроссплатформенными и могут использоваться на любых операционных системах, поддерживающих .NET (Windows, Linux, MacOS).
Не обязательно писать библиотеки на языке C\#, подойдет и любой другой язык, интегрированный с платформой .NET.

=== Динамические библиотеки и сборки .NET

Библиотеки в .NET реализуют принцип динамической компоновки. Это означает, что:
- библиотека загружается в память во время выполнения программы;
- код библиотеки используется только при необходимости;
- после завершения работы приложения библиотека выгружается.

Такой подход позволяет уменьшить дублирование кода, сократить объем занимаемой памяти и	упростить сопровождение и обновление программ.

С точки зрения архитектуры любая библиотека выступает в роли сервера, предоставляющего функциональность, а приложение --- в роли клиента, использующего эту функциональность.

==== Создание библиотеки классов с помощью .NET SDK

Создание библиотек в .NET не зависит от используемой операционной системы или среды разработки.
Для этого достаточно установленного .NET SDK.

В терминале выполните команду:

```sh
dotnet new classlib -n MyLibrary
```

В результате будет создан проект библиотеки классов.
По умолчанию в проекте присутствует один файл с минимальным кодом класса.
Его можно переименовать и использовать для реализации собственной логики.

Пример класса библиотеки:

```cs
namespace MyLibrary
{
  public class Method
  {
    public int Add(int a, int b)
    {
      return a + b;
    }

    public int Sub(int a, int b)
    {
      return a - b;
    }
  }
}
```

После написания кода библиотеку необходимо собрать:

```sh
dotnet build
```

В каталоге `bin/Debug` (или `bin/Release`) будет создан файл библиотеки .dll.

==== Создание библиотеки классов через Visual Studio

Для того, чтобы создать библиотеку в Visual Studio на Windows, нужно выбрать пункт главного меню "Файл --- Создать --- Проект".
После чего откроется окно "Создание проекта", в левой части которого нужно выбрать "Шаблоны --- Visual C\# --- Windows", в главной рабочей области выбрать пункт "Библиотека классов", а в нижней части окна ввести имя библиотеки, как показано на рисунке ниже (также можно указать расположение создаваемого проекта).

#figure(
  image(
    "lab4_imports/images/lib_creation1.png",
    width: 80%,
  ),
  caption: [Выбор типа создаваемого проекта],
)

После указания всех параметров нужно нажать на кнопку "OK" и дождаться создания проекта.
После успешного создания проекта мы увидим примерно следующее окно:

#figure(
  image(
    "lab4_imports/images/lib_creation2.png",
    width: 80%,
  ),
  caption: [Созданный проект библиотеки],
)

Чтобы переименовать класс, нам нужно навести курсор на его имя в обозревателе решений (Solution Explorer) и вызвать контекстное меню, в котором выбрать пункт "Переименовать".
После чего в области редактирования ввести новое имя и нажать на клавишу Enter, в результате появится сообщение с запросом подтверждения.

Теперь можно собрать проект, выбрав "Сборка --- Собрать решение" в главном меню Visual Studio, или нажатием Ctrl+Shift+B. 
В директории `bin/Debug` будет лежать созданный dll-файл.

=== Статическое подключение библиотеки

Наиболее простой и безопасный способ использования библиотеки --- статическое подключение.
В этом случае типы библиотеки известны на этапе компиляции.

==== Подключение библиотеки в Visual Studio 

Чтобы подключить собранную библиотеку в классов в проект Visual Studio, надо нажать правой кнопкой мыши на "Зависимости" в обозревателе решений и выбрать с помощью диспетчера файлов .dll файл.

#figure(
  image(
    "lab4_imports/images/lib_creation3.png",
    width: 80%,
  ),
  caption: [Подключение библиотеки],
)

==== Подключение библиотеки с помощью .NET SDK

Создадим консольное приложение:

```sh
dotnet new console -n LibraryClient
```

Перейдя в директорию этого приложения, добавим ссылку на библиотеку:

```sh
dotnet add reference ../MyLibrary/MyLibrary.csproj
```

Теперь классы библиотеки можно использовать напрямую:

```cs
using MyLibrary;

class Program
{
  static void Main()
  {
    Method m = new Method();
    Console.WriteLine(m.Add(3, 4));
    Console.WriteLine(m.Sub(3, 4));
  }
}
```

При статическом подключении	проверка типов выполняется компилятором и большинство ошибок может быть выявлено заранее.

=== Статические классы и методы расширения

Если методы библиотеки не зависят от состояния объекта, удобно использовать статические классы.

Пример статического класса:

```cs
namespace MyLibrary
{
  public static class Method
  {
    public static int Add(int a, int b)
    {
      return a + b;
    }

    public static int Sub(int a, int b)
    {
      return a - b;
    }
  }
}
```

Использование:

```cs
Console.WriteLine(Method.Add(5, 6));
Console.WriteLine(Method.Sub(5, 6));
```

В библиотеку также можно добавлять методы расширения:

```cs
namespace MyLibrary
{
  public static class MathExtension
  {
    public static int Factorial(this int x)
    {
      if (x <= 1)
      {
        return 1;
      }
      if (x == 2)
      {
        return 2;
      }
      return x * Factorial(x - 1);
    }
  }
}
```

Пример использования:

```cs
int n = 5;
Console.WriteLine(n.Factorial());
```

=== Динамическая загрузка библиотек (Reflection)

В некоторых случаях заранее неизвестно, какие библиотеки или классы будут использоваться.
Для таких ситуаций применяется позднее связывание, реализуемое с помощью механизма `Reflection`.

Подключим пространство имен:

```cs
using System.Reflection;
```

Загрузим сборку во время выполнения программы:

```cs
Assembly assembly = Assembly.Load("MyLibrary");
```

Получим информацию о типах, содержащихся в сборке:

```cs
Type[] types = assembly.GetTypes();
foreach (Type t in types)
{
  Console.WriteLine(t.FullName);
}
```

Создание экземпляра класса и вызов метода:

```cs
object obj = assembly.CreateInstance("MyLibrary.Method");
Type type = assembly.GetType("MyLibrary.Method");

MethodInfo method = type.GetMethod("Add");
object result = method.Invoke(obj, new object[] { 2, 3 });

Console.WriteLine(result);
```

=== Динамический вызов статических методов

`Reflection` позволяет вызывать и статические методы, при этом экземпляр класса не требуется:

```cs
Type type = assembly.GetType("MyLibrary.Method");
MethodInfo method = type.GetMethod("Add");

object result = method.Invoke(null, new object[] { 10, 20 });
Console.WriteLine(result);
```

Аналогично можно вызывать методы расширения, если знать их имя и сигнатуру.

== Индивидуальные задания 

Задания выполняются для консольного приложения. 
Методы первой части задания должны быть перегружены (три варианта вызова) и использовать параметры по умолчанию. 
Расположите все методы задания в своей библиотеке. Продемонстрируйте их статическое и динамическое подключение к приложению.

1. Написать метод `min(x, y)`, находящий минимальное значение из двух чисел. С его помощью найти минимальное значение из четырёх чисел `a`, `b`, `c`, `d`. 
Определить метод расширения, сравнивающий исходное число с двумя другими и возвращающий `True` в том случае, если исходное число больше каждого из них.

2. Написать метод `max(x, y)`, находящий максимальное значение из двух чисел. С его помощью найти максимальное значение из четырёх чисел `a`, `b`, `c`, `d`.
Определить метод расширения, подсчитывающий количество делителей в исходном целом числе.

3. Написать метод, вычисляющий значение $(n)/(x^n)$. С его помощью вычислить выражение 
$ limits(sum)_(i = 1)^(10) (i)/(x^i). $
Определить метод расширения, определяющий, является ли число составным.	

4. Написать метод, вычисляющий значение $(n)/(x^n)$. С его помощью вычислить выражение
$ limits(product)_(i = 1)^(10) (i)/(x^i). $
Написать метод расширения, находящий НОД двух чисел.

5. Написать метод, вычисляющий значение $(x^n)/(x + n)$. С его помощью вычислить выражение
$ limits(sum)_(i = 1)^(10) (x^i)/(x + i). $
Определить метод расширения, вычисляющий дробную часть в выражении.

6. Написать метод, вычисляющий значение $sin(x) + cos(2x)$. С его помощью определить в какой из точек `a`, `b` или `с` значение будет минимальным. Написать метод расширения, находящий НОК двух чисел.

7. Написать метод, вычисляющий значение $x^2 + y^2$. С его помощью определить с какой парой чисел `(a, b)` или `(с, d)` значение будет максимальным. Написать метод расширения, делающий реверс целого числа.

8. Написать метод, вычисляющий значение $x^2 times y^3 times sqrt(z)$. С его помощью определить с какой тройкой чисел `(a, b, c)` или `(d, e, f)` значение будет максимальным. Написать метод расширения, находящий произведение числа на переданный в параметрах вектор.

9. Написать метод, который у чётных чисел меняет знак, а нечётные числа оставляет без изменения. С его помощью обработать ряд чисел от 1 до 10. Написать метод расширения, находящий произведение всех цифр в переданной строке.

10. Написать метод, который положительные числа возводит в квадрат, а отрицательные --- в куб. С его помощью обработать ряд чисел от -10 до 10. Написать метод расширения, определяющий, является ли число простым.

11. Написать метод, который вычисляет значения $x = sin^2(a)$ и $y = cos^2(a)$. Напечатать таблицу значений от $-pi$ до $pi$ с шагом $pi/4$. Написать метод расширения, обнуляющий в массиве все отрицательные элементы.

12. Написать метод, который вычисляет значения $x = a^2$ и $y = sqrt(a)$. Напечатать таблицу значений от –10 до 10 с шагом 1. Написать метод расширения, делающий реверс строки.
