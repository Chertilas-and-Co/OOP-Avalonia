#import "conf/conf.typ": conf

#show: conf.with(
  title: [= Лабораторная работа №4
  Классы и объекты],
  type: "pract",
  info: (
    author: (
      name: [],
      faculty: [],
      group: "",
      sex: "",
    ),
    inspector: (
      degree: "",
      name: "",
    ),
  ),
  settings: (
    title_page: (
      enabled: true,
    ),
    contents_page: (
      enabled: true,
    ),
  ),
)

= Часть 1. Индексаторы

*Цель работы*:
Познакомиться с основой объектного подхода в языке C\#, с использованием индексаторов.

== Теория

Индексатор представляет собой разновидность свойства. 
Если у класса есть скрытое поле, представляющее собой массив, то с помощью индексатора можно обратиться к элементу этого массива, используя имя объекта и номер элемента массива в квадратных скобках.

Синтаксис индексатора аналогичен синтаксису свойства:

`<уровень доступа> <тип>this [список_параметров] { get { код_доступа} set { код_доступа} }`

Индексаторы чаще всего объявляются спецификатором `public`, поскольку они входят в интерфейс объекта.

Код доступа представляет собой блоки операторов, которые выполняются при получении (`get`) или установке значения (`set`) элемента массива. 
Может отсутствовать либо часть `get`, либо `set`, но не обе одновременно.
Если отсутствует часть `set`, индексатор доступен только для чтения (read-only), если отсутствует часть `get`, индексатор доступен только для записи (write-only).

Синтаксически чтение и запись индексатора выглядят почти как методы. 
Метод `get` должен содержать оператор `return`, возвращающий выражение, для типа которого должно существовать неявное преобразование к типу свойства. 
В методе `set` используется параметр со стандартным именем `value`, который содержит устанавливаемое значение.

Список параметров содержит одно или несколько описаний индексов, по которым выполняется доступ к элементу.
Чаще всего используется один индекс целого типа.
Однако, C\# не ограничивает тип индексатора типом `int`.
Например, может оказаться полезным использование в индексаторе строки.
Такой индексатор можно реализовать, выполнив поиск строки в коллекции и возвратив соответствующее значением. 
Методы доступа можно перегружать, версии типа `string` и `int` могут сосуществовать.

Индексаторы могут иметь более одного формального параметра, например, при доступе к двухмерному массиву.

=== Пример. Работа с индексатором

*Задание*.
Создайте объект класса `Rectangle`: "Большой прямоугольник" со сторонами 5 и 10; объявите поле "Имя" данного класса, а также поле "Размеры сторон", содержащее информацию о размерах всех сторонах прямоугольника. 
Организуйте доступ к полю "Имя" посредством свойства, а к полю "Размеры сторон" посредством индексатора.

*Решение*.

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MyConsoleApplication
{

  // Объявление класса
  public class Rectangle
  {
    // Члены класса:
    // Поля.
    private string Name;

    // Объявляем массив с двумя элементами
    private int[] Side = new int[2];  

    // Индексатор с целочисленным параметром (индексом)
    public int this[int index] {
      get {
        return Side[index];
      }
      set {
        Side[index] = value;
      }
    }

     // Конструктор с аргументами
    public Rectangle(string name, int SideA, int SideB) {
      Side[0] = SideA;
      Side[1] = SideB;
      Name = name;
    }
    
    // Свойства
    // Только для чтения
    public int Perimeter {
      get {return (Side[0] + Side[1]) * 2; }
    }

    // Для чтения и для записи
    public string Name {
      set { Name = value; }
      get { return Name; }
    }
  
  }

  class Program {
    static void Main(string[] args) {     
      // Создание объекта на основе класса Rectangle (Большой прямоугольник со сторонами 5 и 10)
      Rectangle myRectangle = new Rectangle("Большой прямоугольник", 5, 10);

      // Выведем свойства фигуры и её имя
      Console.WriteLine(myRectangle.Name);

      // Длины сторон (до изменения)
      Console.WriteLine(myRectangle[0]);
      Console.WriteLine(myRectangle[1]);
      Console.ReadKey();
      
      // Изменим длины сторон прямоугольника
      myRectangle[0] = 10;
      myRectangle[1] = 20;

      // Выведем свойства фигуры
      // Длины сторон (после изменения)
      Console.WriteLine(myRectangle[0]);
      Console.WriteLine(myRectangle[1]);
      Console.ReadKey();

      // Значение периметра
      Console.WriteLine(myRectangle.Perimeter);
      Console.ReadKey();
    }
  }
}
```

Индексаторы очень удобно применять для создания специализированных массивов, на работу с которыми накладываются какие-либо ограничения.
Кроме того, при доступе к элементу проверяется, не вышел ли индекс за допустимые границы.

=== Пример.

Класс Треугольник. Поля --- длины сторон (целые числа).

```cs
// Индексатор, при значении 0 вернём длину стороны а, при 1 - стороны b, при 3 - стороны с
public string this[string i] {
  get {
    // switch - позволяет выбирать продолжение алгоритма из нескольких разделов, в скобках указывается условие выбора 
    switch (i) {
      // case - ключевое слово, после которого указывается какое либо значение условия выбора при switch
      case "0": return Convert.ToString(this.a); 
      case "1": return Convert.ToString(this.b);
      case "2": return Convert.ToString(this.c);

      // Дефолтное продолжение алгоритма (если не подошло ни к одному из значений case) 
      // В нашем случае генерируется исключение (throw new Exception)
      default: throw new Exception("i не принадлежит 0, 1 или 2"); 
    }
  }
}
```

=== Пример.

Предположим, есть некий магазин, занимающийся реализацией ноутбуков.
Эта ситуация отображается при помощи двух классов: класса `Shop`, изображающего магазин, и класса `Laptop`, изображающего его продукцию. 
Дабы не перегружать пример лишней информацией, снабдим класс `Laptop` только двумя полями: `vendor` --- для отображения имени фирмы-производителя, а также `price` --- для отображения цены ноутбука. 
Класс будет включать соответствующие открытые свойства `Vendor` и `Price`, конструктор с двумя параметрами, а также переопределённый метод `ToString()` для отображения информации по конкретной единице товара.
В качестве единственного поля класса `Shop` выступает ссылка на массив объектов `Laptop`.
В конструкторе с одним параметром задаётся количество элементов массива и выделяется память для их хранения. 
Далее нам нужно сделать возможным обращение к элементам этого массива через экземпляр класса `Shop`, пользуясь синтаксисом массива так, словно класс `Shop` и есть массив элементов типа `Laptop`. 
Для этого добавим в класс `Shop` индексатор:

```cs
public Laptop this[int pos] {
  get {
    if (pos >= LaptopArr.Length ||  pos < 0) {
      throw new IndexOutOfRangeException();
    } else {
      return (Laptop)LaptopArr[pos];
    }

  set { 
    LaptopArr[pos] = (Laptop)value; 
  }
}
```

Здесь в аксессоре `get` мы предусматриваем выход за пределы массива, и при этом генерируется исключение `IndexOutOfRangeException`.

Для проверки работы классов создаётся отдельный класс `Tester`, содержащий точку входа.
В нём создаётся экземпляр класса `Shop`, причём в конструкторе задается количество элементов, которые в нём можно разместить.

```cs
Shop sh = new Shop(3);
```
Далее мы заполняем этот массив объектами `Laptop`.

```
sh[0] = new Laptop("Samsung", 5200);
sh[1] = new Laptop("Asus", 4700); 
sh[2] = new Laptop("LG", 4300);
```

И, наконец, вывод на экран данных по каждому объекту `Laptop`, пользуясь синтаксисом массива.

```cs
for (int i = 0; i < 3; i++) {
  Console.WriteLine(sh[i].ToString());
}
```

В цикле ограничивающим значением в условии является явно заданное число 3.
Дело в том, что индексатор позволяет нам пользоваться лишь синтаксисом индексирования массива, но других функциональных возможностей массива не предоставляет.
Если это был бы стандартный массив, то это условие описывается иначе:

```cs
for (int i = 0; i < sh.Length; i++) {
  ...
}
```

Для того, чтобы подобная функциональная возможность появилась и в примере, необходимо добавить в класс `Shop` дополнительное свойство `Length`.

```cs
public int Length {
  get { 
    return LaptopArr.Length; 
  }
}
```

Общий вид программы:

```cs
namespace NS {
  public class Laptop {
    private string vendor;
    private double price;

    public string Vendor {
      get { 
        return vendor; 
      }
      set {
        vendor = value;
      }
    }

    public double Price {
      get { 
        return price;
      }
      set { 
        price = value; 
      }
    }

    public Laptop(string v, double p) {
      vendor = v; price = p;
    }

    public override string ToString() {
      return vendor + " " + price.ToString();
    }
  }

  public class Shop {
    private Laptop[] LaptopArr;
    public Shop(int size) {
      LaptopArr = new Laptop[size];
    }

    public int Length {
      get { 
        return LaptopArr.Length; 
      }
    }

    public Laptop this[int pos] {
      get {
        if (pos >= LaptopArr.Length || pos < 0) {
          throw new IndexOutOfRangeException();
        }
        else
            return (Laptop)LaptopArr[pos];
      }
      set
      {
          LaptopArr[pos] = (Laptop)value;
      }
    }
  }

  public class Tester {
    public static void Main() {
      Shop sh = new Shop(3);
      sh[0] = new Laptop("Samsung", 5200);
      sh[1] = new Laptop("Asus", 4700);
      sh[2] = new Laptop("LG", 4300);

      try {
        for (int i = 0; i < sh.Length; i++) {
          Console.WriteLine(sh[i].ToString());
        }
        Console.WriteLine();
      }

      catch (System.NullReferenceException) { 
      }
    }
  }
}
```
