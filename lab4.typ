#import "conf/conf.typ": conf

#show: conf.with(
  title: [= Лабораторная работа №4
  Классы и объекты],
  type: "pract",
  info: (
    author: (
      name: [],
      faculty: [],
      group: "",
      sex: "",
    ),
    inspector: (
      degree: "",
      name: "",
    ),
  ),
  settings: (
    title_page: (
      enabled: true,
    ),
    contents_page: (
      enabled: true,
    ),
  ),
)

= Часть 1. Индексаторы

*Цель работы*:
познакомиться с основой объектного подхода в языке C\#, с использованием индексаторов.

== Теория

Индексатор представляет собой разновидность свойства. 
Если у класса есть скрытое поле, представляющее собой массив, то с помощью индексатора можно обратиться к элементу этого массива, используя имя объекта и номер элемента массива в квадратных скобках.

Синтаксис индексатора аналогичен синтаксису свойства:

`<уровень доступа> <тип>this [список_параметров] { get { код_доступа} set { код_доступа} }`

Индексаторы чаще всего объявляются спецификатором `public`, поскольку они входят в интерфейс объекта.

Код доступа представляет собой блоки операторов, которые выполняются при получении (`get`) или установке значения (`set`) элемента массива. 
Может отсутствовать либо часть `get`, либо `set`, но не обе одновременно.
Если отсутствует часть `set`, индексатор доступен только для чтения (read-only), если отсутствует часть `get`, индексатор доступен только для записи (write-only).

Синтаксически чтение и запись индексатора выглядят почти как методы. 
Метод `get` должен содержать оператор `return`, возвращающий выражение, для типа которого должно существовать неявное преобразование к типу свойства. 
В методе `set` используется параметр со стандартным именем `value`, который содержит устанавливаемое значение.

Список параметров содержит одно или несколько описаний индексов, по которым выполняется доступ к элементу.
Чаще всего используется один индекс целого типа.
Однако, C\# не ограничивает тип индексатора типом `int`.
Например, может оказаться полезным использование в индексаторе строки.
Такой индексатор можно реализовать, выполнив поиск строки в коллекции и возвратив соответствующее значением. 
Методы доступа можно перегружать, версии типа `string` и `int` могут сосуществовать.

Индексаторы могут иметь более одного формального параметра, например, при доступе к двухмерному массиву.

=== Пример. Работа с индексатором

*Задание*.
Создайте объект класса `Rectangle`: "Большой прямоугольник" со сторонами 5 и 10; объявите поле "Имя" данного класса, а также поле "Размеры сторон", содержащее информацию о размерах всех сторонах прямоугольника. 
Организуйте доступ к полю "Имя" посредством свойства, а к полю "Размеры сторон" посредством индексатора.

*Решение*.

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MyConsoleApplication {

  // Объявление класса
  public class Rectangle {

    // Члены класса:
    // Поля.
    private string Name;

    // Объявляем массив с двумя элементами
    private int[] Side = new int[2];  

    // Индексатор с целочисленным параметром (индексом)
    public int this[int index] {
      get {
        return Side[index];
      }
      set {
        Side[index] = value;
      }
    }

     // Конструктор с аргументами
    public Rectangle(string name, int SideA, int SideB) {
      Side[0] = SideA;
      Side[1] = SideB;
      Name = name;
    }
    
    // Свойства
    // Только для чтения
    public int Perimeter {
      get {return (Side[0] + Side[1]) * 2; }
    }

    // Для чтения и для записи
    public string Name {
      set { 
        Name = value;
      }
      get { 
        return Name; 
      }
    }
  
  }

  class Program {
    static void Main(string[] args) {     
      // Создание объекта на основе класса Rectangle (Большой прямоугольник со сторонами 5 и 10)
      Rectangle myRectangle = new Rectangle("Большой прямоугольник", 5, 10);

      // Выведем свойства фигуры и её имя
      Console.WriteLine(myRectangle.Name);

      // Длины сторон (до изменения)
      Console.WriteLine(myRectangle[0]);
      Console.WriteLine(myRectangle[1]);
      Console.ReadKey();
      
      // Изменим длины сторон прямоугольника
      myRectangle[0] = 10;
      myRectangle[1] = 20;

      // Выведем свойства фигуры
      // Длины сторон (после изменения)
      Console.WriteLine(myRectangle[0]);
      Console.WriteLine(myRectangle[1]);
      Console.ReadKey();

      // Значение периметра
      Console.WriteLine(myRectangle.Perimeter);
      Console.ReadKey();
    }
  }
}
```

Индексаторы очень удобно применять для создания специализированных массивов, на работу с которыми накладываются какие-либо ограничения.
Кроме того, при доступе к элементу проверяется, не вышел ли индекс за допустимые границы.

=== Пример

Класс Треугольник. Поля --- длины сторон (целые числа).

```cs
// Индексатор, при значении 0 вернём длину стороны а, при 1 - стороны b, при 3 - стороны с
public string this[string i] {
  get {
    // switch - позволяет выбирать продолжение алгоритма из нескольких разделов, в скобках указывается условие выбора 
    switch (i) {
      // case - ключевое слово, после которого указывается какое либо значение условия выбора при switch
      case "0": return Convert.ToString(this.a); 
      case "1": return Convert.ToString(this.b);
      case "2": return Convert.ToString(this.c);

      // Дефолтное продолжение алгоритма (если не подошло ни к одному из значений case) 
      // В нашем случае генерируется исключение (throw new Exception)
      default: throw new Exception("i не принадлежит 0, 1 или 2"); 
    }
  }
}
```

=== Пример

Предположим, есть некий магазин, занимающийся реализацией ноутбуков.
Эта ситуация отображается при помощи двух классов: класса `Shop`, изображающего магазин, и класса `Laptop`, изображающего его продукцию. 
Дабы не перегружать пример лишней информацией, снабдим класс `Laptop` только двумя полями: `vendor` --- для отображения имени фирмы-производителя, а также `price` --- для отображения цены ноутбука. 
Класс будет включать соответствующие открытые свойства `Vendor` и `Price`, конструктор с двумя параметрами, а также переопределённый метод `ToString()` для отображения информации по конкретной единице товара.
В качестве единственного поля класса `Shop` выступает ссылка на массив объектов `Laptop`.
В конструкторе с одним параметром задаётся количество элементов массива и выделяется память для их хранения. 
Далее нам нужно сделать возможным обращение к элементам этого массива через экземпляр класса `Shop`, пользуясь синтаксисом массива так, словно класс `Shop` и есть массив элементов типа `Laptop`. 
Для этого добавим в класс `Shop` индексатор:

```cs
public Laptop this[int pos] {
  get {
    if (pos >= LaptopArr.Length ||  pos < 0) {
      throw new IndexOutOfRangeException();
    } else {
      return (Laptop)LaptopArr[pos];
    }

  set { 
    LaptopArr[pos] = (Laptop)value; 
  }
}
```

Здесь в аксессоре `get` мы предусматриваем выход за пределы массива, и при этом генерируется исключение `IndexOutOfRangeException`.

Для проверки работы классов создаётся отдельный класс `Tester`, содержащий точку входа.
В нём создаётся экземпляр класса `Shop`, причём в конструкторе задается количество элементов, которые в нём можно разместить.

```cs
Shop sh = new Shop(3);
```
Далее мы заполняем этот массив объектами `Laptop`.

```
sh[0] = new Laptop("Samsung", 5200);
sh[1] = new Laptop("Asus", 4700); 
sh[2] = new Laptop("LG", 4300);
```

И, наконец, вывод на экран данных по каждому объекту `Laptop`, пользуясь синтаксисом массива.

```cs
for (int i = 0; i < 3; i++) {
  Console.WriteLine(sh[i].ToString());
}
```

В цикле ограничивающим значением в условии является явно заданное число 3.
Дело в том, что индексатор позволяет нам пользоваться лишь синтаксисом индексирования массива, но других функциональных возможностей массива не предоставляет.
Если это был бы стандартный массив, то это условие описывается иначе:

```cs
for (int i = 0; i < sh.Length; i++) {
  ...
}
```

Для того, чтобы подобная функциональная возможность появилась и в примере, необходимо добавить в класс `Shop` дополнительное свойство `Length`.

```cs
public int Length {
  get { 
    return LaptopArr.Length; 
  }
}
```

Общий вид программы:

```cs
namespace MyConsoleApplication {
  public class Laptop {
    private string vendor;
    private double price;

    public string Vendor {
      get { 
        return vendor; 
      }
      set {
        vendor = value;
      }
    }

    public double Price {
      get { 
        return price;
      }
      set { 
        price = value; 
      }
    }

    public Laptop(string v, double p) {
      vendor = v; price = p;
    }

    public override string ToString() {
      return vendor + " " + price.ToString();
    }
  }

  public class Shop {
    private Laptop[] LaptopArr;
    public Shop(int size) {
      LaptopArr = new Laptop[size];
    }

    public int Length {
      get { 
        return LaptopArr.Length; 
      }
    }

    public Laptop this[int pos] {
      get {
        if (pos >= LaptopArr.Length || pos < 0) {
          throw new IndexOutOfRangeException();
        }
        else
            return (Laptop)LaptopArr[pos];
      }
      set
      {
          LaptopArr[pos] = (Laptop)value;
      }
    }
  }

  public class Program {
    public static void Main() {
      Shop sh = new Shop(3);
      sh[0] = new Laptop("Samsung", 5200);
      sh[1] = new Laptop("Asus", 4700);
      sh[2] = new Laptop("LG", 4300);

      try {
        for (int i = 0; i < sh.Length; i++) {
          Console.WriteLine(sh[i].ToString());
        }
        Console.WriteLine();
      }

      catch (System.NullReferenceException) { 
      }
    }
  }
}
```

#figure(
  image(
    "lab4_imports/images/example.png",
    width: 80%,
  ),
  caption: [Результат выполнения программы],
)

== Создание многомерныx индексаторов

В C\# есть возможность создавать не только одномерные, но и многомерные индексаторы.
Это возможно, если класс-контейнер содержит в качестве поля массив с более чем одним измерением.

=== Пример использования многомерного индексатора

```cs
namespace MyConsoleApplication {
  public class A {
    private int[,] arr;

    private int rows, cols;
    public int Rows {
      get { 
        return rows; 
      }
    }
    public int Cols {
      get {
        return cols; 
      }
    }

    public A(int rows, int cols) {
      this.rows = rows; this.cols = cols;
      arr = new int[rows, cols];
    }

    public int this[int r, int c] {
      get {
        return arr[r, c]; 
      }
      set {
        arr[r, c] = value; 
      }
    }
  }

  public class Program {
    static void Main() {
      A obj = new A(2, 3);

      for (int i = 0; i < obj.Rows; i++) {
        for (int j = 0; j < obj.Cols; j++) {
          obj[i, j] = i + j;
          Console.Write(obj[i, j].ToString());
        }
        Console.WriteLine();
      }
    }
  }
}
```

== Задание для самостоятельной работы

1.	Используя решение задания, приведенного в лабораторной работе №3, дополните класс индексатором (одномерным, двумерным, строковым). 
2.	Создайте несколько экземпляров класса и продемонстрируйте работу индексатора.

== Контрольные вопросы

1. В каких случаях применение индексатора является целесообразным?
2. Каким образом осуществляется чтение и запись индексатора?

= Часть 2. Перегрузка операторов

*Цель работы*: 
ознакомиться с понятием перегрузки операторов в языке C\#.

== Введение в перегрузку операторов

Перегрузка операторов позволяет указать, как стандартные операторы будут использоваться с объектами класса. 

Требования к перегрузке операторов:
- перегрузка операторов должна выполняться открытыми статическими методами класса (спецификаторы `public static`);
- у метода-оператора тип возвращаемого значения или одного из параметров должен совпадать с типом, в котором выполняется перегрузка оператора;
- параметры метода-оператора не должны включать модификатор `out` и `ref`.

Невозможно изменить значение стандартных операций для стандартных типов данных.
#figure(
  caption: [Операторы, допускающие перегрузку.],
  table(
    columns: (auto, auto),
    align: left,
    table.header(
      [*Операторы*], [*Категория операторов*]
    ),

    [`-`], 	                            [Изменение знака переменной],
    [`!`],                             	[Операция логического отрицания],
    [`~`],                              [Операция побитового дополнения, которая приводит к инверсии каждого бита],
    [`++`, `--`],                       [Инкремент и декремент],
    [`true`, `false`],	                [Критерий истинности объекта, определяется разработчиком класса],
    [`+`, `–`, `*`, `/`, `%`],        	[Арифметические операторы],
    [`&`, `|`, `^`, `<<`, `>>`],       	[Битовые операции],
    [`==`, `!=`, `<`, `>`, `<=`, `>=`],	[Операторы сравнения],
    [`&&`, `||`],	                    [Логические операторы],
    [`[]`],                             [Операции доступа к элементам массивов моделируются за счет индексаторов],
    [`()`],                            	[Операции преобразования],
    )
) <table1>

#figure(
  caption: [Операторы, не допускающие перегрузку.],
  table(
    columns: (auto, auto),
    align: left,
    table.header(
      [*Операторы*], [*Категория операторов*]),
      [`+=`, `–=`, `*=`, `/=`, `%=`,
      `&=`, `|=`, `^=`, `<<=`, `>>=`],	[Перегружаются автоматически при перегрузке соответствующих бинарных операций],
      [`=`],	                        [Присвоение],
      [`.`],                        	[Доступ к членам типа],
      [`?:`],                         	[Оператора условия],
      [`new`],	                        [Создание объекта],
      [`as`, `is`, `typeof`],       	[Используются для получения информации о типе],
      [`–>`, `sizeof`, `*`, `&`],   	[Доступны только в небезопасном коде]
    ),
) <table2>


Перегрузка операторов имеет некоторые ограничения:
- перегрузка не может изменить приоритет операторов;
- при перегрузке невозможно изменить число операндов, с которыми работает оператор;
- не все операторы можно перегружать (см. таблицы @table1 и @table2).

Перегрузку операторов можно использовать как в классах, так и в структурах.

Поскольку перегруженные операторы являются статическими методами, они не получают указателя `this`, поэтому унарные операторы должны получать один параметр, бинарные два.

Синтаксис перегрузки:

`public static <тип результата> operator <символ операции> (параметры)`

== Перегрузка унарных операторов

Можно определять в классе следующие унарные операции:
`+`, `-`, `!`, `~`, `++`, `--`, `true`, `false`.

Синтаксис объявления унарной операции:

`тип operator унарная_операция ( параметр )`

Примеры заголовков унарных операций:

```cs
public static int operator +(MyObject m)
public static MyObject operator --(MyObject m) 
public static bool operator true(MyObject m)
```

Параметр, передаваемый в операцию, должен иметь тип класса, для которого она определяется. 
Операция должна возвращать:
- для операций `+`, `-`, `!` величину любого типа;
- для операций `++` и `--` величину типа класса, для которого она определяется;
- для операций `true` и `false` величину типа `bool`.

Операции не должны изменять значение передаваемого им операнда. 
Операция, возвращающая величину типа класса, для которого она определяется, должна создать новый объект этого класса, выполнить с ним необходимые действия и передать его в качестве результата.

=== Пример операторов инкремента, декремента и изменения знака

Класс `Point` описывает точку на плоскости, точка имеет координаты `x` и `y`.
Оператор `++` увеличивает обе координаты на 1, оператор `--` уменьшает, оператор `–` изменяет знак координат на противоположный.

```cs
namespace UnaryOperator {
  // Класс точки на плоскости - пример для перегрузки операторов 
  class CPoint {
    int x, y;
    public CPoint(int x, int y) { 
      this.x = x; 
      this.y = y; }

    // Перегрузка инкремента
    public static CPoint operator ++(CPoint s) { 
      s.x++;
      s.y++; 
      return s; 
    }

    // Перегрузка декремента
    public static CPoint operator --(CPoint s) { 
      s.x--;
      s.y--; 
      return s;
    }

    // Перегрузка оператора -
    public static CPoint operator -(CPoint s) {
      CPoint p = new CPoint(s.x, s.y);
      p.x = -p.x; 
      p.y = -p.y; 
      return p;
    }

    public override string ToString() {
      return string.Format("X = {0} Y = {1}", x, y); 
    }
  }

  class Program {
    static void Main() {
      CPoint p = new CPoint(10, 10);

      // Префиксная и постфиксная формы выполняются одинаково
      Console.WriteLine(++p); // x = 11, y = 11

      CPoint p1 = new CPoint(10, 10);
      Console.WriteLine(p1++); // x = 11, y=11

      Console.WriteLine(--p); // x = 10, y = 10 
      Console.WriteLine(-p);  // x = -10, y = -10
                              // После выполнения оператора
                              // состояние исходного объекта не изменилось 
      Console.WriteLine(p);   // x = 10, y = 10
    }
  }
}
```
