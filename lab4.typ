#import "conf/conf.typ": conf

#show: conf.with(
  title: [= Лабораторная работа №4
  Классы и объекты],
  type: "pract",
  info: (
    author: (
      name: [],
      faculty: [],
      group: "",
      sex: "",
    ),
    inspector: (
      degree: "",
      name: "",
    ),
  ),
  settings: (
    title_page: (
      enabled: true,
    ),
    contents_page: (
      enabled: true,
    ),
  ),
)

= Часть 1. Индексаторы

*Цель работы*:
познакомиться с основой объектного подхода в языке C\#, с использованием индексаторов.

== Теория

Индексатор представляет собой разновидность свойства. 
Если у класса есть скрытое поле, представляющее собой массив, то с помощью индексатора можно обратиться к элементу этого массива, используя имя объекта и номер элемента массива в квадратных скобках.

Синтаксис индексатора аналогичен синтаксису свойства:

`<уровень доступа> <тип>this [список_параметров] { get { код_доступа} set { код_доступа} }`

Индексаторы чаще всего объявляются спецификатором `public`, поскольку они входят в интерфейс объекта.

Код доступа представляет собой блоки операторов, которые выполняются при получении (`get`) или установке значения (`set`) элемента массива. 
Может отсутствовать либо часть `get`, либо `set`, но не обе одновременно.
Если отсутствует часть `set`, индексатор доступен только для чтения (read-only), если отсутствует часть `get`, индексатор доступен только для записи (write-only).

Синтаксически чтение и запись индексатора выглядят почти как методы. 
Метод `get` должен содержать оператор `return`, возвращающий выражение, для типа которого должно существовать неявное преобразование к типу свойства. 
В методе `set` используется параметр со стандартным именем `value`, который содержит устанавливаемое значение.

Список параметров содержит одно или несколько описаний индексов, по которым выполняется доступ к элементу.
Чаще всего используется один индекс целого типа.
Однако, C\# не ограничивает тип индексатора типом `int`.
Например, может оказаться полезным использование в индексаторе строки.
Такой индексатор можно реализовать, выполнив поиск строки в коллекции и возвратив соответствующее значением. 
Методы доступа можно перегружать, версии типа `string` и `int` могут сосуществовать.

Индексаторы могут иметь более одного формального параметра, например, при доступе к двухмерному массиву.

=== Пример. Работа с индексатором

*Задание*.
Создайте объект класса `Rectangle`: "Большой прямоугольник" со сторонами 5 и 10; объявите поле "Имя" данного класса, а также поле "Размеры сторон", содержащее информацию о размерах всех сторонах прямоугольника. 
Организуйте доступ к полю "Имя" посредством свойства, а к полю "Размеры сторон" посредством индексатора.

*Решение*.

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MyConsoleApplication {

  // Объявление класса
  public class Rectangle {

    // Члены класса:
    // Поля.
    private string Name;

    // Объявляем массив с двумя элементами
    private int[] Side = new int[2];  

    // Индексатор с целочисленным параметром (индексом)
    public int this[int index] {
      get {
        return Side[index];
      }
      set {
        Side[index] = value;
      }
    }

     // Конструктор с аргументами
    public Rectangle(string name, int SideA, int SideB) {
      Side[0] = SideA;
      Side[1] = SideB;
      Name = name;
    }
    
    // Свойства
    // Только для чтения
    public int Perimeter {
      get {return (Side[0] + Side[1]) * 2; }
    }

    // Для чтения и для записи
    public string Name {
      set { 
        Name = value;
      }
      get { 
        return Name; 
      }
    }
  
  }

  class Program {
    static void Main(string[] args) {     
      // Создание объекта на основе класса Rectangle (Большой прямоугольник со сторонами 5 и 10)
      Rectangle myRectangle = new Rectangle("Большой прямоугольник", 5, 10);

      // Выведем свойства фигуры и её имя
      Console.WriteLine(myRectangle.Name);

      // Длины сторон (до изменения)
      Console.WriteLine(myRectangle[0]);
      Console.WriteLine(myRectangle[1]);
      Console.ReadKey();
      
      // Изменим длины сторон прямоугольника
      myRectangle[0] = 10;
      myRectangle[1] = 20;

      // Выведем свойства фигуры
      // Длины сторон (после изменения)
      Console.WriteLine(myRectangle[0]);
      Console.WriteLine(myRectangle[1]);
      Console.ReadKey();

      // Значение периметра
      Console.WriteLine(myRectangle.Perimeter);
      Console.ReadKey();
    }
  }
}
```

Индексаторы очень удобно применять для создания специализированных массивов, на работу с которыми накладываются какие-либо ограничения.
Кроме того, при доступе к элементу проверяется, не вышел ли индекс за допустимые границы.

=== Пример

Класс Треугольник. Поля --- длины сторон (целые числа).

```cs
// Индексатор, при значении 0 вернём длину стороны а, при 1 - стороны b, при 3 - стороны с
public string this[string i] {
  get {
    // switch - позволяет выбирать продолжение алгоритма из нескольких разделов, в скобках указывается условие выбора 
    switch (i) {
      // case - ключевое слово, после которого указывается какое либо значение условия выбора при switch
      case "0": return Convert.ToString(this.a); 
      case "1": return Convert.ToString(this.b);
      case "2": return Convert.ToString(this.c);

      // Дефолтное продолжение алгоритма (если не подошло ни к одному из значений case) 
      // В нашем случае генерируется исключение (throw new Exception)
      default: throw new Exception("i не принадлежит 0, 1 или 2"); 
    }
  }
}
```

=== Пример

Предположим, есть некий магазин, занимающийся реализацией ноутбуков.
Эта ситуация отображается при помощи двух классов: класса `Shop`, изображающего магазин, и класса `Laptop`, изображающего его продукцию. 
Дабы не перегружать пример лишней информацией, снабдим класс `Laptop` только двумя полями: `vendor` --- для отображения имени фирмы-производителя, а также `price` --- для отображения цены ноутбука. 
Класс будет включать соответствующие открытые свойства `Vendor` и `Price`, конструктор с двумя параметрами, а также переопределённый метод `ToString()` для отображения информации по конкретной единице товара.
В качестве единственного поля класса `Shop` выступает ссылка на массив объектов `Laptop`.
В конструкторе с одним параметром задаётся количество элементов массива и выделяется память для их хранения. 
Далее нам нужно сделать возможным обращение к элементам этого массива через экземпляр класса `Shop`, пользуясь синтаксисом массива так, словно класс `Shop` и есть массив элементов типа `Laptop`. 
Для этого добавим в класс `Shop` индексатор:

```cs
public Laptop this[int pos] {
  get {
    if (pos >= LaptopArr.Length ||  pos < 0) {
      throw new IndexOutOfRangeException();
    } else {
      return (Laptop)LaptopArr[pos];
    }

  set { 
    LaptopArr[pos] = (Laptop)value; 
  }
}
```

Здесь в аксессоре `get` мы предусматриваем выход за пределы массива, и при этом генерируется исключение `IndexOutOfRangeException`.

Для проверки работы классов создаётся отдельный класс `Tester`, содержащий точку входа.
В нём создаётся экземпляр класса `Shop`, причём в конструкторе задается количество элементов, которые в нём можно разместить.

```cs
Shop sh = new Shop(3);
```
Далее мы заполняем этот массив объектами `Laptop`.

```
sh[0] = new Laptop("Samsung", 5200);
sh[1] = new Laptop("Asus", 4700); 
sh[2] = new Laptop("LG", 4300);
```

И, наконец, вывод на экран данных по каждому объекту `Laptop`, пользуясь синтаксисом массива.

```cs
for (int i = 0; i < 3; i++) {
  Console.WriteLine(sh[i].ToString());
}
```

В цикле ограничивающим значением в условии является явно заданное число 3.
Дело в том, что индексатор позволяет нам пользоваться лишь синтаксисом индексирования массива, но других функциональных возможностей массива не предоставляет.
Если это был бы стандартный массив, то это условие описывается иначе:

```cs
for (int i = 0; i < sh.Length; i++) {
  ...
}
```

Для того, чтобы подобная функциональная возможность появилась и в примере, необходимо добавить в класс `Shop` дополнительное свойство `Length`.

```cs
public int Length {
  get { 
    return LaptopArr.Length; 
  }
}
```

Общий вид программы:

```cs
namespace MyConsoleApplication {
  public class Laptop {
    private string vendor;
    private double price;

    public string Vendor {
      get { 
        return vendor; 
      }
      set {
        vendor = value;
      }
    }

    public double Price {
      get { 
        return price;
      }
      set { 
        price = value; 
      }
    }

    public Laptop(string v, double p) {
      vendor = v; price = p;
    }

    public override string ToString() {
      return vendor + " " + price.ToString();
    }
  }

  public class Shop {
    private Laptop[] LaptopArr;
    public Shop(int size) {
      LaptopArr = new Laptop[size];
    }

    public int Length {
      get { 
        return LaptopArr.Length; 
      }
    }

    public Laptop this[int pos] {
      get {
        if (pos >= LaptopArr.Length || pos < 0) {
          throw new IndexOutOfRangeException();
        }
        else
            return (Laptop)LaptopArr[pos];
      }
      set
      {
          LaptopArr[pos] = (Laptop)value;
      }
    }
  }

  public class Program {
    public static void Main() {
      Shop sh = new Shop(3);
      sh[0] = new Laptop("Samsung", 5200);
      sh[1] = new Laptop("Asus", 4700);
      sh[2] = new Laptop("LG", 4300);

      try {
        for (int i = 0; i < sh.Length; i++) {
          Console.WriteLine(sh[i].ToString());
        }
        Console.WriteLine();
      }

      catch (System.NullReferenceException) { 
      }
    }
  }
}
```

#figure(
  image(
    "lab4_imports/images/example.png",
    width: 80%,
  ),
  caption: [Результат выполнения программы],
)

== Создание многомерныx индексаторов

В C\# есть возможность создавать не только одномерные, но и многомерные индексаторы.
Это возможно, если класс-контейнер содержит в качестве поля массив с более чем одним измерением.

=== Пример использования многомерного индексатора

```cs
namespace MyConsoleApplication {
  public class A {
    private int[,] arr;

    private int rows, cols;
    public int Rows {
      get { 
        return rows; 
      }
    }
    public int Cols {
      get {
        return cols; 
      }
    }

    public A(int rows, int cols) {
      this.rows = rows; this.cols = cols;
      arr = new int[rows, cols];
    }

    public int this[int r, int c] {
      get {
        return arr[r, c]; 
      }
      set {
        arr[r, c] = value; 
      }
    }
  }

  public class Program {
    static void Main() {
      A obj = new A(2, 3);

      for (int i = 0; i < obj.Rows; i++) {
        for (int j = 0; j < obj.Cols; j++) {
          obj[i, j] = i + j;
          Console.Write(obj[i, j].ToString());
        }
        Console.WriteLine();
      }
    }
  }
}
```

== Задание для самостоятельной работы

1.	Используя решение задания, приведенного в лабораторной работе №3, дополните класс индексатором (одномерным, двумерным, строковым). 
2.	Создайте несколько экземпляров класса и продемонстрируйте работу индексатора.

== Контрольные вопросы

1. В каких случаях применение индексатора является целесообразным?
2. Каким образом осуществляется чтение и запись индексатора?

= Часть 2. Перегрузка операторов

*Цель работы*: 
ознакомиться с понятием перегрузки операторов в языке C\#.

== Введение в перегрузку операторов

Перегрузка операторов позволяет указать, как стандартные операторы будут использоваться с объектами класса. 

Требования к перегрузке операторов:
- перегрузка операторов должна выполняться открытыми статическими методами класса (спецификаторы `public static`);
- у метода-оператора тип возвращаемого значения или одного из параметров должен совпадать с типом, в котором выполняется перегрузка оператора;
- параметры метода-оператора не должны включать модификатор `out` и `ref`.

Невозможно изменить значение стандартных операций для стандартных типов данных.
#figure(
  caption: [Операторы, допускающие перегрузку.],
  table(
    columns: (auto, auto),
    align: left,
    table.header(
      [*Операторы*], [*Категория операторов*]
    ),

    [`-`], 	                            [Изменение знака переменной],
    [`!`],                             	[Операция логического отрицания],
    [`~`],                              [Операция побитового дополнения, которая приводит к инверсии каждого бита],
    [`++`, `--`],                       [Инкремент и декремент],
    [`true`, `false`],	                [Критерий истинности объекта, определяется разработчиком класса],
    [`+`, `–`, `*`, `/`, `%`],        	[Арифметические операторы],
    [`&`, `|`, `^`, `<<`, `>>`],       	[Битовые операции],
    [`==`, `!=`, `<`, `>`, `<=`, `>=`],	[Операторы сравнения],
    [`&&`, `||`],	                    [Логические операторы],
    [`[]`],                             [Операции доступа к элементам массивов моделируются за счет индексаторов],
    [`()`],                            	[Операции преобразования],
    )
) <table1>

#figure(
  caption: [Операторы, не допускающие перегрузку.],
  table(
    columns: (auto, auto),
    align: left,
    table.header(
      [*Операторы*], [*Категория операторов*]),
      [`+=`, `–=`, `*=`, `/=`, `%=`,
      `&=`, `|=`, `^=`, `<<=`, `>>=`],	[Перегружаются автоматически при перегрузке соответствующих бинарных операций],
      [`=`],	                        [Присвоение],
      [`.`],                        	[Доступ к членам типа],
      [`?:`],                         	[Оператора условия],
      [`new`],	                        [Создание объекта],
      [`as`, `is`, `typeof`],       	[Используются для получения информации о типе],
      [`–>`, `sizeof`, `*`, `&`],   	[Доступны только в небезопасном коде]
    ),
) <table2>


Перегрузка операторов имеет некоторые ограничения:
- перегрузка не может изменить приоритет операторов;
- при перегрузке невозможно изменить число операндов, с которыми работает оператор;
- не все операторы можно перегружать (см. таблицы @table1 и @table2).

Перегрузку операторов можно использовать как в классах, так и в структурах.

Поскольку перегруженные операторы являются статическими методами, они не получают указателя `this`, поэтому унарные операторы должны получать один параметр, бинарные два.

Синтаксис перегрузки:

`public static <тип результата> operator <символ операции> (параметры)`

== Перегрузка унарных операторов

Можно определять в классе следующие унарные операции:
`+`, `-`, `!`, `~`, `++`, `--`, `true`, `false`.

Синтаксис объявления унарной операции:

`тип operator унарная_операция ( параметр )`

Примеры заголовков унарных операций:

```cs
public static int operator +(MyObject m)
public static MyObject operator --(MyObject m) 
public static bool operator true(MyObject m)
```

Параметр, передаваемый в операцию, должен иметь тип класса, для которого она определяется. 
Операция должна возвращать:
- для операций `+`, `-`, `!` величину любого типа;
- для операций `++` и `--` величину типа класса, для которого она определяется;
- для операций `true` и `false` величину типа `bool`.

Операции не должны изменять значение передаваемого им операнда. 
Операция, возвращающая величину типа класса, для которого она определяется, должна создать новый объект этого класса, выполнить с ним необходимые действия и передать его в качестве результата.

=== Пример операторов инкремента, декремента и изменения знака

Класс `Point` описывает точку на плоскости, точка имеет координаты `x` и `y`.
Оператор `++` увеличивает обе координаты на 1, оператор `--` уменьшает, оператор `–` изменяет знак координат на противоположный.

```cs
namespace UnaryOperator {
  // Класс точки на плоскости - пример для перегрузки операторов 
  class Point {
    int x, y;
    public Point(int x, int y) { 
      this.x = x; 
      this.y = y; }

    // Перегрузка инкремента
    public static Point operator ++(Point s) { 
      s.x++;
      s.y++; 
      return s; 
    }

    // Перегрузка декремента
    public static Point operator --(Point s) { 
      s.x--;
      s.y--; 
      return s;
    }

    // Перегрузка оператора -
    public static Point operator -(Point s) {
      Point p = new Point(s.x, s.y);
      p.x = -p.x; 
      p.y = -p.y; 
      return p;
    }

    public override string ToString() {
      return string.Format("X = {0}, Y = {1}", x, y); 
    }
  }

  class Program {
    static void Main() {
      Point p = new Point(10, 10);

      // Префиксная и постфиксная формы выполняются одинаково
      Console.WriteLine(++p); // x = 11, y = 11

      Point p1 = new Point(10, 10);
      Console.WriteLine(p1++); // x = 11, y=11

      Console.WriteLine(--p); // x = 10, y = 10 
      Console.WriteLine(-p);  // x = -10, y = -10
                              // После выполнения оператора
                              // состояние исходного объекта не изменилось 
      Console.WriteLine(p);   // x = 10, y = 10
    }
  }
}
```

#figure(
  image(
    "lab4_imports/images/example2.png",
    width: 80%,
  ),
  caption: [Результат выполнения программы],
)

В данном примере `Point` является ссылочным типом, поэтому изменения значений `x` и `y`, которые выполняются в перегруженных операторах инкремента и декремента, затрагивают переданный в них объект. 
Оператор `-` (изменение знака) не должен изменять состояние переданного объекта, а должен возвращать новый объект с измененным знаком. 
Для этого в реализации этого метода создается новый объект `Point`, изменяется знак его координат и этот объект возвращается из метода.

В C\# нет возможности выполнить отдельно перегрузку постфиксной и префиксной форм операторов инкремента и декремента.
Поэтому при вызове постфиксная и префиксная форма работают одинаково.

При перегрузке операторов `true` и `false` разработчик задает критерий истинности для своего типа данных. 
После этого объекты типа напрямую можно использовать в структуре операторов `if`, `do`, `while`, `for` в качестве условных выражений.

== Перегрузка бинарных операторов

Можно определять в классе следующие бинарные операции:
`+`, `-`, `*`, `/`, `%`, `&`, `<<`, `>>`, `==`, `!=`, `>`, `<`, `>=`, `<=`.

Синтаксис объявителя бинарной операции:

`тип operator бинарная_операция (параметр1, параметр2)`

Примеры заголовков бинарных операций:

```cs 
static MyObject operator +(MyObject ml, MyObject m2) 
static bool operator ==(MyObject ml, MyObject m2)
```

Хотя бы один параметр, передаваемый в операцию, должен иметь тип класса, для которого она определяется.
Операция может возвращать величину любого типа.

Операции `==` и `!=`, `>` и `<`, `>=` и `<=` определяются только парами и обычно возвращают логическое значение. 
Чаще всего в классе определяют операции сравнения на равенство и неравенство для того, чтобы обеспечить сравнение объектов, а не их ссылок, как определено по умолчанию для ссылочных типов.

=== Пример перегрузки бинарных операций

```cs
namespace BinaryOperator {
  class Vector {
    public int x; 
    public int y;

    public Vector(int x, int y) {
      this.x = x;
      this.y = y; 
    }

    public override string ToString() {
      return string.Format("Vector: X = {0}, Y = {1}", x, y); 
    }

  class Point {
    private int x;
    private int y;

    public Point(int x, int y) { 
      this.x = x; 
      this.y = y; 
    }

    // Перегрузка бинарного оператора +
    public static Point operator +(Point p, Vector v) { 
      return new Point(p.x + v.x, p.y + v.y);
    }

    // Перегрузка бинарного оператора *
    public static Point operator *(Point p, int a) { 
      return new Point(p.x * a, p.y * a); 
    }

    // Перегрузка бинарного оператора -
    public static Vector operator -(Point p1, Point p2) {
      return new Vector(p1.x - p2.x, p1.y - p2.y); 
    }

    public override string ToString() {
      return string.Format("Point: X = {0}, Y = {1}", x, y); 
    }
  }

  class Program {
    static void Main() {
      Point p1 = new Point(10, 10);
      Point p2 = new Point(12, 20);

      Vector v = new Vector(10, 20);

      Console.WriteLine("Точка p1: {0}", p1);
      Console.WriteLine("Сдвиг: {0}", p1 + v);
      Console.WriteLine("Масштабирование: {0}", p1 * 10);
      Console.WriteLine("Точка p2: {0}", p2);
      Console.WriteLine("Расстояние: {0}", p2 - p1);

      Console.ReadKey();
    }
  }
}
```

#figure(
  image(
    "lab4_imports/images/example3.png",
    width: 80%,
  ),
  caption: [Результат выполнения программы],
)

Выполненная перегрузка автоматически перегружает операторы `+=`, `*=`, `-=`.
Например, можно записать: 

`p1 += v;`

Для реализации этого действия будет использован перегруженный оператор `+`.

Однако перегруженные в примере операторы будут использоваться компилятором только если переменная типа `Point` находится слева от знака операнда.
Т.е. выражение `p * 10` скомпилируется нормально, а при перестановке сомножителей, т.е. в выражении `10 * p` произойдет ошибка компиляции.
Для исправления этой ошибки следует перегрузить оператор `*` с другим порядком операндов:

```cs
public static Point operator *(int a, CPoint p) {
  return p * a; 
}
```

При перегрузке операторов отношения надо учитывать, что есть два способа проверки равенства:
- равенство ссылок (тождество);
- равенство значений.

В классе `Object` определены следующие методы сравнения объектов: 

```cs
public static bool ReferenceEquals(Object obj1, Object obj2)
public bool virtual Equals(Object obj)
```

Есть отличия в работе этих методов со значимыми и ссылочными типами.

Метод `ReferenceEquals()` проверяет, указывают ли две ссылки на один и тот же экземпляр класса; точнее --- содержат ли две ссылки один и тот адрес памяти.
Этот метод невозможно переопределить. Со значимыми типами `ReferenceEquals()` всегда возвращает `false`, т.к. при сравнении выполняется приведение к `Object` и упаковка, упакованные объекты располагаются по разным адресам.

Метод `Equals()` является виртуальным. 
Его реализация в `Object` выполняется проверку равенства ссылок, т.е. работает так же как и `ReferenceEquals`.
Для значимых типов в базовом типе `System.ValueType` выполнена перегрузка метода `Equals()`, которая выполняет сравнение объектов путем сравнения всех полей (побитовое сравнение).

=== Пример использования операторов `ReferenceEquals()` и `Equals()` со ссылочными и значимыми типами:

```cs
namespace Equals_and_ReferenceEquals {
  class CPoint {
    private int x, y;
    public CPoint(int x, int y) {
      this.x = x; 
      this.y = y; 
    }
  }

  struct SPoint {
    private int x, y;
    public SPoint(int x, int y) {
      this.x = x; 
      this.y = y;
    }
  }

  class Program {
    static void Main() {
      // Работа метода ReferenceEquals с ссылочным и значимым типами

      // Ссылочный тип
      CPoint p = new CPoint(0, 0);
      CPoint p1 = new CPoint(0, 0);
      CPoint p2 = p1;
      Console.WriteLine("ReferenceEquals(p, p1) = {0}", ReferenceEquals(p, p1)); // false
      // Хотя p и p1 содержат одинаковые значения,
      // они указывают на разные адреса памяти 

      Console.WriteLine("ReferenceEquals(p1, p2) = {0}", ReferenceEquals(p1, p2)); // true
      // p1 и p2 указывают на один и тот же адрес памяти

      // Значимый тип
      SPoint p3 = new SPoint(0, 0);
      Console.WriteLine("ReferenceEquals(p3, p3) = {0}", ReferenceEquals(p3, p3)); // false
      // при передаче в метод ReferenceEquals выполняется упаковка,
      // упакованные объекты располагаются по разным адресам 

      // Работа метода Equals с ссылочным и значимым типами

      // Ссылочный тип
      CPoint cp = new CPoint(0, 0); CPoint cp1 = new CPoint(0, 0);
      Console.WriteLine("Equals(cp, cp1) = {0}", Equals(cp, cp1)); // false
      // Выполняется сравнение адресов

      // Значимый тип 
      SPoint sp = new SPoint(0, 0);
      SPoint sp1 = new SPoint(0, 0);
      Console.WriteLine("Equals(sp, sp1) = {0}", Equals(sp, sp1)); // true
      // Выполняется сравнение значений полей
    }
  }
}
```

#figure(
  image(
    "lab4_imports/images/example4.png",
    width: 80%,
  ),
  caption: [Результат выполнения программы],
)

При создании собственного типа оператор `Equals()` можно перегрузить.
Для ссылочных типов перегрузку следует выполнять, только если тип представляет собой неизменяемый объект. Например, для типа `String`, который содержит в себе неизменную строку, имеется перегруженный метод `Equals()` и оператор `==`.

Поскольку в `System.ValueType` перегруженный метод `Equals()` выполняет побитовое сравнение, то в собственных значимых типах его можно не перегружать. 
Однако, в `System.ValueType` получение значений полей для сравнения в методе `Equals()` выполняется с помощью рефлексии, что приводит к снижению производительности. 
Поэтому при разработке значимого типа для увеличения быстродействия рекомендуется выполнить перегрузку метода `Equals()`.

При перегрузке метода `Equals()` следует также перегружать метод `GetHashCode()`.
Этот метод предназначен для получения целочисленного значения хеш-кода объекта. 
Причем, различным (т.е. не равным между собой) объектам должны соответствовать различные хеш-коды.
Если перегрузку метода ёGetHashCode()ё не выполнить возникнет предупреждение компилятора.

Перегрузка оператора `==` обычно выполняется путем вызова метода `Equals()`.

Если предполагается сравнивать экземпляры собственного типа для целей сортировки, рекомендуется унаследовать этот тип от интерфейсов `System.IComparable` и `System.IComparable<T>` и реализовать метод `CompareTo()`.
В дальнейшем этот метод можно вызывать из реализации `Equals()` и возвращать `true`, если `CompareTo()` возвращает 0.

=== Пример перегрузки операторов `==` и `!=` для класса `Point` 

```cs 
namespace ComparisonOperator {
  class Point {
    int x, y;

    public Point(int x, int y) { 
      this.x = x;
      this.y = y;
    }

    // Перегрузка метода Equals
    public override bool Equals(object obj) {
      // Если obj == null,
      // Значит он не равен объекту, от имени которого вызывается этот метод
      if (obj == null) {
        return false;
      } 

      Point p = obj as Point;
      // Переданный объект не является ссылкой на Point 
      if (p == null) {
        return false;
      }

      // Проверяется равенство содержимого 
      return ((x == p.x) && (y == p.y));
    }

    //При перегрузке Equals надо также перегрузить GetHashCode()
    public override int GetHashCode() {
      return x ^ y; // использование XOR для получения хеш-кода
    }

    public static bool operator ==(Point p1, Point p2) {
      // Проверка, что переменные ссылаются на один и тот же адрес
      // Сравнение p1 == p2 приведет к бесконечной рекурсии 
      if (ReferenceEquals(p1, p2)) {
        return true;
      } 

      // Приведение к object необходимо,
      // т.к. сравнение p1 == null приведет к бесконечной рекурсии 
      if ((object)p1 == null) {
        return false;
      }

      return p1.Equals(p2);
    }

    public static bool operator !=(Point p1, Point p2) {
      return (!(p1 == p2)); 
    }
  }

  class Program {
    static void Main() {
      Point cp = new Point(0, 0);
      Point cp1 = new Point(0, 0);
      Point cp2 = new Point(1, 1);
      Console.WriteLine("cp == cp1: {0}", cp == cp1); // true
      Console.WriteLine("cp == cp1: {0}", cp == cp2); // false
    }
  }
}
```

#figure(
  image(
    "lab4_imports/images/example5.png",
    width: 80%,
  ),
  caption: [Результат выполнения программы],
)

Условные логические операторы `&&` и `||` нельзя перегрузить, но они вычисляются с помощью `&` и `|`, допускающих перегрузку.

== Перегрузка операторов преобразования типа 

Операции преобразования типа обеспечивают возможность явного и неявного преобразования между пользовательскими типами данных. 
Синтаксис объявителя операции преобразования типа:

```cs 
implicit operator тип ( параметр ) // Неявное преобразование 
explicit operator тип ( параметр ) // Явное преобразование
```

Эти операции выполняют преобразование из типа параметра в тип, указанный в заголовке операции. 
Одним из этих типов должен быть класс, для которого определяется операция. 
Таким образом, операции выполняют преобразования либо типа класса к другому типу, либо наоборот.
Преобразуемые типы не должны быть связаны отношениями наследования.

Явное приведение типов требуется, если возможна потеря данных в результате приведения. Например:
- при преобразовании `int` в `short`, потому что размер `short` недостаточен для сохранения значения `int`;
- при преобразовании типов данных со знаком в беззнаковые может быть получен неверный результат, если переменная со знаком содержит отрицательное значение;
- при конвертировании типов с плавающей точкой в целые дробная часть теряется;
- при конвертировании типа, допускающего значение `null`, в тип, не допускающий `null`, если исходная переменная содержит `null`, генерируется исключение.

Если потери данных в результате приведения не происходит приведение можно выполнять как неявное.

== Индивидуальные задания 

*Создайте класс с компонентами*:

1.
  1. `Point`. 
  2. Индексатор, позволяющий по индексу 0 обращаться к полю `x`, по индексу 1 --- к полю `y`, при других значениях индекса выдается сообщение об ошибке.
  3. Перегрузку:
    - операции `++` (`--`): одновременно увеличивает (уменьшает) значение полей `х` и `у` на 1;
    - констант `true` и `false`: обращение к экземпляру класса дает значение `true`, если значение полей `x` и `у` совпадает, иначе `false`;
    - операции бинарный `+`: одновременно добавляет к полям `х` и `у` значение скаляра.
  4. Преобразования типа `Point` в `string` (и наоборот).

2. 
  1. `Triangle`.
  2. Индексатор, позволяющий по индексу 0 обращаться к полю `a`, по индексу 1 --- к полю `b`, по индексу 2 --- к полю `c`, при других значениях индекса выдается сообщение об ошибке.
  3. Перегрузку:
    - операции `++` (`--`): одновременно увеличивает (уменьшает) значение полей `a`, `b` и `c` на 1;
    - констант `true` и `false`: обращение к экземпляру класса дает значение `true`, если треугольник с заданными длинами сторон существует, иначе `false`;
    - операции `*`: одновременно домножает поля `a`, `b` и `c` на скаляр.
  4. Преобразования типа `Triangle` в `string` (и наоборот).

3. 
  1. `Rectangle` 
  2. Индексатор, позволяющий по индексу 0 обращаться к полю `a`, по индексу 1 --- к полю `b`, при других значениях индекса выдается сообщение об ошибке.
  3. Перегрузку:
    - операции `++` (`--`): одновременно увеличивает (уменьшает) значение полей `a` и `b`;
    - констант `true` и `false`: обращение к экземпляру класса дает значение `true`, если прямоугольник с заданными длинами сторон является квадратом, иначе `false`;
    - операции `*`: одновременно домножает поля `a` и `b` на скаляр.  
  4. Преобразования типа `Rectangle` в `string` (и наоборот).

4.
  1. Класс для работы с одномерным массивом целых чисел.
  2. Индексатор, позволяющий по индексу обращаться к соответствующему элементу массива.
  3. Перегрузку:
    - операции `++` (`--`): одновременно увеличивает (уменьшает) значение всех элементов массива на 1;
    - операции `!`: возвращает значение `true`, если элементы массива не упорядочены по возрастанию, иначе `false`;
    - операции бинарный `*`: домножить все элементы массива на скаляр;
  4. Преобразования класса массив в одномерный массив (и наоборот).

5. 
  1. Класс для работы с двумерным массивом целых чисел.
  2.Двумерный индексатор, позволяющий обращаться к соответствующему элементу массива.
  3. Перегрузку:
    - операции `++` (`--`): одновременно увеличивает (уменьшает) значение всех элементов массива на 1;
    - констант `true` и `false`: обращение к экземпляру класса дает значение `true`, если двумерный массив является квадратным;
    - операции бинарный `+`: позволяющей сложить два массива соответствующих размерностей;
  4. Преобразования класса массив в двумерный массив (и наоборот).

6.
  1. Класс для работы с двумерным массивом вещественных чисел.
  2. Двумерный индексатор, позволяющий обращаться к соответствующему элементу массива.
  3. Перегрузку:
    - операции `++` (`--`): одновременно увеличивает (уменьшает) значение всех элементов массива на 1;
    - констант `true` и `false`: обращение к экземпляру класса дает значение true, если каждая строка массива упорядочена по возрастанию, иначе `false`;
    - операции `*`: позволяющей умножить два массива соответствующих размерностей.
  4. Преобразования класса массив в ступенчатый массив (и наоборот).

7. 
  1. Класс для работы со строками.
  2. Индексатор, позволяющий по индексу обращаться к соответствующему символу строки.
  3. Перегрузку:
    - операции унарного `+` (`-`): преобразующей строку к строчным (прописным) символам;
    - констант `true` и `false`: обращение к экземпляру класса дает значение `true`, если строка не пустая, иначе `false`.
    - операции `&`: возвращает значение `true`, если строковые поля двух объектов посимвольно равны (без учета регистра), иначе `false`;
  4. Преобразования класса-строки в тип `string` (и наоборот).

8.
  1. Добавить в класс для работы с регулярными выражениями.
  2. Индексатор, позволяющий по индексу 0 обращаться к полю `r` (само регулярное выражение), по индексу 1 --- к полю `text` (обрабатываемый текст), при других значениях индекса выдается сообщение об ошибке.
  3. Перегрузку:
    - операции унарного `-`: удаляет из поля `text` все фрагменты, соответствующие регулярному выражению поля `r`;
    - констант `true` и `false`: обращение к экземпляру класса дает значение `true`, если поле `text` не пустое, иначе `false`;
    - операции бинарного `+`: дописывает в конец поля `text` строку.
Преобразования класса `Regex` в тип `string` (и наоборот).

9.
  1. Класс для работы с датой.
  2. Индексатор, позволяющий определить дату `i`-того по счету дня относительно установленной даты (при отрицательных значениях индекса отсчет ведется в обратном порядке, рекомндуется использовать тип `DateTime`).
  3. Перегрузку:
    - операции `!`: возвращает значение `true`, если установленная дата не является последним днем месяца, иначе `false`;
    - констант `true` и `false`: обращение к экземпляру класса дает значение `true`, если установленная дата является началом года, иначе `false`;
    - операции `&`: возвращает значение `true`, если поля двух объектов равны, иначе `false`.
  4. Преобразования класса `DateTime` в тип `string` (и наоборот).

Вариантам 10 и далее соответствует задание по модулю 10 + 1. 

Так, например варианту 10 соответствует задание 1, варианту 11 сооветствует задание 2 и т.д.

= Часть 3. Наследование, виртуальные методы и свойства, полиморфизм и абстрактные классы

*Цель работы*:
Познакомиться с реализацией принципа наследования на языке С\#, с использованием виртуальных методов и свойств, абстрактных и бесплодных классов, с реализацией принципа полиморфизма на языке С\#.

== Теория

Мы уже отмечали, что "наследование" является одной из основных характеристик (или базовых понятий) объектно-ориентированного программирования, это механизм, который дает возможность создавать новый (производный) класс на основе определения уже существующего (базового) класса.

С помощью механизма наследования производный класс наследует все свойства и поведение (все методы и свойства интерфейса базового класса автоматически появляются в интерфейсе производного класса), представленные в базовом классе, при этом позволяя расширять их и изменять.

Производный класс может иметь только один непосредственный базовый класс. 
Однако наследование является транзитивным.
Если `ClassC` является производным от `ClassB`, и `ClassB` является производным от `ClassA`, `ClassC` наследует члены, объявленные в `ClassB` и `ClassA`.

Наследование применяется для следующих взаимосвязанных целей:
- исключения из программы повторяющихся фрагментов кода;
- упрощения модификации программы;
- упрощения создания новых программ на основе существующих.

При описании класса имя его базового класса записывается в заголовке класса после двоеточия (если имя предка не указано, предком считается базовый класс всей иерархии `System.Object`):

```cs
[уровень доступа] class <имя производного класса>:<имя базового класса> {
  // Описание членов класса
}
```

Поля, методы и свойства класса наследуются, поэтому при желании заменить элемент базового класса новым элементом следует явным образом указать компилятору свое намерение с помощью ключевого слова `new`.
Соответственно синтаксис для полей, свойств и методов выглядит следующим образом:

```cs
new <уровень доступа> <тип переменной> <имя переменной>;
new <уровень доступа> <тип><имя свойства > { get { код_доступа} set { код_доступа} }
new <уровень доступа> <возвращаемый тип><имя метода > (<список параметров>){тело_метода}
```

Из производного класса можно получить доступ к открытым (`public`), защищенным (`protected`), внутренним (`internal`) и защищенным внутренним (`protected internal`) членам базового класса.  

Хотя производный класс и наследует закрытые члены базового класса, он не может получить доступ к этим членам.
Однако все эти закрытые члены все же присутствуют в производном классе и могут выполнять ту же работу, что и в самом базовом классе, например, если защищенный метод базового класса имеет доступ к закрытому полю, то это поле должно присутствовать в производном классе для правильной работы унаследованного метода базового класса.

Конструкторы не наследуются, поэтому производный класс должен иметь собственные конструкторы. Порядок вызова конструкторов определяется приведенными далее правилами:

1. Если в конструкторе производного класса явный вызов конструктора базового класса отсутствует, автоматически вызывается конструктор базового класса без параметров. 
2. Для иерархии, состоящей из нескольких уровней, конструкторы базовых классов вызываются, начиная с самого верхнего уровня. После этого выполняются конструкторы тех элементов класса, которые являются объектами, в порядке их объявления в классе, а затем исполняется конструктор класса. Таким образом, каждый конструктор инициализирует свою часть объекта. 
3. Если конструктор базового класса требует указания параметров, он должен быть явным образом вызван в конструкторе производного класса в списке инициализации. Вызов выполняется с помощью ключевого слова `base`. Вызывается та версия конструктора, список параметров которой соответствует списку аргументов, указанных после слова `base`.

=== Пример. Наследование

*Задание*. 

Создайте два класса:
1. `Shape` (базовый класс), предназначенный для создания на своей основе классов любых геометрических фигур, и обеспечивающий возможность чтения и записи их наименования; 
2. `Rectangle` (производный класс), предназначенный для описания состояния и поведения прямоугольников как геометрических фигур.

*Решение*.

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MyConsoleApplication {
  // Объявление класса "Фигура"
  public class Shape {
    // Члены класса:
    // Поля
    protected string Name;
    protected int SideA;
    protected int SideB;
    
    // Конструкторы
    public Shape(string name, int sideA, int sideB) {
      SideA = sideA; 
      SideB = sideB;
      Name = name;
    }

    // Свойства
    // Наименование фигуры
    public string Name {
      set {
        Name = value + " (неопределенная фигура)"; 
      }
      get {
        return Name; 
      }
    }
  }

  public class Rectangle : Shape {
    // Члены класса:

    // Конструкторы
    public Rectangle(string Name, int SideA, int SideB): base(Name,SideA,SideB) {}

    // Свойства
    // Свойство, дополняющее элементы базового класса  
    public int Perimeter {
      get { 
        return (SideA + SideB) * 2; 
      }
    }
    // Свойства
    // Свойство, заменяющее элемент базового класса  
    new public string Name { 
      set { 
        Name = value + " (прямоугольник)"; 
      }
      get { 
        return Name;
      }
    }
  }

  class Program {
    static void Main() {
      // Создание объекта на основе класса Rectangle (Большой прямоугольник со сторонами 5 и 10)
      Rectangle myRectangle = new Rectangle("Большой прямоугольник", 5, 10);

      // Выведем свойства фигуры
      // Имя 
      Console.WriteLine(myRectangle.Name);

      // Значение периметра
      Console.WriteLine(myRectangle.Perimeter);
      Console.ReadKey();
    }
  }
}
```

Во время разработки программы удобно оперировать объектами одной иерархии единообразно, то есть использовать один и тот же программный код для работы с экземплярами разных классов.
Желательно иметь возможность описать:
- объект, в который во время выполнения программы заносятся ссылки на объекты разных классов иерархии;
- контейнер, в котором хранятся объекты разных классов, относящиеся к одной иерархии;
- метод, в который могут передаваться объекты разных классов иерархии;
- метод, из которого в зависимости от типа вызвавшего его объекта вызываются соответствующие методы.

Все это возможно благодаря тому, что объекту базового класса в С\# можно присвоить объект производного класса, однако при этом для него вызываются только методы и свойства, определенные в базовом классе (см. пример ниже). 

=== Пример. Присвоение объекту базового класса объекта производного класса (пример несоответствия вызываемых методов типу объекта)

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MyConsoleApplication {
  // Объявление класса "Фигура"
  public class Shape {
    // Члены класса:
    // Поля
    protected string Name;

    public Shape() {
      Name = "Неопределенная фигура";
    }

    // Наименование фигуры
    public string Name {
      get { 
        return Name + " (неопределенная фигура)"; 
      }
    }
  }

  public class Rectangle : Shape {
    // Члены класса:
    // Конструкторы
    public Rectangle() {
      Name = "Прямоугольник";
    }
     
    // Свойство, заменяющее элемент базового класса
    new public string Name {
      get { 
        return Name; 
      }
    }
  }


  public class Circle : Shape {
    // Члены класса:
    // Конструкторы
    public Circle() {
      Name = "Окружность";
    }

    // Свойство, заменяющее элемент базового класса  
    new public string Name  {
      get { 
        return Name; 
      }
    }
  }


  class Program {
    static void Main() {
      // Создание объектов базового класса 
      // на основе производных класcов 
      Shape myShape1 = new Rectangle();
      Shape myShape2 = new Circle();

      // на основе базового класса
      Shape myShape3 = new Shape();

      // Выведем свойства фигуры
      // Имя 
      Console.WriteLine(myShape1.Name);
      Console.WriteLine(myShape2.Name);
      Console.WriteLine(myShape3.Name);
      Console.ReadKey();
      Console.WriteLine();

      // То же самое, но с использование массива
      Shape[] MyShape = new Shape[3];
      MyShape[0] = new Rectangle();
      MyShape[1] = new Circle();
      MyShape[2] = new Shape();

      foreach (Shape elem in MyShape) {
        Console.WriteLine(elem.Name);
      }
      Console.ReadKey();
    }
  }
}
```

Таким образом, возможность доступа к элементам класса определяется типом ссылки, а не типом объекта, на который она указывает.

Причина этого состоит в том, что компилятор еще до выполнения программы должен решить, какой метод вызывать, и вставить в код фрагмент, передающий управление на этот метод (этот процесс называется ранним связыванием).
При этом компилятор может руководствоваться только типом переменной, для которой вызывается метод или свойство. 
То, что в этой переменной в разные моменты времени могут находиться ссылки на объекты разных типов, компилятор учесть не может.

Следовательно, если мы хотим, чтобы вызываемые методы соответствовали типу объекта, необходимо отложить процесс связывания до этапа выполнения программы, а точнее --- до момента вызова метода, когда уже точно известно, на объект какого типа указывает ссылка.
Такой механизм в С\# есть --- он называется поздним связыванием и реализуется с помощью так называемых виртуальных методов.

Объявление метода виртуальным означает, что все ссылки на этот метод будут разрешаться по факту его вызова, то есть не на стадии компиляции, а во время выполнения программы.

Для обозначения виртуального метода и виртуального используется ключевое слово `virtual`, которое записывается в заголовке метода или свойства базового класса следующим образом:

```cs
virtual <уровень доступа> <тип><имя свойства> { get { код_доступа} set { код_доступа} }
virtual <уровень доступа> <возвращаемый тип><имя метода> (<список параметров>){тело_метода}
```

Если в производном классе требуется переопределить виртуальный метод или виртуальное свойство, используется ключевое слово `override`:

```cs
override <уровень доступа> <тип><имя свойства> { get { код_доступа} set { код_доступа} }
override <уровень доступа> <возвращаемый тип><имя метода> (<список параметров>){тело_метода}
```

=== Пример. Использование виртуальных методов (свойств)

*Задание*. 

Изменить программный код, приведенный в предыдущем примере, таким образом, чтобы вызываемые методы соответствовали типу объекта.

*Решение*.

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MyConsoleApplication {
  // Объявление класса "Фигура"
  public class Shape {
    // Члены класса
    // Поля.
    protected string Name;

    public Shape() {
      Name = "Неопределенная фигура";
    }

    // Наименование фигуры
    virtual public string Name  {
      get {
        return Name + " (неопределенная фигура)";
      }
    }
  }

  public class Rectangle : Shape {
    // Члены класса
    // Конструкторы
    public Rectangle() {
      Name = "Прямоугольник";
    }

    // свойство, заменяющее элемент базового класса  
    override public string Name {
      get { 
        return Name; 
      }
    }
  }


  public class Circle : Shape {
    // Члены класса
    // Конструкторы
    public Circle() {
      Name = "Окружность";
    }

    // Свойство, заменяющее элемент базового класса  
    override public string Name {
      get { 
        return Name;
      }
    }
  }

  class Program {
    static void Main() {
      Shape[] MyShape = new Shape[3];
      MyShape[0] = new Rectangle();
      MyShape[1] = new Circle();
      MyShape[2] = new Shape();
      foreach (Shape elem in MyShape) {
        Console.WriteLine(elem.Name);
      }
      Console.ReadKey();
    }
  }
}
```

Переопределенный виртуальный метод должен обладать таким же набором параметров, как и одноименный метод базового класса.
Это требование вполне естественно, если учесть, что одноименные методы
, относящиеся к разным классам, могут вызываться из одной и той же точки программы.

Виртуальные методы базового класса определяют интерфейс всей иерархии.
Этот интерфейс может расширяться в потомках за счет добавления новых виртуальных методов. 
Переопределять виртуальный метод в каждом из потомков не обязательно: если он выполняет устраивающие потомка действия, метод наследуется.

С помощью виртуальных методов реализуется один из основных принципов объектно-ориентированного программирования --- полиморфизм. 
Это слово в переводе с греческого означает "много форм", что в данном случае означает "один вызов --- много методов".
Применение виртуальных методов обеспечивает гибкость и возможность расширения функциональности класса (см. пример ниже).
При описании классов рекомендуется определять в качестве виртуальных те методы, которые в производных классах должны реализовываться по-другому.

Если во всех классах иерархии метод будет выполняться одинаково, его лучше определить как обычный метод.

Таким образом, при наследовании производный класс получает от базового класса все методы, поля, свойства и события базового класса.
При разработке производного класса можно поступить следующим образом:
- либо наследовать члены ближайшего базового класса без переопределения; 
- либо заменить реализацию отдельных членов производного класса, скрывая при этом их реализацию в базовом классе;
- либо переопределить виртуальные члены в базовом классе.

При создании иерархии объектов для исключения повторяющегося кода часто бывает логично выделить их общие свойства в один родительский класс. 
При этом может оказаться, что создавать экземпляры такого класса не имеет смысла, потому что никакие реальные объекты им не соответствуют.
Такие классы называют абстрактными. 

Абстрактный класс служит только для порождения потомков. 
Как правило, в нем задается набор методов, которые каждый из потомков будет реализовывать по-своему.
Абстрактные классы предназначены для представления общих понятий, которые предполагается конкретизировать в производных классах. 
При этом полученный базовый класс может представлять очень общую сущность, и создание экземпляров такого класса не будет иметь смысла. 
В этом случае класс объявляют как абстрактный (`abstract`) и в нём присутствуют абстрактные методы.

Класс называется абстрактным, если он имеет хотя бы один абстрактный метод.
Метод называется абстрактным, если при его определении задана его сигнатура, но не задана реализация метода.
Абстрактный метод представляет собой виртуальный метод, переопределяемый производными классами.

Объявление абстрактных классов и абстрактных методов должно сопровождаться модификатором `abstract`.

```cs
public abstract class Shape { 
  // ...
  public abstract void Draw();
  // ...
}
```

Модификатор `abstract` может применяться только в методах экземпляра, но не в статических методах.

Поскольку абстрактные классы не являются полностью определенными классами, то нельзя создавать объекты абстрактных классов. 
Кроме того, абстрактные классы могут содержать и полностью определённые методы, в отличие от сходного с ним по назначению специального вида классов, называемых интерфейсом.

Таким образом, абстрактные классы служат только для создания классов-потомков.
Обычно в абстрактном классе задается набор методов, которые каждый из потомков будет реализовывать по-своему. 
Если класс, являющийся производным от абстрактного класса, не переопределяет все абстрактные методы, то он также является абстрактным и должен иметь модификатор `abstract`.

Абстрактный класс задает интерфейс для всей иерархии, при этом методам класса может не соответствовать никаких конкретных действий. 
В этом случае методы имеют пустое тело и объявляются со спецификатором `abstract`.
В производном классе методы переопределяются с помощью спецификатора `override`.

В некоторых случаях возникает необходимость запретить наследовать от определенного класса.
Ключевое слово `sealed` позволяет описать такой класс, который принято называть бесплодным.

В .NET Framework базовым классом для всех остальных классов и типов является класс `System.Object`.
В языке C\# данный класс носит имя `Object`.
Таким образом, каждый значащий и ссылочный тип в C\# неявно наследуют класс `Object`.
В частности это означает, что переменная ссылочного типа `Object` может ссылаться на объект любого другого типа.

Мы рассматривали выше что класс `Object` имеет следующие открытые виртуальные методы:

- `bool Equals(object obj)` --- возвращает значение `true`, если параметр `obj` является таким же, как и вызывающий объект;
- `int GetHashCode()` --- формирует хеш-код объекта и возвращает целое число, однозначно идентифицирующее объект; может использоваться в алгоритмах, где хеширование используется в качестве средства доступа к хранимым объектам;
- `string ToString()` --- по умолчанию возвращает для ссылочных типов полное имя класса в виде строки, а для значимых типов --- значение величины, преобразованное в строку; данный метод переопределяют для того, чтобы можно было выводить информацию о состоянии объекта.

Переопределить метод `ToString()` можно при помощи следующего объявления метода:

```cs
public override string ToString() {
  // ...
}
```

В Visual Studio после набора слова `override` внутри класса и нажатии клавиши пробела IntelliSense автоматически отображает список всех переопределяемых элементов базового класса (см. рис. @intellisense).

#figure(
  image(
    "lab4_imports/images/intellisense.png",
    width: 80%,
  ),
  caption: [Просмотр списка переопределяемых элементов в Visual Studio],
) <intellisense>

Такое же поведение и подсказки ожидайте в любом другом текстовом редакторе или IDE с настроенным под язык C\# LSP.

=== Пример. 

Требуется разработать класс `BaseCar` ("легковой автомобиль в базовой комплектации"), который содержит виртуальный метод `int GetCost()` ("определить стоимость") и переопределяет методы базового класса `System.Object`.
Кроме того, требуется разработать производный от него класс `ForcedCar` ("легковой автомобиль с гидроусилителем руля"), который будет переопределять метод int `GetCost()`.
Исходный код указанных классов представлен в листингах ниже. В коде использовались комментарии к XML-документации (смотрите Приложение 1 к лабораторной работе).

```cs
namespace MyConsoleApplication {
  /// <summary>
  /// Представляет легковые автомобили в базовой комплектации.
  /// </summary>
  class BaseCar {
    protected string mark; // Марка
    protected int year;    // Год выпуска
    protected int cost;    // Базовая стоимость, руб.

    /// <summary>
    /// Конструктор по умолчанию.
    /// </summary>
    public BaseCar() {
      mark = "Daewoo Nexia";
      year = 2014;
      cost = 209000;
    }

    /// <summary>
    /// Конструктор с параметрами.
    /// </summary>
    /// <param name="mark">Марка</param>
    /// <param name="year">Год выпуска</param>
    /// <param name="cost">Стоимость, руб.</param>
    public BaseCar(string mark, int year, int cost) {
      this.mark = mark;
      this.year = year;
      this.cost = cost;
    }

    /// <summary>
    /// Возвращает результат сравнения объектов.
    /// </summary>
    /// <param name="obj">Объект</param>
    /// <returns>Результат сравнения</returns>
    public override bool Equals(object obj) {
      return base.Equals(obj);
    }

    /// <summary>
    /// Возвращает хеш-код экземпляра класса BaseCar.
    /// </summary>
    /// <returns>Хеш-код объекта</returns>
    public override int GetHashCode() {
      return base.GetHashCode();
    }

    /// <summary>
    /// Возвращает строку с данными об автомобиле.
    /// </summary>
    /// <returns>Строка с данными об автомобиле</returns>
    public override string ToString() {
      return string.Format(
        "Автомобиль: {0}\n" +
        "Год выпуска: {1}\n" +
        "Базовая стоимость: {2} руб.\n",
        mark, year, cost
      );
    }

    /// <summary>
    /// Определяет стоимость в зависимости от года выпуска.
    /// </summary>
    /// <returns>Стоимость, руб.</returns>
    public virtual int GetCost() {
      // Степень уценки в зависимости от года выпуска
      double dis = 1 - (DateTime.Today.Year - year) / 85.0;
      return Convert.ToInt32(cost * dis);
    }


  /// <summary>
  /// Представляет легковые автомобили с гидроусилителем руля.
  /// </summary>
  public class ForcedCar : BaseCar {
    int cost1; // Стоимость гидроусилителя
    int cost2; // Стоимость монтажа

    /// <summary>
    /// Конструктор по умолчанию.
    /// </summary>
    public ForcedCar() : base() {
      cost1 = 7000;
      cost2 = 3000;
    }

    /// <summary>
    /// Конструктор с параметрами.
    /// </summary>
    /// <param name="mark">Марка</param>
    /// <param name="year">Год выпуска</param>
    /// <param name="cost">Базовая стоимость, руб.</param>
    /// <param name="cost1">Стоимость гидроусилителя, руб.</param>
    /// <param name="cost2">Стоимость монтажа, руб.</param>
    public ForcedCar(string mark, int year, int cost, int cost1, int cost2)
      : base(mark, year, cost) {
      this.cost1 = cost1;
      this.cost2 = cost2;
    }

    /// <summary>
    /// Возвращает полную стоимость.
    /// </summary>
    /// <returns>Полную стоимость, руб.</returns>
    public override int GetCost() {
      return base.GetCost() + cost1 + cost2;
    }
  }


  class Program {
    static void Main() {
      Console.Title = "Работа с виртуальными методами";

      BaseCar car1 = new BaseCar();
      ForcedCar car2 = new ForcedCar();
      BaseCar car3 = new BaseCar("Daewoo Matiz", 2013, 230000);
      ForcedCar car4 = new ForcedCar("Daewoo Matiz", 2014, 230000, 6000, 3000);

      BaseCar[] cars = new BaseCar[] { car1, car2, car3, car4 };

      foreach (BaseCar car in cars) {
        Console.WriteLine("Идентификатор: {0}", car.GetHashCode());
        Console.WriteLine(car.ToString());
        Console.WriteLine("Полная стоимость: {0} руб.\n", car.GetCost());
      }

      Console.WriteLine("Результаты сравнения объектов:");
      Console.WriteLine(car1.Equals(car1));
      car1 = car3;
      Console.WriteLine(car3.Equals(car1));
      car3 = car2;
      Console.WriteLine(car3.Equals(car1));

      Console.Read();
    }
  }
}
```
